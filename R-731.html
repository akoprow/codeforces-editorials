<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no"">
  <meta name="generator" content="Jekyll">

  <title>Round 731 (Div. III)</title>

  <!-- Bootstrap -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/js/bootstrap.bundle.min.js" integrity="sha384-ygbV9kiqUc6oa4msXn9868pTtWMgiQaeYH7/t7LECLbyPA2x65Kgf80OJFdroafW" crossorigin="anonymous"></script>

  <link rel="stylesheet" href="/codeforces-editorials/css/main.css">

  <link href="/codeforces-editorials/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Round 731 (Div. III) | Codeforces editorials</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Round 731 (Div. III)" />
<meta name="author" content="Adam Koprowski" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Codeforces Round #731 (Div. 3)" />
<meta property="og:description" content="Codeforces Round #731 (Div. 3)" />
<meta property="og:site_name" content="Codeforces editorials" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-07-10T00:00:00+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Round 731 (Div. III)" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"/codeforces-editorials/R-731","headline":"Round 731 (Div. III)","dateModified":"2021-07-10T00:00:00+01:00","datePublished":"2021-07-10T00:00:00+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"/codeforces-editorials/R-731"},"author":{"@type":"Person","name":"Adam Koprowski"},"description":"Codeforces Round #731 (Div. 3)","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
    extensions: [
      "MathMenu.js",
      "MathZoom.js",
      "AssistiveMML.js",
      "a11y/accessibility-menu.js"
    ],
    jax: ["input/TeX", "output/CommonHTML"],
    TeX: {
      extensions: [
        "AMSmath.js",
        "AMSsymbols.js",
        "noErrors.js",
        "noUndefined.js",
      ]
    }
  });
  </script>
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-SHM3SPE7F9"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-SHM3SPE7F9');
  </script>
</head>


<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/codeforces-editorials/">
    
    <h1>adam@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/codeforces-editorials/"><h2 class="header-link">Contests</h2></a>
<a href="/codeforces-editorials/problems"><h2 class="header-link">Problems</h2></a>
<a href="/codeforces-editorials/todo"><h2 class="header-link">TODO</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>Round 731 (Div. III)</h2>
  <time datetime="2021-07-10T00:00:00+01:00" class="by-line">10 Jul 2021</time>
  <p><a href="https://codeforces.com/contest/1547">Codeforces Round #731 (Div. 3)</a></p>

<div class="alert alert-primary" role="alert">
  
  <tiny>1547</tiny>A

  
  <a href="/codeforces-editorials/problems/1547a/">
    Shortest Path with Obstacle
  </a>
  <a href="https://codeforces.com/contest/1547/problem/A">
  [CF]
  </a>

  <a href="https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r731/1547a-shortest-path-with-obstacle.kt">(Code)</a>

  <rating>R:800 <meter min="800" max="3600" value="800" /></rating>

  <labels>
  
  
    <span class="badge rounded-pill bg-warning text-dark">implementation</span>
  
    <span class="badge rounded-pill bg-warning text-dark">math</span>
  
  </labels>
</div>

<p>Without the obstacle the answer would be: \(\mid x_A - x_B \mid + \mid y_A - y_B \mid\).  Notice that if both the height and weight of the rectangle implied by the start and end points is at least \(2\) then the obstacle does not make a difference as we can walk around it.  In fact the only case when it does make a difference is when we’re travelling in a straight line (either horizontally or vertically) and the obstacle is on our way, in which case we need extra \(2\) moves to walk around it.</p>

<div class="alert alert-primary" role="alert">
  
  <tiny>1547</tiny>B

  
  <a href="/codeforces-editorials/problems/1547b/">
    Alphabetical Strings
  </a>
  <a href="https://codeforces.com/contest/1547/problem/B">
  [CF]
  </a>

  <a href="https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r731/1547b-alphabetical-strings.kt">(Code)</a>

  <rating>R:800 <meter min="800" max="3600" value="800" /></rating>

  <labels>
  
  
    <span class="badge rounded-pill bg-warning text-dark">greedy</span>
  
    <span class="badge rounded-pill bg-warning text-dark">implementation</span>
  
    <span class="badge rounded-pill bg-warning text-dark">strings</span>
  
  </labels>
</div>

<p>A simple constructive approach works: let’s find “a” as the first index (if it does not exist or if multiple copies exist then the answer is clearly “NO”).  From here on in every step we try to extend our index range to left or right depending on which side has the next letter we need.  Every step is uniquely determined and at every step if we cannot make a move or have multiple options for a move then the answer is “NO”.  If we go through all the required letters and process the whole string then it’s a “YES”.</p>

<div class="alert alert-primary" role="alert">
  
  <tiny>1547</tiny>C

  
  <a href="/codeforces-editorials/problems/1547c/">
    Pair Programming
  </a>
  <a href="https://codeforces.com/contest/1547/problem/C">
  [CF]
  </a>

  <a href="https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r731/1547c-pair-programming.kt">(Code)</a>

  <rating>R:1100 <meter min="800" max="3600" value="1100" /></rating>

  <labels>
  
  
    <span class="badge rounded-pill bg-warning text-dark">greedy</span>
  
    <span class="badge rounded-pill bg-warning text-dark">two pointers</span>
  
  </labels>
</div>

<p>Simple greedy approach works.  I.e. at every step we consider next operation for first and second player and any move we can make we do make.  This is because all the moves either help us with further constraints (if we add a new line) or at least do not hinder it (if we modify a line).  If we manage to process all the moves then we’re good; if at any point neither programmer can make progress the answer must be “NO”.</p>

<div class="alert alert-primary" role="alert">
  
  <tiny>1547</tiny>D

  
  <a href="/codeforces-editorials/problems/1547d/">
    Co-growing Sequence
  </a>
  <a href="https://codeforces.com/contest/1547/problem/D">
  [CF]
  </a>

  <a href="https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r731/1547d-co-growing-sequence.kt">(Code)</a>

  <rating>R:1300 <meter min="800" max="3600" value="1300" /></rating>

  <labels>
  
  
    <span class="badge rounded-pill bg-warning text-dark">bitmasks</span>
  
    <span class="badge rounded-pill bg-warning text-dark">greedy</span>
  
  </labels>
</div>

<p>We will build our target sequence element by element and at every step pick the smallest value we possibly can, so that it will be lexicographically smallest by construction.  Let’s keep a running prefix-or \(p\), i.e. the bitwise or of all the elements we’ve considered so far.  This tells us which bits must be set in the final sequence at this position.  So now we can take \(y_i := p \oplus x_i\) so that \(x_i \oplus y_i\) will have the required bit sets (and only those, as that will minimize \(y_i\)).</p>

<div class="alert alert-primary" role="alert">
  
  <tiny>1547</tiny>E

  
  <a href="/codeforces-editorials/problems/1547e/">
    Air Conditioners
  </a>
  <a href="https://codeforces.com/contest/1547/problem/E">
  [CF]
  </a>

  <a href="https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r731/1547e-air-conditioners.kt">(Code)</a>

  <rating>R:1500 <meter min="800" max="3600" value="1500" /></rating>

  <labels>
  
  
    <span class="badge rounded-pill bg-warning text-dark">data structures</span>
  
    <span class="badge rounded-pill bg-warning text-dark">dp</span>
  
    <span class="badge rounded-pill bg-warning text-dark">implementation</span>
  
    <span class="badge rounded-pill bg-warning text-dark">shortest paths</span>
  
    <span class="badge rounded-pill bg-warning text-dark">sortings</span>
  
    <span class="badge rounded-pill bg-warning text-dark">two pointers</span>
  
  </labels>
</div>

<p>Let’s calculate two arrays: \(L\) and \(R\) where \(L\) (resp. \(R\)) is the temperature in each cell if each air conditioner only “works to the left” (resp. right).  This can be done with a single pass, keeping track of current temperature \(t\) and when moving to the new cell we have: \(p := min(p+1, A)\) where \(A\) is the temperature generated by the air conditioner in that cell (or \(\infty\) if there is none).  Note that we can reuse the same code for the second variant only pass in reversed inputs and reverse the output it generates.  Then we get final temperature in each cell simply as \(min(L_i, R_i)\).</p>

<div class="alert alert-primary" role="alert">
  
  <tiny>1547</tiny>F

  
  <a href="/codeforces-editorials/problems/1547f/">
    Array Stabilization (GCD version)
  </a>
  <a href="https://codeforces.com/contest/1547/problem/F">
  [CF]
  </a>

  <a href="https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r731/1547f-array-stabilization-gcd-version.kt">(Code)</a>

  <rating>R:1900 <meter min="800" max="3600" value="1900" /></rating>

  <labels>
  
  
    <span class="badge rounded-pill bg-warning text-dark">binary search</span>
  
    <span class="badge rounded-pill bg-warning text-dark">brute force</span>
  
    <span class="badge rounded-pill bg-warning text-dark">data structures</span>
  
    <span class="badge rounded-pill bg-warning text-dark">number theory</span>
  
    <span class="badge rounded-pill bg-warning text-dark">two pointers</span>
  
  </labels>
</div>

<p>The game ends when all numbers in the array are equal; what will their value be?  It’s not difficult to see that it will be \(g = gcd(a_0, \ldots, a_{n-1})\).  We can also see that solving the problem for the numbers divided by \(g\) will not change the number of steps in the process, but ensures that at the end all numbers equal \(1\).</p>

<p>Now, how many steps will this process take?  It will take at least \(k\) steps only if there are some \(k\) consecutive entries which are all divisible by some \(p &gt; 1\).  So what remains to be done is to factorize all \(a_0, \ldots, a_{n-1}\) and build a map from prime factors to a set of indices that contain it.  Then we go over all such prime factors and for each find the longest segment that has it.  The only tricky bit is that we need to take the circularity into account. One way of doing that is to start with an arbitrary index present in the set and then try to extend it both to the left and to the right as much as possible (including wrapping from \(0\) to \(n-1\)), at the same time removing those entries from the set.</p>

<div class="alert alert-primary" role="alert">
  
  <tiny>1547</tiny>G

  
  <a href="/codeforces-editorials/problems/1547g/">
    How Many Paths?
  </a>
  <a href="https://codeforces.com/contest/1547/problem/G">
  [CF]
  </a>

  <a href="https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r731/1547g-how-many-paths.kt">(Code)</a>

  <rating>R:2100 <meter min="800" max="3600" value="2100" /></rating>

  <labels>
  
  
    <span class="badge rounded-pill bg-warning text-dark">dfs and similar</span>
  
    <span class="badge rounded-pill bg-warning text-dark">dp</span>
  
    <span class="badge rounded-pill bg-warning text-dark">graphs</span>
  
    <span class="badge rounded-pill bg-warning text-dark">trees</span>
  
  </labels>
</div>

<p>This is a problem for understanding of a DFS in directed graphs.  Let’s do the usual thing of keeping state for each vertex while doing the DFS which can be either:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">UNVISITED</code> if we have not reached the vertex yet (this is initial state for all vertices),</li>
  <li><code class="language-plaintext highlighter-rouge">IN_PROGRESS</code> when we started but not yet finished processing the vertex, i.e. we’re still exploring it’s subgraph and</li>
  <li><code class="language-plaintext highlighter-rouge">FINISHED</code> when we’re done with the vertex.</li>
</ul>

<p>Now we will do a DFS with a single source at vertex \(1\).  We have few observations:</p>

<ul>
  <li>if we reach a vertex that is in <code class="language-plaintext highlighter-rouge">IN_PROGRESS</code> state then we’ve just found a cycle and that vertex is part of that cycle.</li>
  <li>if we reach a vertex that is in <code class="language-plaintext highlighter-rouge">FINISHED</code> state then we’ve just found an alternative path to that vertex.</li>
</ul>

<p>Let’s denote the former set of vertices as \(\mathcal{C}\) and the latter as \(\mathcal{A}\).  We then extend \(\mathcal{C}\) to \(\mathcal{\overline{C}}\) by adding to it all the vertices that are reachable from any vertex in \(\mathcal{C}\) (that’s another DFS). Similarly we extend \(\mathcal{A}\) to \(\mathcal{\overline{A}}\).</p>

<p>Finally we have:</p>

<ul>
  <li>if vertex \(v\) was never reached by the initial DFS then it’s unreachable from the initial vertex and we answer \(0\) for it.</li>
  <li>otherwise, if \(v \in \mathcal{\overline{C}}\) then there are infinitely many paths to it so we answer \(-1\).</li>
  <li>otherwise, if \(v \in \mathcal{\overline{A}}\) then there is more than one path to it so we answer \(2\).</li>
  <li>otherwise, there’s a single path only and we answer \(1\).</li>
</ul>

<hr />

<object data="notes/R-731.pdf" width="1000" height="1000" type="application/pdf" />


</article>
      </section>
    </div>
  </div>

   <footer>
  <a href="https://creativecommons.org/licenses/by-nc/3.0/deed.en_US">
    <span>
        <b>Adam Koprowski</b>
    </span>
    
    <span>© 2021</span>
  </a>
</footer>

  
</body>

</html>
