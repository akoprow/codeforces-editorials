Note that to make array $$k$$-similar we pick a position, say $$i$$, and replace the value at that position to $$a_{i-1} < v < a_{i+1}$$ and $$v \neq a_i$$.

It's possible to compute things directly but the simplest solution (I think) is to use prefix sums.  Compute on each position how many $$k$$-similar arrays we can make by changing value at this position, which is trivial given the observation above.  Now for each query just take the sum over the segment, only be careful with segment boundaries as for them we now get more solutions as we loose part of the constraints.  So for a segment $$[l, r]$$ at position $$l$$ we can put anything smaller than $$a_{l+1}$$ and different than $$a_l$$ so we have $$a_{l+1}-2$$ options.  Similarly at position $$r$$ we can put anything greater than $$a_{r-1}$$ and different than $$a_r$$ so we have $$k - a_{r-1} - 1$$ options.  For the rest of the segment just take the sum using precomputed prefix sums.  Be careful for the case where $$l = r$$ in which case any single number other than $$a_l$$ is a solution.
