{% include exercise.md name="Number of Simple Paths" id="1454E" labels="`combinatorics` `dfs and similar` `graphs` `trees`" rating=2000
   code="https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r686/1454e-number-of-simple-paths.kt" %}

The graph is "almost-a-tree"; more precisely it's a single cycle with trees hanging from (some) vertices of said cycle.  If that tree has $$v$$ vertices then, firstly, we have $$v(v-1)/2$$ paths within the tree itself and also $$2v(n-v)$$ paths with vertices outside of the tree. The latter is because: pick vertex in the tree, pick vertex outside of the tree and we have two paths between them: going clockwise or anti-clockwise on the cycle.  If we drop the $$2$$ factor, to avoid double counting, each tree contributes $$v(v-1)/2 + v(n-v)$$ to the answer.

How do we find tree sizes and the cycle?  Simplest is to keep map from node to its size.  Start with everything being of size $$1$$ and moving from the leafs, if $$u$$ is connected to $$v$$ increment $$size_v$$ by $$size_u$$ and if now $$v$$ becomes a leaf add it to the queue to process.  Nodes that remain after this process is done are on the cycle and their sizes will be the sizes of trees attached to them.
