<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no"">
  <meta name="generator" content="Jekyll">

  <title>Round 697 (Div III)</title>

  <!-- Bootstrap -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/js/bootstrap.bundle.min.js" integrity="sha384-ygbV9kiqUc6oa4msXn9868pTtWMgiQaeYH7/t7LECLbyPA2x65Kgf80OJFdroafW" crossorigin="anonymous"></script>

  <link rel="stylesheet" href="/codeforces-editorials/css/main.css">

  <link href="/codeforces-editorials/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Round 697 (Div III) | Codeforces editorials</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Round 697 (Div III)" />
<meta name="author" content="Adam Koprowski" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Codeforces Round #697 (Div. 3)" />
<meta property="og:description" content="Codeforces Round #697 (Div. 3)" />
<meta property="og:site_name" content="Codeforces editorials" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-01-25T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Round 697 (Div III)" />
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"Round 697 (Div III)","dateModified":"2021-01-25T00:00:00+00:00","url":"/codeforces-editorials/R-697","datePublished":"2021-01-25T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"/codeforces-editorials/R-697"},"author":{"@type":"Person","name":"Adam Koprowski"},"description":"Codeforces Round #697 (Div. 3)","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
    extensions: [
      "MathMenu.js",
      "MathZoom.js",
      "AssistiveMML.js",
      "a11y/accessibility-menu.js"
    ],
    jax: ["input/TeX", "output/CommonHTML"],
    TeX: {
      extensions: [
        "AMSmath.js",
        "AMSsymbols.js",
        "noErrors.js",
        "noUndefined.js",
      ]
    }
  });
  </script>
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-SHM3SPE7F9"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-SHM3SPE7F9');
  </script>
</head>


<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/codeforces-editorials/">
    
    <h1>adam@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/codeforces-editorials/"><h2 class="header-link">Contests</h2></a>
<a href="/codeforces-editorials/problems"><h2 class="header-link">Problems</h2></a>
<a href="/codeforces-editorials/todo"><h2 class="header-link">TODO</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>Round 697 (Div III)</h2>
  <time datetime="2021-01-25T00:00:00+00:00" class="by-line">25 Jan 2021</time>
  <p><a href="https://codeforces.com/contest/1475">Codeforces Round #697 (Div. 3)</a></p>

<div class="alert alert-primary" role="alert">
  
  <tiny>1475</tiny>A

  
  <a href="/codeforces-editorials/problems/1475a/">
    Odd Divisor
  </a>
  <a href="https://codeforces.com/contest/1475/problem/A">
  [CF]
  </a>

  <a href="https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475a-odd-divisor.kt">(Code)</a>

  <rating>R:900 <meter min="800" max="3600" value="900" /></rating>

  <labels>
  
  
    <span class="badge rounded-pill bg-warning text-dark">bitmasks</span>
  
    <span class="badge rounded-pill bg-warning text-dark">math</span>
  
    <span class="badge rounded-pill bg-warning text-dark">number theory</span>
  
  </labels>
</div>

<p>Surprisingly difficult for Div III A, me thinks!</p>

<p>Problem limits are too large to check all divisors of numbers.  So we need to do better than that.  Let’s think about factorization of a given number \(x\):</p>

\[x = p_1^{\alpha_1} \cdot \ldots p_n^{\alpha_n}\]

<p>If any of the factors is odd then clearly \(x\) is divisible by an odd factor.  Now, the only prime number that isn’t odd is \(2\) itself.  So the only number \(x\) that does not have an odd divisor is if \(x = 2^i\) for some \(i\).</p>

<p>So we only need to check if \(x\) is a power of \(2\); either naively, or, if we want to be fancy, by checking if \(x \&amp; (x-1) = 0\).</p>

<div class="alert alert-primary" role="alert">
  
  <tiny>1475</tiny>B

  
  <a href="/codeforces-editorials/problems/1475b/">
    New Year's Number
  </a>
  <a href="https://codeforces.com/contest/1475/problem/B">
  [CF]
  </a>

  <a href="https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475b-new-years-numer.kt">(Code)</a>

  <rating>R:900 <meter min="800" max="3600" value="900" /></rating>

  <labels>
  
  
    <span class="badge rounded-pill bg-warning text-dark">brute force</span>
  
    <span class="badge rounded-pill bg-warning text-dark">dp</span>
  
    <span class="badge rounded-pill bg-warning text-dark">math</span>
  
  </labels>
</div>

<p>Suppose that there is \(x\) and \(y\) such that:</p>

\[n = 2020 \cdot x + 2021 \cdot y = 2020 \cdot (x + y) + y\]

<p>We can see that \(n - y\) is divisible by \(2020\).  Take \(y = n \mod 2020\) and we get that \(x = \frac{n-y}{2020} - y\) and we only need to check that \(x \ge 0\).</p>

<div class="alert alert-primary" role="alert">
  
  <tiny>1475</tiny>C

  
  <a href="/codeforces-editorials/problems/1475c/">
    Ball in Berland
  </a>
  <a href="https://codeforces.com/contest/1475/problem/C">
  [CF]
  </a>

  <a href="https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475c-ball-in-berland.kt">(Code)</a>

  <rating>R:1400 <meter min="800" max="3600" value="1400" /></rating>

  <labels>
  
  
    <span class="badge rounded-pill bg-warning text-dark">combinatorics</span>
  
    <span class="badge rounded-pill bg-warning text-dark">dfs and similar</span>
  
    <span class="badge rounded-pill bg-warning text-dark">graphs</span>
  
    <span class="badge rounded-pill bg-warning text-dark">hashing</span>
  
    <span class="badge rounded-pill bg-warning text-dark">math</span>
  
  </labels>
</div>

<p>We can iterate over pairs \((a_i, b_i)\) and for each one we can add:</p>

\[k - F_a(a_i) - F_b(b_i) - 1\]

<p>where \(F_v(x)\) is the number of \(x\) within vector \(v\).  In other words:</p>

<ul>
  <li>we take \((a_i, b_i)\) as the first pair,</li>
  <li>out of the k-1 remaining pairs how many are there that <em>cannot</em> complement the first pair?  Well, all the ones with boy \(a_i\) in it (as he’s taken) and all the ones with girl \(b_i\) (she’s also taken).  Note that there is only one pair \((a_i, b_i)\) so all the other pairs excluded because of the girl and because of the boy are disjoint, which is why the formula works.</li>
</ul>

<div class="alert alert-primary" role="alert">
  
  <tiny>1475</tiny>D

  
  <a href="/codeforces-editorials/problems/1475d/">
    Cleaning the Phone
  </a>
  <a href="https://codeforces.com/contest/1475/problem/D">
  [CF]
  </a>

  <a href="https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475d-cleaning-the-phone.kt">(Code)</a>

  <rating>R:1800 <meter min="800" max="3600" value="1800" /></rating>

  <labels>
  
  
    <span class="badge rounded-pill bg-warning text-dark">binary search</span>
  
    <span class="badge rounded-pill bg-warning text-dark">dp</span>
  
    <span class="badge rounded-pill bg-warning text-dark">greedy</span>
  
    <span class="badge rounded-pill bg-warning text-dark">number theory</span>
  
    <span class="badge rounded-pill bg-warning text-dark">sortings</span>
  
    <span class="badge rounded-pill bg-warning text-dark">two pointers</span>
  
  </labels>
</div>

<p>Let’s split applications into two groups: one with \(b_i = 1\) (normal) and the other with \(b_i = 2\) (important).  For each group let’s take the application size in decreasing order and compute prefix sums.</p>

<p>We will iterate over \(x\), indicating how many elements we take from the normal group, from \(0\) up to all the elements in the group.  We compute how much size will that free us up which is the sum of the first \(x\) elements.  Based on that we compute how much more space we need to free up with important applications.  We find the number of important applications we need to remove, \(y\), using binary search.</p>

<p>Having those two we know that we will loose \(2y+x\) convenience points and we pick the minimum one.</p>

<p>Actually, instead of binary search we can use two pointers as as we take more and more of normal applications, we will always be decreasing the number of important applications.  So we don’t even need prefix sums, just two pointers over those two arrays.</p>

<div class="alert alert-primary" role="alert">
  
  <tiny>1475</tiny>E

  
  <a href="/codeforces-editorials/problems/1475e/">
    Advertising Agency
  </a>
  <a href="https://codeforces.com/contest/1475/problem/E">
  [CF]
  </a>

  <a href="https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475e-advertising-agency.kt">(Code)</a>

  <rating>R:1600 <meter min="800" max="3600" value="1600" /></rating>

  <labels>
  
  
    <span class="badge rounded-pill bg-warning text-dark">combinatorics</span>
  
    <span class="badge rounded-pill bg-warning text-dark">implementation</span>
  
    <span class="badge rounded-pill bg-warning text-dark">math</span>
  
    <span class="badge rounded-pill bg-warning text-dark">sortings</span>
  
  </labels>
</div>

<p>Clearly we must pick the bloggers with most followers.  So we can sort by the number of followers and choose the first \(k\) of them.</p>

<p>The only leeway we have is when the last chosen blogger has \(x\) followers and some not chosen bloggers also have \(x\) followers; we can swap them and still have the maximum number of followers.  In other words all bloggers with \(x\) followers are interchangeable for us.  Suppose there are \(k\) such bloggers in the prefix we picked and \(n\) in total in our pool of bloggers.  Well clearly the number of ways in which we can choose them is \({n}\choose{k}\).</p>

<div class="alert alert-primary" role="alert">
  
  <tiny>1475</tiny>F

  
  <a href="/codeforces-editorials/problems/1475f/">
    Unusual Matrix
  </a>
  <a href="https://codeforces.com/contest/1475/problem/F">
  [CF]
  </a>

  <a href="https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475f-unusual-matrix.kt">(Code)</a>

  <rating>R:1900 <meter min="800" max="3600" value="1900" /></rating>

  <labels>
  
  
    <span class="badge rounded-pill bg-warning text-dark">constructive algorithms</span>
  
    <span class="badge rounded-pill bg-warning text-dark">dfs and similar</span>
  
    <span class="badge rounded-pill bg-warning text-dark">greedy</span>
  
  </labels>
</div>

<p>Few observations.</p>

<ul>
  <li>Order of operations does not matter (because xor is commutative)</li>
  <li>It does not make sense to apply the same operation twice (as it then will cancel itself out)</li>
</ul>

<p>One way to think about it is that going from \(a\) to \(b\) is equivalent to going to a matrix of all zeroes from a matrix \(c\) where \(c_{i,j} = [a_{i,j} \neq b_{i,j}]\) (i.e. \(1\) if given cells in both matrices are different, \(0$ otherwise).  So matrix\)c$$ essentially tells us which cells we need to flip (to zero them).</p>

<p>Now, we will now say that columns \(i\) and \(j\) are compatible if either:</p>

<ul>
  <li>for each row \(p\), \(c_{p,i} = c_{p,i}\) or</li>
  <li>for each row \(p\), \(a_{p,i} \neq c_{p,i}\).</li>
</ul>

<p>In the first case those columns are already equal, in the second case we can make them equal by applying xor to either of the columns.</p>

<p>Now, let’s check if all columns are compatible with the first one.  If they are we can make all rows identical.  And if we have all rows identical it’s a win, we just flip all those column which are all \(1\) and get a matrix full of zeroes.</p>

<p>Otherwise, we cannot make all rows equal by applying row operations and so column operations will not help us because there will always be at least one column with some \(0\) and some \(1\) and then that will remain so after applying an operation to it.</p>

<div class="alert alert-primary" role="alert">
  
  <tiny>1475</tiny>G

  
  <a href="/codeforces-editorials/problems/1475g/">
    Strange Beauty
  </a>
  <a href="https://codeforces.com/contest/1475/problem/G">
  [CF]
  </a>

  <a href="https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475g-strange-beauty.kt">(Code)</a>

  <rating>R:1900 <meter min="800" max="3600" value="1900" /></rating>

  <labels>
  
  
    <span class="badge rounded-pill bg-warning text-dark">dp</span>
  
    <span class="badge rounded-pill bg-warning text-dark">graphs</span>
  
    <span class="badge rounded-pill bg-warning text-dark">math</span>
  
    <span class="badge rounded-pill bg-warning text-dark">number theory</span>
  
  </labels>
</div>

<p>Firstly, let’s sort the input array.  Now for each number \(x\) we will want to see how many numbers smaller than \(x\) we can put together with \(x\) to form a beautiful array.  We keep track of a mapping from a number to that value, let’s call that \(f\), and when seeing \(x\) update mapping for \(x\) to:</p>

\[\max_{d \in \mathcal{D}(x)} f(d)+1\]

<p>where \(\mathcal{D}{x}\) is a set of all divisors of \(x\).  In other words we go through all divisors of \(d\) (those are all numbers that can be with \(x\) in a beautiful array) and pick the best one, adding \(1\) because we extend the sequence with \(x\).</p>

<p>To do that we need to efficiently iterate through all divisors of any number and we do that by precomputing all divisors of all numbers up to \(2 \cdot 10^5\) using the sieve of Eratosthenes.</p>

<p>I actually had a lot of problems avoiding TLE on this problem with Kotlin.</p>

<hr />

<object data="notes/R-697.pdf" width="1000" height="1000" type="application/pdf" />


</article>
      </section>
    </div>
  </div>

   <footer>
  <a href="https://creativecommons.org/licenses/by-nc/3.0/deed.en_US">
    <span>
        <b>Adam Koprowski</b>
    </span>
    
    <span>© 2021</span>
  </a>
</footer>

  
</body>

</html>
