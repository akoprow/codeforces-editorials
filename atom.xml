<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Codeforces editorials</title>
    <description>Codeforces editorials</description>
    <link></link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <author>
      <name>Adam Koprowski</name>
      <email>Adam.Koprowski@gmail.com</email>
      <uri></uri>
    </author>
    
      <item>
        <title>Round 732 (Div. I+II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1545&quot;&gt;Codeforces Round #732 (Div. 1)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1546&quot;&gt;Codeforces Round #732 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1546&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1546a/&quot;&gt;
    AquaMoon and Two Arrays
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1546/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r732/1546a-AquaMoon-and-two-arrays.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s build lists of indices that need to be increased/decreased by 1.  So if \(a_i &amp;gt; b_i\) then insert entry \(i\) into the decrement list \(a_i-b_i\) times and similarly for \(a_i &amp;lt; b_i\).  Now, if those two lists have different lengths then clearly there is no solution.  Otherwise, just pair them up into operations (zip) and we’re done.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1546&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1546b/&quot;&gt;
    AquaMoon and Stolen String
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1546/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r732/1546b-AquaMoon-and-stolen-string.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s reconstruct the stolen string index by index.  For any given position let’s count the frequencies of all letters.  Note that letters will appear in pairs: once from the list of original strings and once from the scrambled up strings (but we do not care about the order) and only the stolen string’s letter will contribute once without a pair.  So we can keep track of parities and the only letter occurring odd number of times is from the stolen string.&lt;/p&gt;

&lt;p&gt;Alternatively, we can keep a multiset of letters (again, per index) and add all the ones from the original string and then remove the ones from the paired up strings.  The only letter remaining is from the secret string.&lt;/p&gt;

&lt;p&gt;Yet another approach is to xor the letters together.  All pairs will cancel each other out and we will be left with the secret letter.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1546&lt;/tiny&gt;C / &lt;tiny&gt;1545&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1546c/&quot;&gt;
    AquaMoon and Strange Sort
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1546/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r732/1546c-AquaMoon-and-strange-sort.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We can see that the nonsense with arrows essentially means that each number can move an even number of positions. So we can count for all letters how many times they occur on even positions in: a) the original array, b) the sorted array.  If those two numbers are equal then we can go from one to the other; otherwise, we cannot.  So the answer is “YES” iff. the multisets obtained from numbers at even positions in original and sorted arrays are equal.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1546&lt;/tiny&gt;D / &lt;tiny&gt;1545&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1546d/&quot;&gt;
    AquaMoon and Chess
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1546/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r732/1546d-AquaMoon-and-chess.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;First simple observation is understanding what do the moves mean.  Essentially we need to have two adjacent pawns and we can move them (both together) to the left or right (provided that position is empty).&lt;/p&gt;

&lt;p&gt;A more difficult observation is that the only things that matter are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;the number of disjoint groups of pawns \(g\) (i.e. \(5\) pawns in a row give us two groups) and&lt;/li&gt;
  &lt;li&gt;the number of empty positions \(e\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That is because we can move from any such configuration to any other such configuration. So the final answer is \({g+e}\choose{g}\).&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TODO&lt;/code&gt;: This is very hand-wave’y; understand better and improve this description.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1546&lt;/tiny&gt;E / &lt;tiny&gt;1545&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1546e/&quot;&gt;
    AquaMoon and Permutations
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1546/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1546&lt;/tiny&gt;F / &lt;tiny&gt;1545&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1546f/&quot;&gt;
    AquaMoon and Wrong Coordinate
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1546/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1545&lt;/tiny&gt;E1

  
  &lt;a href=&quot;/codeforces-editorials/problems/1545e1/&quot;&gt;
    AquaMoon and Time Stop (easy version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1545/problem/E1&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1545&lt;/tiny&gt;E2

  
  &lt;a href=&quot;/codeforces-editorials/problems/1545e2/&quot;&gt;
    AquaMoon and Time Stop (hard version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1545/problem/E2&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1545&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1545f/&quot;&gt;
    AquaMoon and Potatoes
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1545/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-732.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Sun, 11 Jul 2021 00:00:00 +0100</pubDate>
        <link>//R-732</link>
        <link href="/R-732"/>
        <guid isPermaLink="true">/R-732</guid>
      </item>
    
      <item>
        <title>Round 731 (Div. III)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1547&quot;&gt;Codeforces Round #731 (Div. 3)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1547&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1547a/&quot;&gt;
    Shortest Path with Obstacle
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1547/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r731/1547a-shortest-path-with-obstacle.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Without the obstacle the answer would be: \(\mid x_A - x_B \mid + \mid y_A - y_B \mid\).  Notice that if both the height and weight of the rectangle implied by the start and end points is at least \(2\) then the obstacle does not make a difference as we can walk around it.  In fact the only case when it does make a difference is when we’re travelling in a straight line (either horizontally or vertically) and the obstacle is on our way, in which case we need extra \(2\) moves to walk around it.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1547&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1547b/&quot;&gt;
    Alphabetical Strings
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1547/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r731/1547b-alphabetical-strings.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;A simple constructive approach works: let’s find “a” as the first index (if it does not exist or if multiple copies exist then the answer is clearly “NO”).  From here on in every step we try to extend our index range to left or right depending on which side has the next letter we need.  Every step is uniquely determined and at every step if we cannot make a move or have multiple options for a move then the answer is “NO”.  If we go through all the required letters and process the whole string then it’s a “YES”.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1547&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1547c/&quot;&gt;
    Pair Programming
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1547/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r731/1547c-pair-programming.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Simple greedy approach works.  I.e. at every step we consider next operation for first and second player and any move we can make we do make.  This is because all the moves either help us with further constraints (if we add a new line) or at least do not hinder it (if we modify a line).  If we manage to process all the moves then we’re good; if at any point neither programmer can make progress the answer must be “NO”.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1547&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1547d/&quot;&gt;
    Co-growing Sequence
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1547/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r731/1547d-co-growing-sequence.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We will build our target sequence element by element and at every step pick the smallest value we possibly can, so that it will be lexicographically smallest by construction.  Let’s keep a running prefix-or \(p\), i.e. the bitwise or of all the elements we’ve considered so far.  This tells us which bits must be set in the final sequence at this position.  So now we can take \(y_i := p \oplus x_i\) so that \(x_i \oplus y_i\) will have the required bit sets (and only those, as that will minimize \(y_i\)).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1547&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1547e/&quot;&gt;
    Air Conditioners
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1547/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r731/1547e-air-conditioners.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;shortest paths&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s calculate two arrays: \(L\) and \(R\) where \(L\) (resp. \(R\)) is the temperature in each cell if each air conditioner only “works to the left” (resp. right).  This can be done with a single pass, keeping track of current temperature \(t\) and when moving to the new cell we have: \(p := min(p+1, A)\) where \(A\) is the temperature generated by the air conditioner in that cell (or \(\infty\) if there is none).  Note that we can reuse the same code for the second variant only pass in reversed inputs and reverse the output it generates.  Then we get final temperature in each cell simply as \(min(L_i, R_i)\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1547&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1547f/&quot;&gt;
    Array Stabilization (GCD version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1547/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r731/1547f-array-stabilization-gcd-version.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;The game ends when all numbers in the array are equal; what will their value be?  It’s not difficult to see that it will be \(g = gcd(a_0, \ldots, a_{n-1})\).  We can also see that solving the problem for the numbers divided by \(g\) will not change the number of steps in the process, but ensures that at the end all numbers equal \(1\).&lt;/p&gt;

&lt;p&gt;Now, how many steps will this process take?  It will take at least \(k\) steps only if there are some \(k\) consecutive entries which are all divisible by some \(p &amp;gt; 1\).  So what remains to be done is to factorize all \(a_0, \ldots, a_{n-1}\) and build a map from prime factors to a set of indices that contain it.  Then we go over all such prime factors and for each find the longest segment that has it.  The only tricky bit is that we need to take the circularity into account. One way of doing that is to start with an arbitrary index present in the set and then try to extend it both to the left and to the right as much as possible (including wrapping from \(0\) to \(n-1\)), at the same time removing those entries from the set.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1547&lt;/tiny&gt;G

  
  &lt;a href=&quot;/codeforces-editorials/problems/1547g/&quot;&gt;
    How Many Paths?
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1547/problem/G&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r731/1547g-how-many-paths.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;This is a problem for understanding of a DFS in directed graphs.  Let’s do the usual thing of keeping state for each vertex while doing the DFS which can be either:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNVISITED&lt;/code&gt; if we have not reached the vertex yet (this is initial state for all vertices),&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IN_PROGRESS&lt;/code&gt; when we started but not yet finished processing the vertex, i.e. we’re still exploring it’s subgraph and&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FINISHED&lt;/code&gt; when we’re done with the vertex.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now we will do a DFS with a single source at vertex \(1\).  We have few observations:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;if we reach a vertex that is in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IN_PROGRESS&lt;/code&gt; state then we’ve just found a cycle and that vertex is part of that cycle.&lt;/li&gt;
  &lt;li&gt;if we reach a vertex that is in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FINISHED&lt;/code&gt; state then we’ve just found an alternative path to that vertex.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let’s denote the former set of vertices as \(\mathcal{C}\) and the latter as \(\mathcal{A}\).  We then extend \(\mathcal{C}\) to \(\mathcal{\overline{C}}\) by adding to it all the vertices that are reachable from any vertex in \(\mathcal{C}\) (that’s another DFS). Similarly we extend \(\mathcal{A}\) to \(\mathcal{\overline{A}}\).&lt;/p&gt;

&lt;p&gt;Finally we have:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;if vertex \(v\) was never reached by the initial DFS then it’s unreachable from the initial vertex and we answer \(0\) for it.&lt;/li&gt;
  &lt;li&gt;otherwise, if \(v \in \mathcal{\overline{C}}\) then there are infinitely many paths to it so we answer \(-1\).&lt;/li&gt;
  &lt;li&gt;otherwise, if \(v \in \mathcal{\overline{A}}\) then there is more than one path to it so we answer \(2\).&lt;/li&gt;
  &lt;li&gt;otherwise, there’s a single path only and we answer \(1\).&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-731.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Sat, 10 Jul 2021 00:00:00 +0100</pubDate>
        <link>//R-731</link>
        <link href="/R-731"/>
        <guid isPermaLink="true">/R-731</guid>
      </item>
    
      <item>
        <title>Round 730 (Div. II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1543&quot;&gt;Codeforces Round #730 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1543&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1543a/&quot;&gt;
    Exciting Bets
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1543/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r730/1543a-exciting-bets.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, if \(a = b\) then we can gen infinite result by continuing to increment them both. Otherwise, without loss of generality assume \(a &amp;gt; b\).  Note that \(a - b\), let’s denote it by \(d\), does not change under the operations.  Also, we have \(gcd(a, b) = gcd(a, a - b) = gcd(a, d)\) so the answer is bound by \(d\).  And we can always get \(d\) as we can always decrease \((a, b)\) down to \((d, 0)\).  However, we might be able to do it in fewer moves as it’s enough to move \(a\) – either up, or down – to any multiple of \(d\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1543&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1543b/&quot;&gt;
    Customising the Track
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1543/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r730/1543b-customising-the-track.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;It’s fairly easy to see that the optimal arrangement is to make the traffic on all tracks as evenly distributed as possible.  Let’s denote by \(S = \sum_i a_i\).  If \(S \mod n = 0\) then we can make the traffic exactly equal on all tracks and the answer is \(0\).  Otherwise, we’ll have \(S \mod n\) tracks that have traffic greater by one than the other \(n - (S \mod n)\) tracks.  Those two classes of tracks are the only ones that contribute to the answer, each one contributes \(1\) for a total of\((S \mod n) \cdot (n - (S \mod n))\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1543&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1543c/&quot;&gt;
    Need for Pink Slips
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1543/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r730/1543c-need-for-pink-slips.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;probabilities&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Crucial observation is that \(v \ge 1.0\), which means that after every move the probability for the pink slip increases by at least \(0.05\) and so there will be at most \(21\) draws and we can brute force the process for a \(O(2^21)\) solution without any memoization at all.&lt;/p&gt;

&lt;p&gt;As to precision problems we need to be careful when comparing doubles.  We can either use \(\epsilon\) in comparisons or convert everything to longs.  For the latter notice that there are at most four digits after the dot so we can just multiply everything by \(10,000\) and then again by \(2^{20}\) to ensure we have enough precision for divisions by two that we might have to perform at every step.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1543&lt;/tiny&gt;D1

  
  &lt;a href=&quot;/codeforces-editorials/problems/1543d1/&quot;&gt;
    RPD and Rap Sheet (Easy Version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1543/problem/D1&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r730/1543d1-RPD-and-rap-sheet-easy.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We have \(n\) guesses and \(n\) possible passwords; is there a way for us to try all options one by one?  The problem is that after each guess the password changes… but we do know &lt;em&gt;how&lt;/em&gt; it changes.  If the password was \(pass_{old}\) and we guessed \(guess\) then it changes to \(pass_{new}\) such that: \(pass_{old} \oplus pass_{new} = guess\), i.e. \(pass_{new} = pass_{old} \oplus guess\).  So after \(i\) guesses we have: \(pass_{new} = pass_{old} \oplus guess_1 \oplus \ldots \oplus guess_i\).  We can maintain \(p = guess_1 \oplus \ldots \oplus guess_i\) and in the i’th query we can check if the original password was \(i\) by querying for \(i \oplus p\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1543&lt;/tiny&gt;D2

  
  &lt;a href=&quot;/codeforces-editorials/problems/1543d2/&quot;&gt;
    RPD and Rap Sheet (Hard Version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1543/problem/D2&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1543&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1543e/&quot;&gt;
    The Final Pursuit
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1543/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;divide and conquer&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-730.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Wed, 07 Jul 2021 00:00:00 +0100</pubDate>
        <link>//R-730</link>
        <link href="/R-730"/>
        <guid isPermaLink="true">/R-730</guid>
      </item>
    
      <item>
        <title>Round 724 (Div II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1536&quot;&gt;Codeforces Round #724 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1536&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1536a/&quot;&gt;
    Omkar and Bad Story
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1536/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r724/1536a-omkar-and-bad-story.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Tricky until you realize that:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If any number is negative then the answer is “NO”.  This is because: take that negative number and the largest other number \(p\) (there must be at least one).  The difference between them will be larger than \(p\) and we’d have to repeat this process ad infinitum adding new numbers so no dice.&lt;/li&gt;
  &lt;li&gt;Otherwise all the numbers are between \(0\) and \(100\) so \(0, 1, \ldots, 100\) is always a valid answer.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1536&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1536b/&quot;&gt;
    Prinzessin der Verurteilung
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1536/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r724/1536b-prinzessin-der-verurteilung.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We can iterate over all candidates for the MEX and try them one by one.  Note that the answer will be at most \(3\) characters long since there are more 3 character combinations than we can pack into a string of length \(1000\).  So we can solve this neatly with a short and sweet three loops.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1536&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1536c/&quot;&gt;
    Diluc and Kaeya
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1536/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r724/1536c-diluc-and-kaeya.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;hashing&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;I solved it in a much more convoluted way but a simple solution goes as follows.&lt;/p&gt;

&lt;p&gt;Visualize this on a XY plane where ‘D’ goes up and ‘K’ goes right.  The tangent corresponds to the ration of \(Ds/Ks\) and so we can split at every point which has the same tangent as our current point.  So we can just count the numbers of ‘D’, \(c_D\), and ‘K’, \(c_K\), store them in a multiset of pairs as:&lt;/p&gt;

\[(\frac{c_D}{gcd(c_D, c_K)}, \frac{c_K}{gcd(c_D, c_K)})\]

&lt;p&gt;and the cardinality of the element we’re inserting is the answer at that position.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1536&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1536d/&quot;&gt;
    Omkar and Medians
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1536/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r724/1536d-omkar-and-medians.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We can solve this by keeping track of:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(v_1 \le v_2 \ldots \le v_n\) being the elements that must necessarily belong to the array we’re trying to reconstruct.&lt;/li&gt;
  &lt;li&gt;\(c_\ge\): the number of elements that are greater or equal than \(v_n\) but otherwise unconstrained and&lt;/li&gt;
  &lt;li&gt;\(c_\le\): the number of elements that are smaller or equal than \(v_1\) but otherwise unconstrained.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that when considering a new element:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;if it’s not in \(v_1, \ldots, v_n\) we need to add it there,&lt;/li&gt;
  &lt;li&gt;all the remaining moves can be used to increment \(c_\ge\) or \(c_\le\) in such a way as to try to make our element a new median (note that it might not be possible)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It can be implemented using an Ordered Statistic Tree.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1536&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1536e/&quot;&gt;
    Omkar and Forest
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1536/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r724/1536e-omkar-and-forest.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;shortest paths&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s say we fixed positions of \(0\)s and all the rest must be different than \(0\).  The crucial observation is that everything else is uniquely determined.  One way to see that is to visualize a BFS starting from all the \(0\)s at once and by so doing assigning to every cell its closest distance to some \(0\).  If we do that clearly all values only move by \(1\).  And indeed positive values have something smaller than them, namely, the cell on the path to the closest \(0\).&lt;/p&gt;

&lt;p&gt;So the only choice we have is for every cell with “#” whether to turn it into a \(0\) or not, hence the answer is \(2^\mathcal{Q}\), where \(\mathcal{Q}\) is the number of cells with “#”.  The only edge case is when all the cells have “#”, in which case we need to subtract \(1\) from the answer as there must be at least one cell with \(0\) (to “bootstrap” our BFS).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1536&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1536f/&quot;&gt;
    Omkar and Akmar
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1536/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;games&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-724.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Sun, 06 Jun 2021 00:00:00 +0100</pubDate>
        <link>//R-724</link>
        <link href="/R-724"/>
        <guid isPermaLink="true">/R-724</guid>
      </item>
    
      <item>
        <title>Educational Round 110</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1535&quot;&gt;Educational Codeforces Round 110 (Rated for Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1535&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1535a/&quot;&gt;
    Fair Playoff
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1535/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu110/1535a-fair-playoff.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We can easily determine winners/losers in both matches let’s denote them as \(w_1/l_1\) for the first match and \(w_2/l_2\) for the second one.&lt;/p&gt;

&lt;p&gt;Then the tournament is fair iff:&lt;/p&gt;

\[w_2 &amp;gt; l_1 \land w_1 &amp;gt; l_2\]

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1535&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1535b/&quot;&gt;
    Array Reodering
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1535/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu110/1535b-array-reordering.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;The optimal strategy is to put the even numbers at the front of the array, as then they will form a good pair with both even and odd numbers to their right.&lt;/p&gt;

&lt;p&gt;So let’s say we have \(n_{even}\) even elements and \(n_{odd}\) odd ones.  We have the following observations:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;all the even elements form good pairs with all the other even elements, which contributes: \(n_{even}\cdot(n_{even}-1)/2\).&lt;/li&gt;
  &lt;li&gt;all the even elements form good pairs with all the odd elements (since we put them to their right), contributing: \(n_{even} \cdot n_{odd}\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So we’re left with figuring out how many good pairs do we have among odd elements.  Since none of the elements is divisible by \(2\) the elements \(x\) and \(y\) form a good pair only if \(gcd(x, y) &amp;gt; 1\) and we can check that condition directly for all the pairs of odd elements.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1535&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1535c/&quot;&gt;
    Unstable String
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1535/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu110/1535c-unstable-string.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We’ll iterate through characters and keep track of two variables: \(z\) and \(o\), indicating, the lengths of the longest beautiful string ending at current position with a \(0\), respectively, \(1\).&lt;/p&gt;

&lt;p&gt;Transitions are as follows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;if next character is \(0\): \((z', o') := (o+1, 0)\) because we can extend a beautiful string ending with a \(1\) by one character and get another beautiful string and there is no way for us to end with a \(1\).  This contributes \(z'\) (for all the beautiful strings ending with a \(0\)).&lt;/li&gt;
  &lt;li&gt;if next character is \(1\) it’s symmetrical: \((z', o') := (0, z+1)\) and we add \(o'\) to the answer.&lt;/li&gt;
  &lt;li&gt;if next characters is \(?\) we have: \((z', o') := (o+1, z+1)\) since we can replace \(?\) with either \(0\) or \(1\).  Note however that this contributes \(max(z', o')\) as we can pick whatever we like for \(?\) to make the beautiful string as long as possible (but we cannot score for both \(0\) and \(1\) variants at once).&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1535&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1535d/&quot;&gt;
    Playoff Tournament
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1535/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu110/1535d-playoff-tournament.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Visualize the tournament bracket as a binary tree.  Leaves are first round games.  Root is the final.  Values in the nodes denote the number of teams that can win a given game.  For simplicity let’s actually add an extra layer of leaves which are all \(1\) and will never change: those are the teams on their own.  Then for the internal nodes we have the following rules depending on the value in the string for that game:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;for \(0\), i.e. lower numbered team wins, then the value of the node equals the value of the left child&lt;/li&gt;
  &lt;li&gt;for \(1\) then, similarly, the value is the values of the right child and&lt;/li&gt;
  &lt;li&gt;for \(?\), i.e. either team can win, it’s the sum of both children.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can easily construct that tree for the initial configuration and we can also easily update, as each update only changes the node in question, plus requires re-computation for all the nodes on the path to the root.  The only difficulty remaining is to translate between game numbers and positions of the nodes in our binary tree (which, of course, we store in an array).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1535&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1535e/&quot;&gt;
    Gold Transfer
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1535/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1535&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1535f/&quot;&gt;
    String Distance
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1535/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;hashing&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/Edu-110.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Fri, 04 Jun 2021 00:00:00 +0100</pubDate>
        <link>//Edu-110</link>
        <link href="/Edu-110"/>
        <guid isPermaLink="true">/Edu-110</guid>
      </item>
    
      <item>
        <title>Round 722 (Div. I+II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1528&quot;&gt;Codeforces Round #722 (Div. 1)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1529&quot;&gt;Codeforces Round #722 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1529&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1529a/&quot;&gt;
    Eshag Loves Big Arrays
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1529/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r722/1529a-Eshag-loves-big-arrays.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, it’s easy to see that we will never be able to remove the minimal element(s).  To do so we would need the average of picked numbers to be strictly less than the minimum, but this is impossible as the minimum is the smallest number we can pick.&lt;/p&gt;

&lt;p&gt;Secondly, we can remove all the other elements: just pick the minimum and the element to be removed.&lt;/p&gt;

&lt;p&gt;So, overall, we just check what’s the minimum, count how many such elements there are and everything else can be removed.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1529&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1529b/&quot;&gt;
    Sifid and Strange Subsequences
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1529/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r722/1529b-Sifid-and-strange-subsequences.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;First, observe that we can always add all non-positive elements.  For them \(\mid x - y \mid \ge 0\) and the maximum is at most \(0\) so we’re good.&lt;/p&gt;

&lt;p&gt;Can we add more?  It’s easy to see that we cannot add more than one positive elements.  Suppose we tried to add \(x, y &amp;gt; 0\), but then we have \(\mid x - y \mid &amp;lt; x\) and so necessarily also less than maximum.&lt;/p&gt;

&lt;p&gt;So now we now we can add at most one positive number.  Clearly the smallest one is the best as it puts least constraints.  So just take it and see if it works by checking all consecutive pairs in sorted order.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1529&lt;/tiny&gt;C / &lt;tiny&gt;1528&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1529c/&quot;&gt;
    Parsa's Humongous Tree
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1529/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r722/1529c-Parsa's-humongous-tree.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Exercise says \(a_i \in [l_i, r_i]\) but the intuition suggests that in the optimal solution we can always pick either \(l_i\) or \(r_i\).  How can we convince ourselves that’s true?  Say we have \(a_i \in (l_i, r_i)\).  Let’s then count how many of the neighbours have values smaller/larger than \(a_i\).  If there are more smaller neighbours then we’ll get a better result by increasing \(a_i\) so we might as well increase it all the way to \(r_i\) (note that by doing so we might increase that imbalance even more).  Similarly for the symmetrical case when there are more larger neighbours, in which case \(l_i\) is better.  What if those two sets are equal?  Moving to \(l_i\) or \(r_i\) will at either not make a difference (if we don’t “cross” any of the other numbers by making this move) or improve the result (if we do cross at least one).&lt;/p&gt;

&lt;p&gt;Now that we know that we only need to consider \(l_i\) and \(r_i\) let’s root the tree at an arbitrary node and for all nodes \(u\) we can calculate \(\mathcal{D}_{u,\leftarrow}\) and \(\mathcal{D}_{u,\rightarrow}\) which are the best results we can get for the subtree at \(u\) picking \(l_i\), respectively, \(r_i\), for its value.  Then we do a DFS and calculate those values from leaves up to the root.  The respective equations are rather straightforward.  Clearly, the final answer is
\(max(\mathcal{D}_{r,\leftarrow}, \mathcal{D}_{r,\rightarrow})\) where \(r\) is the root we picked.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1529&lt;/tiny&gt;D / &lt;tiny&gt;1528&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1529d/&quot;&gt;
    Kavi on Pairing Duty
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1529/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r722/1529d-Kavi-on-pairing-duty.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s denote the number of combinations for \(n\) pairs of points by \(f(n)\).  So let’s say we have \(n\) pairs of points, how can we connect them?&lt;/p&gt;

&lt;p&gt;Firstly, we can connect the first and last points, everything else will be inside that arc so we can put there any solution for \(n-1\) pairs of points.  Similarly we can connect first and last but one and second and last points; the arcs will intersect but will have the same length and we have \(n-2\) points left that we can use arbitrarily as they’ll be inside those two initial arcs.  And so on.&lt;/p&gt;

&lt;p&gt;Secondly, we can make all the arcs have equal lengths, which will trivially satisfy correctness constraints. For instance for 6 points we can connect them as: \((1, 2), (3, 4), (5, 6)\) or \((1, 4), (2, 5), (3, 6)\) with arc lengths of \(1\) and \(3\) respectively.  Notice that the number of points being divisible by the arc lengths is the only requirement here.&lt;/p&gt;

&lt;p&gt;Putting those two together we get the final formula as:&lt;/p&gt;

\[f(n) = \mathcal{D}(n) + \sum_{i \in {1 \ldots n-1}} f(i)\]

&lt;p&gt;where \(\mathcal{D}(n)\) is the number of divisors of \(n\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1529&lt;/tiny&gt;E / &lt;tiny&gt;1528&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1529e/&quot;&gt;
    Trees of Tranquillity
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1529/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1529&lt;/tiny&gt;F / &lt;tiny&gt;1528&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1529f/&quot;&gt;
    It's a bird! No, it's a plane! No, it's AaParsa!
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1529/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;shortest paths&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1528&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1528e/&quot;&gt;
    Mashtali and Hagh Trees
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1528/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1528&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1528f/&quot;&gt;
    AmShZ Farm
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1528/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;fft&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-722.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Mon, 24 May 2021 00:00:00 +0100</pubDate>
        <link>//R-722</link>
        <link href="/R-722"/>
        <guid isPermaLink="true">/R-722</guid>
      </item>
    
      <item>
        <title>Round 721 (Div. I+II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1527&quot;&gt;Codeforces Round #721 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1527&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1527a/&quot;&gt;
    And Then There Were K
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1527/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r721/1527a-and-then-there-were-k.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s take the highest set bit in \(n\), suppose it is \(2^k\).  Now, clearly \((2^k) \&amp;amp; (2^k-1) = 0\) as the former only has the \(k\)-th bit set and the latter has all the lower bits but not the \(k\)-th one.  So \(2^k-1\) is an answer.  It’s easy to see that there is not a better one since all numbers from \(2^k\) up to \(n\) have the \(k\)-th bit set.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1527&lt;/tiny&gt;B1

  
  &lt;a href=&quot;/codeforces-editorials/problems/1527b1/&quot;&gt;
    Palindrome Game (easy version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1527/problem/B1&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/codeforces/r720-739/r721/1527b1-palindrome-game-easy.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;games&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, let’s assume that the palindrome has an even length.  Then Bob wins.  This is because initially string is a palindrome so Alice needs to turn some \(0\) into \(1\) and Bob can:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If there is more than one \(0\) left he mimics this move at the corresponding position in the palindrome.  This again gives a palindrome to Alice in her next move.&lt;/li&gt;
  &lt;li&gt;If there is only one \(0\) he can reverse the palindrome and so Alice will be forced in the next move to remove the remaining \(0\) and lose by at least \(2\$\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What if the initial palindrome has an odd length?  If the character in the middle is \(1\) then it does not change anything.  If it’s a zero then Alice can turn it into \(1\) and win as now Bob is given the starting position equivalent to that for even-length scenario described above.&lt;/p&gt;

&lt;p&gt;Note that those conditions can be simplified as: Bob wins if there is an even number of zeroes whereas Alice wins if there is an odd number.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1527&lt;/tiny&gt;B2

  
  &lt;a href=&quot;/codeforces-editorials/problems/1527b2/&quot;&gt;
    Palindrome Game (hard version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1527/problem/B2&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r721/1527b2-palindrome-game-hard.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;games&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We covered in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B1&lt;/code&gt; the case when the string is a palindrome.  If it is not then Alice almost always wins as she can:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;revert the string, unless&lt;/li&gt;
  &lt;li&gt;the string is one step away from becoming a palindrome with an even number of zeroes.  In that case she makes it so and we’re back to a palindrome case, in which Alice wins by at least \(2\$\) and she paid \(1\$\) in this steps so she still wins.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The only scenario that leads to a draw is if the string has \(2\) zeroes and one of them is in the middle as in this case they will both pay \(1\$\) when played optimally:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If Alice takes the non-middle \(0\), Bob needs to take the middle.&lt;/li&gt;
  &lt;li&gt;If Alice reverts the string then Bob takes the non-middle \(0\) and Alice needs to take the middle one.&lt;/li&gt;
  &lt;li&gt;If Alice take the middle \(0\) then Bob reverts and Alice lost so she will not do that.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1527&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1527c/&quot;&gt;
    Sequence Pair Weight
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1527/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r721/1527c-sequence-pair-weight.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;hashing&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s look at all the contributions of all segments ending at character \(i\).  They can be classified as:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;All the contributions ending at character \(i-1\) (we extend those by 1 letter to the right but not yet count the pairs matched with character \(i\)).&lt;/li&gt;
  &lt;li&gt;Suppose we have another occurrence of the same element at index \(j\) (\(j &amp;lt; i\)), how much will this pair contribute?  Well, \(j\), as it will be included in subsegments \([1, i], [2, i], \ldots [j, i]\).  So overall we get \(j_1 + \ldots + j_n\) where \(j_1, \ldots, j_n\) are indices of previous occurrences of the element at position \(i\).  We can easily keep track of that by having a map from element to the prefix sum of its indices seen so far.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1527&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1527d/&quot;&gt;
    MEX Tree
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1527/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1527&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1527e/&quot;&gt;
    Partition Game
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1527/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;divide and conquer&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-721.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Thu, 20 May 2021 00:00:00 +0100</pubDate>
        <link>//R-721</link>
        <link href="/R-721"/>
        <guid isPermaLink="true">/R-721</guid>
      </item>
    
      <item>
        <title>Round 719 (Div III)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1520&quot;&gt;Codeforces Round #719 (Div. 3)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1520&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1520a/&quot;&gt;
    Do Not Be Distracted!
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1520/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r719/1520a-do-not-be-distracted.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We can do it in one pass: consider all blocks of problems (i.e. ignore a problem if it’s the same as the previous one, meaning it belongs to the same block).  Now if any problem has at least \(2\) groups then the teacher can be suspicious.&lt;/p&gt;

&lt;p&gt;Alternatively, for every problem find its first and last occurrence.  All the positions in between must also belong to that problem or else the teacher can be suspicious.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1520&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1520b/&quot;&gt;
    Ordinary Numbers
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1520/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r719/1520b-ordinary-numbers.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Simply iterate through all the digits from \(1\) to \(9\) and for each digit keep constructing ordinary numbers with increasing number of digits (i.e. \(d, dd, ddd, \ldots\)) until they exceed \(n\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1520&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1520c/&quot;&gt;
    Not Adjacent Matrix
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1520/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r719/1520c-not-adjacent-matrix.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;As it turns out \(n = 2\) is the only case where there is no answer.  For all the other numbers we can do a simple construction of dividing the board into black and white cells, like a chessboard.  First fill black cells row by row from \(1\) going up and then continue, similarly, with higher numbers for white cells, so that for instance for \(n = 3\) we get:&lt;/p&gt;

\[\begin{pmatrix}1 &amp;amp; 6 &amp;amp; 2 \\ 7 &amp;amp; 3 &amp;amp; 8 \\ 4 &amp;amp; 9 &amp;amp; 5 \end{pmatrix}\]

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1520&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1520d/&quot;&gt;
    Same Differences
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1520/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r719/1520d-same-differences.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;hashing&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;So \(a_j − a_i = j − i\) can be represented equivalently as:  \(a_j - j = a_i - a_i\).  So we can transform each number \(a_i\) into \(a_i - i\) and now the problem can be reduced to finding the number of equal values in such transformed array.  We do that simply by doing frequency counts and each value occurring \(x\) times gives us \(\frac{x \cdot (x-1)}{2}\) such pairs.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1520&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1520e/&quot;&gt;
    Arranging The Sheep
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1520/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r719/1520e-arranging-the-sheep.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;I solved it by considering all sheeps one by one and assuming that a given sheep is stationary.  Then with a DP it’s possible for every prefix to compute the cost of moving all the sheep up until that position to form a line ending at that position (i.e. going from \(*.*.* \to ..***\)) and similarly for every suffix.&lt;/p&gt;

&lt;p&gt;But actually there’s a much simpler solution hinging on the fact that if there are \(k\) sheeps then in the optimal solution sheep \(\lceil \frac{k}{2} \rceil\) should remain stationary and then it’s just a simple single sweep calculation.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1520&lt;/tiny&gt;F1

  
  &lt;a href=&quot;/codeforces-editorials/problems/1520f1/&quot;&gt;
    Guess the K-th Zero (Easy version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1520/problem/F1&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r719/1520f1-guess-the-kth-zero-easy.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;This is just a simple binary search.  We will maintain a segment in which the \(k\)‘th zero must be, starting with the full \([0, n-1]\) segment.&lt;/p&gt;

&lt;p&gt;Let’s say we are looking for the \(k\)‘th zero and we know it is within \([l, r]\).  Pick \(m = \lfloor \frac{l+r}{2} \rfloor\), ask for segment \([l, m]\).  Let’s say the answer is \(s\).  Than means that there are \(z = m-l+1-s\) zeros in that segment and so:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;if \(z \ge k\) then we continue searching for \(k\) zeros in \([l, m]\)&lt;/li&gt;
  &lt;li&gt;if \(z &amp;lt; k\) then we continue searching for \(k-z\) zeros in \([m+1, r]\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We end up asking at most \(\log n\) queries, which is fine.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1520&lt;/tiny&gt;F2

  
  &lt;a href=&quot;/codeforces-editorials/problems/1520f2/&quot;&gt;
    Guess the K-th Zero (Hard version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1520/problem/F2&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r719/1520f2-guess-the-kth-zero-hard.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;This is similar to the easy problem except we need to be smarter and remember responses and re-use answers rather than asking again.&lt;/p&gt;

&lt;p&gt;When doing so we need to be careful to account for the changes in the array by remembering that the zeroes we guessed so far were changed into ones.  The easiest way to do it is to store answers pertaining to the original array and then when re-using an answer for segment \([l, r]\), add to it the number of guessed zeros we’ve made so far in that range (by using an OST).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1520&lt;/tiny&gt;G

  
  &lt;a href=&quot;/codeforces-editorials/problems/1520g/&quot;&gt;
    To Go Or Not To Go?
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1520/problem/G&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r719/1520g-to-go-or-not-to-go.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;shortest paths&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, observe that there is no point to using portal more than once.  If we have a solution that uses portal multiple times then we can always jump from the first portal immediately to the last, removing the part in the middle and reducing the cost.  So the answer can have one of the two forms:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;go from start to end without any use of portals.&lt;/li&gt;
  &lt;li&gt;go from start to portal \(A\), teleport to \(B\) and go from there to the end.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can compute costs of those options by doing a flood algorithm from start and keeping track of:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;the cheapest direct route to the end (if any) and&lt;/li&gt;
  &lt;li&gt;the cheapest way to some portal + cost of taking that portal.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Then we do flood from the end to compute:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;the cheapest way from end to some portal + cost of taking it.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Combining the two we get the answers for the original two options and we’re done.&lt;/p&gt;

&lt;p&gt;Careful that both start and end can be portals (I failed during the contest because of that).&lt;/p&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-719.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Wed, 05 May 2021 00:00:00 +0100</pubDate>
        <link>//R-719</link>
        <link href="/R-719"/>
        <guid isPermaLink="true">/R-719</guid>
      </item>
    
      <item>
        <title>Educational Round 107</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1511&quot;&gt;Educational Codeforces Round 107 (Rated for Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1511&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1511a/&quot;&gt;
    Review Site
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1511/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu107/1511a-review-site.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;The basic idea is to send all the nay-sayers to the second server and all the positive ones to the first ones, hence ensuring that everyone who’s undecided says yes.  Helpfully draws are in our favour so the answer is simply the total number of reviewers of types \(1\) and \(3\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1511&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1511b/&quot;&gt;
    GCD Length
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1511/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu107/1511b-GCD-length.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Since \(10 = 2 \cdot 5\) we have that \(10^i = 2^i \cdot 5^i\).  So let’s take \(x = 100\ldots 0 \cdot 10^{c-1}\) and \(y = 111\ldots 1 \cdot 10^{c-1}\). We have \(gcd(x, y) = 10^{c-1}\) since \(10^i\) and \(11\ldots1\) are relatively prime.  So we can prepend the prefix of required length to both \(x\) and \(y\) and we’re done.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1511&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1511c/&quot;&gt;
    Yet Another Card Deck
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1511/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu107/1511c-yet-another-card-deck.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, clearly we only need to keep track of the top card of each color.  Secondly, when we move card from position \(p\) to the top then the index of all the cards which previously had an index less than \(p\) increases by \(1\).  So this easily leads to a simulation of the process with \(O(nk)\) complexity.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1511&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1511d/&quot;&gt;
    Min Cost String
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1511/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu107/1511d-min-cost-string.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;It was fairly easy to solve it (greedily) but much harder to prove that that (greedy) solution works.  The main observation is that we have \(k^2\) pairs of letters and we want to use them “uniformly”, i.e. if the generated string is short enough then just use as many of those pairs as we can, as that will give us a \(0\) cost.  Otherwise, try to repeat each pair as few times as possible.  We essentially do it by keeping track of unused pairs and being careful not to get into a letter from which we cannot move forward (i.e. do not follow \(x\) with \(y\) if there are no moves from \(y\)).  Once we use all the pairs recreate them again and start from scratch.&lt;/p&gt;

&lt;p&gt;There’s a nice interpretation of this problem where we are basically looking for an Eulerian cycle in a graph (a clique actually) of letters.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1511&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1511e/&quot;&gt;
    Colorings and Dominoes
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1511/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1511&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1511f/&quot;&gt;
    Chainword
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1511/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;matrices&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1511&lt;/tiny&gt;G

  
  &lt;a href=&quot;/codeforces-editorials/problems/1511g/&quot;&gt;
    Chips on a Board
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1511/problem/G&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;games&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/Edu-107.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Mon, 12 Apr 2021 00:00:00 +0100</pubDate>
        <link>//Edu-107</link>
        <link href="/Edu-107"/>
        <guid isPermaLink="true">/Edu-107</guid>
      </item>
    
      <item>
        <title>Round 712 (Div I+II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1503&quot;&gt;Codeforces Round #712 (Div. 1)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1504&quot;&gt;Codeforces Round #712 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1504&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1504a/&quot;&gt;
     Déjà Vu
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1504/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r712/1504a-deja-vu.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We cannot just try inserting “a” at every position and checking if we get a palindrome as that will TLE.  However, note that we can just try inserting at the beginning and at the end.  If neither works then there’s no solution.  Why?   Since \(a\vec{x}\) is a palindrome and \(\vec{x}a\) is a palindrome then clearly \(\vec{v}\) starts and ends with an \(a\) and in fact is just a sequence of \(a\) so clearly inserting \(a\) anything into it will not give us a palindrome.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1504&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1504b/&quot;&gt;
    Flip the Bits
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1504/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r712/1504b-flip-the-bits.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We should start fixing from the end, as if some suffix is good we don’t need to touch it ever again.  So we go from the end of the string and keep track of:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;a flag indicating whether we flipped the prefix and&lt;/li&gt;
  &lt;li&gt;number of \(0\)s and \(1\)s in the prefix.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If at current position we get something else than what we need (after taking into account that prefix might have been flipped) then we need to flip that prefix.  So if number of \(0\)s and \(1\)s is different then there’s no solution.  Otherwise we flip the “prefix-flipped” flag and continue.  Regardless of whether the current position matches or not we also update number of \(0/1\) in the prefix.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1504&lt;/tiny&gt;C / &lt;tiny&gt;1503&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1504c/&quot;&gt;
    Balance the Bits
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1504/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r712/1504c-balance-the-bits.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Think of the usual way to check for correctness of such an expression where we count \(+1/-1\) for “(“ / “)” and need to never go below zero and end up with zero.  Note that for both \(a\) and \(b\) we will have some values contributed by the common substring, say \(x\), and some contributed by the parts where they must differ, call it \(y_a\) and \(y_b\).  Then we have that:&lt;/p&gt;

&lt;p&gt;\(x + y_a = 0\) and \(x + y_b = 0\)&lt;/p&gt;

&lt;p&gt;Hence \(y_a = y_b\) but we also know that \(y_a = -y_b\) as those two parts are complementary (i.e. if one has an opening bracket the other one has a closing one and vice versa).  Hence we conclude that \(x = y_a = y_b = 0\).  That means that:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;number of positions on which \(a\) and \(b\) agree must be even and will be split evenly between opening and closing brackets.&lt;/li&gt;
  &lt;li&gt;number of positions on which they differ must be even and we will alternate between opening and closing bracket for it.&lt;/li&gt;
  &lt;li&gt;to minimize the chance that we go below zero at some point (i.e. produce unmatched closing bracket) let’s start with the half of opening brackets and finish with all closing brackets for the common part.&lt;/li&gt;
  &lt;li&gt;all that’s left at this point is to construct \(a\) and \(b\) in the unique way prescribed above and check whether they both are valid expressions.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1504&lt;/tiny&gt;D / &lt;tiny&gt;1503&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1504d/&quot;&gt;
    3-Coloring
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1504/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r712/1504d-3-coloring.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;games&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s think of the grid as a chessboard with alternating black and white squares.  Firstly let’s fill one black and one white square with any, but different, numbers.  We can always do that as:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;in the first move, for the black square, we have two numbers to choose from and either works; say we end up with \(x\)&lt;/li&gt;
  &lt;li&gt;in the second move, for the white square, one number is forbidden, one we potentially cannot use because we used it on black but one number remains; say it’s \(y\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;From there on we just continue filling black with \(x\) and white squares with \(y\).  At some point we will have filled all black (or white) squares but at this point we can put any number on white (black) other than \(x\) (\(y\)).  Again we can always do that as we cannot use \(x\) and we cannot use whatever Alice forbids us to, but one option always remains.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1504&lt;/tiny&gt;E / &lt;tiny&gt;1503&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1504e/&quot;&gt;
    Travelling Salesman Problem
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1504/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;shortest paths&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1504&lt;/tiny&gt;F / &lt;tiny&gt;1503&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1504f/&quot;&gt;
    Flip the Cards
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1504/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;2-sat&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1503&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1503e/&quot;&gt;
    2-Coloring
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1503/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1503&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1503f/&quot;&gt;
    Balance the Cards
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1503/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;divide and conquer&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;geometry&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-712.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Sat, 03 Apr 2021 00:00:00 +0100</pubDate>
        <link>//R-712</link>
        <link href="/R-712"/>
        <guid isPermaLink="true">/R-712</guid>
      </item>
    
  </channel>
</rss>
