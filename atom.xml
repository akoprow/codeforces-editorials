<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Codeforces editorials</title>
    <description>Codeforces editorials</description>
    <link></link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <author>
      <name>Adam Koprowski</name>
      <email>Adam.Koprowski@gmail.com</email>
      <uri></uri>
    </author>
    
      <item>
        <title>Educational Round 103</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1476&quot;&gt;Educational Codeforces Round 103 (Rated for Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476a/&quot;&gt;
    K-divisible Sum
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu103/1476a-k-divisible-sum.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We essentially have three cases:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(n \ge k\) and \(n\) is divisible by \(k\) then the answer is \(1\) as all elements equal to \(1\) are a correct solution&lt;/li&gt;
  &lt;li&gt;\(n \ge k\) but \(n\) not divisible by \(k\) then the answer is \(2\) as all \(1\) is not divisible by \(k\) and we need to bump up some elements to \(2\).&lt;/li&gt;
  &lt;li&gt;\(k &amp;lt; n\) the answer is \(\lceil \frac{k}{n} \rceil\) as we are aiming for the total sum to be \(k\) in this case and that’s the maximum we will need to put in a single element.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476b/&quot;&gt;
    Inflation
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu103/1476b-inflation.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We want:&lt;/p&gt;

\[\frac{p_i}{p_0 + \ldots + p_{i-1}} \le \frac{k}{100}\]

&lt;p&gt;or, equivalently:&lt;/p&gt;

\[100 \cdot p_i \le k \cdot (p_0 + \ldots + p_{i-1})\]

&lt;p&gt;We compute that by keeping track of the running sum.  If at any point the equation does not hold we compute the delta by which we need to increase the running sum, i.e.:&lt;/p&gt;

\[\lceil \frac{100 \cdot p_i - k \cdot (p_0 + \ldots + p_{i-1}}{k} \rceil\]

&lt;p&gt;we update the running sum and continue further.  The sum of all the deltas is our answer.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476c/&quot;&gt;
    Longest Simple Cycle
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu103/1476c-longest-simple-cycle.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;It’s clear that the cycle’s right side will be one of the chains.  So we’ll iterate over that chain, \(i\), and will keep track of the current longest cycle that we can built to the left of \(i\), let’s call that \(q_i\).  To simplify things, notice that we can swap \(a_i\) and \(b_i\) without influencing the result, so let’s normalize it so that always \(a_i &amp;lt; b_i\).&lt;/p&gt;

&lt;p&gt;We have two cases.  If \(a_i = b_i\) then the current chain is connected to the same vertex so \(q_i = 2\) as we can only use the two links to that vertex.&lt;/p&gt;

&lt;p&gt;Otherwise we have two options (a picture is worth a thousand words so see notes for a diagram)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;either we follow the links to the previous chain and then follow that chain, that gives us \(2 + b_i - a_i\) or&lt;/li&gt;
  &lt;li&gt;we follow the links and then combine it with the longest cycle so far for \(2 + q_{i-1} + (a_i - 1) + (c_{i-1} - b_i)\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We combine those two options for the final formula:&lt;/p&gt;

\[q_i = 2 + max(b_i - a_i, q_{i-1} + (a_i - 1) + (c_{i-1} - b_i))\]

&lt;p&gt;Now at each position we close the cycle so need to add the path traversed along the last chain so the final answer is \(max_i (q_i + c_i - 1)\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476d/&quot;&gt;
    Journey
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu103/1476d-journey.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dsu&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;The crucial observation is that if we start at city \(i\) and move to other city \(j\), we can always come back to \(i\).  We can easily see that that’s possible after one step and we can prove it for arbitrary number of steps by induction (or just convince ourselves that it works by observing \(2\) or \(3\) steps).&lt;/p&gt;

&lt;p&gt;So now for each city we compute \(L(i)\) and \(L_rev(i)\) denoting how many steps to the left can we move from city \(i\) in initial/reversed setup (all arrows reversed), respectively.  We have \(L(i) = L_rev(i-1)+1\) if \(s_{i-1} = &quot;L&quot;\) and \(0\) otherwise.  Similarly \(L_rev(i) = L(i-1) + 1\) if \(s_{i-1} = &quot;R&quot;\) and \(0\) otherwise.&lt;/p&gt;

&lt;p&gt;Now, we do the same for \(R(i)\) and \(R_rev(i)\) to compute our moves to the right.  And we combine it for each city by seeing how far we can go to the left and right, plus the city itself, giving us the final answer for city \(i\) of: \(L_i + R_i + 1\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476e/&quot;&gt;
    Pattern Matching
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476f/&quot;&gt;
    Lanterns
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;G

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476g/&quot;&gt;
    Minimum Difference
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/G&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/Edu-103.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Fri, 29 Jan 2021 00:00:00 +0000</pubDate>
        <link>//Edu-103</link>
        <link href="/Edu-103"/>
        <guid isPermaLink="true">/Edu-103</guid>
      </item>
    
      <item>
        <title>Round 697 (Div III)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1475&quot;&gt;Codeforces Round #697 (Div. 3)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1475&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1475a/&quot;&gt;
    Odd Divisor
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1475/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475a-odd-divisor.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Surprisingly difficult for Div III A, me thinks!&lt;/p&gt;

&lt;p&gt;Problem limits are too large to check all divisors of numbers.  So we need to do better than that.  Let’s think about factorization of a given number \(x\):&lt;/p&gt;

\[x = p_1^{\alpha_1} \cdot \ldots p_n^{\alpha_n}\]

&lt;p&gt;If any of the factors is odd then clearly \(x\) is divisible by an odd factor.  Now, the only prime number that isn’t odd is \(2\) itself.  So the only number \(x\) that does not have an odd divisor is if \(x = 2^i\) for some \(i\).&lt;/p&gt;

&lt;p&gt;So we only need to check if \(x\) is a power of \(2\); either naively, or, if we want to be fancy, by checking if \(x \&amp;amp; (x-1) = 0\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1475&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1475b/&quot;&gt;
    New Year's Number
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1475/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475b-new-years-numer.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Suppose that there is \(x\) and \(y\) such that:&lt;/p&gt;

\[n = 2020 \cdot x + 2021 \cdot y = 2020 \cdot (x + y) + y\]

&lt;p&gt;We can see that \(n - y\) is divisible by \(2020\).  Take \(y = n \mod 2020\) and we get that \(x = \frac{n-y}{2020} - y\) and we only need to check that \(x \ge 0\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1475&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1475c/&quot;&gt;
    Ball in Berland
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1475/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475c-ball-in-berland.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;hashing&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We can iterate over pairs \((a_i, b_i)\) and for each one we can add:&lt;/p&gt;

\[k - F_a(a_i) - F_b(b_i) - 1\]

&lt;p&gt;where \(F_v(x)\) is the number of \(x\) within vector \(v\).  In other words:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;we take \((a_i, b_i)\) as the first pair,&lt;/li&gt;
  &lt;li&gt;out of the k-1 remaining pairs how many are there that &lt;em&gt;cannot&lt;/em&gt; complement the first pair?  Well, all the ones with boy \(a_i\) in it (as he’s taken) and all the ones with girl \(b_i\) (she’s also taken).  Note that there is only one pair \((a_i, b_i)\) so all the other pairs excluded because of the girl and because of the boy are disjoint, which is why the formula works.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1475&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1475d/&quot;&gt;
    Cleaning the Phone
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1475/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475d-cleaning-the-phone.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s split applications into two groups: one with \(b_i = 1\) (normal) and the other with \(b_i = 2\) (important).  For each group let’s take the application size in decreasing order and compute prefix sums.&lt;/p&gt;

&lt;p&gt;We will iterate over \(x\), indicating how many elements we take from the normal group, from \(0\) up to all the elements in the group.  We compute how much size will that free us up which is the sum of the first \(x\) elements.  Based on that we compute how much more space we need to free up with important applications.  We find the number of important applications we need to remove, \(y\), using binary search.&lt;/p&gt;

&lt;p&gt;Having those two we know that we will loose \(2y+x\) convenience points and we pick the minimum one.&lt;/p&gt;

&lt;p&gt;Actually, instead of binary search we can use two pointers as as we take more and more of normal applications, we will always be decreasing the number of important applications.  So we don’t even need prefix sums, just two pointers over those two arrays.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1475&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1475e/&quot;&gt;
    Advertising Agency
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1475/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475e-advertising-agency.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Clearly we must pick the bloggers with most followers.  So we can sort by the number of followers and choose the first \(k\) of them.&lt;/p&gt;

&lt;p&gt;The only leeway we have is when the last chosen blogger has \(x\) followers and some not chosen bloggers also have \(x\) followers; we can swap them and still have the maximum number of followers.  In other words all bloggers with \(x\) followers are interchangeable for us.  Suppose there are \(k\) such bloggers in the prefix we picked and \(n\) in total in our pool of bloggers.  Well clearly the number of ways in which we can choose them is \({n}\choose{k}\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1475&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1475f/&quot;&gt;
    Unusual Matrix
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1475/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475f-unusual-matrix.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Few observations.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Order of operations does not matter (because xor is commutative)&lt;/li&gt;
  &lt;li&gt;It does not make sense to apply the same operation twice (as it then will cancel itself out)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;One way to think about it is that going from \(a\) to \(b\) is equivalent to going to a matrix of all zeroes from a matrix \(c\) where \(c_{i,j} = [a_{i,j} \neq b_{i,j}]\) (i.e. \(1\) if given cells in both matrices are different, \(0$ otherwise).  So matrix\)c$$ essentially tells us which cells we need to flip (to zero them).&lt;/p&gt;

&lt;p&gt;Now, we will now say that columns \(i\) and \(j\) are compatible if either:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;for each row \(p\), \(c_{p,i} = c_{p,i}\) or&lt;/li&gt;
  &lt;li&gt;for each row \(p\), \(a_{p,i} \neq c_{p,i}\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the first case those columns are already equal, in the second case we can make them equal by applying xor to either of the columns.&lt;/p&gt;

&lt;p&gt;Now, let’s check if all columns are compatible with the first one.  If they are we can make all rows identical.  And if we have all rows identical it’s a win, we just flip all those column which are all \(1\) and get a matrix full of zeroes.&lt;/p&gt;

&lt;p&gt;Otherwise, we cannot make all rows equal by applying row operations and so column operations will not help us because there will always be at least one column with some \(0\) and some \(1\) and then that will remain so after applying an operation to it.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1475&lt;/tiny&gt;G

  
  &lt;a href=&quot;/codeforces-editorials/problems/1475g/&quot;&gt;
    Strange Beauty
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1475/problem/G&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475g-strange-beauty.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, let’s sort the input array.  Now for each number \(x\) we will want to see how many numbers smaller than \(x\) we can put together with \(x\) to form a beautiful array.  We keep track of a mapping from a number to that value, let’s call that \(f\), and when seeing \(x\) update mapping for \(x\) to:&lt;/p&gt;

\[\max_{d \in \mathcal{D}(x)} f(d)+1\]

&lt;p&gt;where \(\mathcal{D}{x}\) is a set of all divisors of \(x\).  In other words we go through all divisors of \(d\) (those are all numbers that can be with \(x\) in a beautiful array) and pick the best one, adding \(1\) because we extend the sequence with \(x\).&lt;/p&gt;

&lt;p&gt;To do that we need to efficiently iterate through all divisors of any number and we do that by precomputing all divisors of all numbers up to \(2 \cdot 10^5\) using the sieve of Eratosthenes.&lt;/p&gt;

&lt;p&gt;I actually had a lot of problems avoiding TLE on this problem with Kotlin.&lt;/p&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-697.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Mon, 25 Jan 2021 00:00:00 +0000</pubDate>
        <link>//R-697</link>
        <link href="/R-697"/>
        <guid isPermaLink="true">/R-697</guid>
      </item>
    
      <item>
        <title>Round 696 (Div II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1474&quot;&gt;Codeforces Round #696 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1474&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1474a/&quot;&gt;
    Puzzle From the Future
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1474/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r696/1474a-puzzle-from-the-future.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly note that we always have a choice for every position in \(a\) (\(0\) or \(1\)), which in turn will always lead to a choice for a digit in \(d\).  That means we can make all the digits in \(d\) different and hence make \(d\) of maximum possible length \(n\).  So now it comes down to greedily making digits in \(d\) as large as possible from left to right which we can do by choosing \(1\) for a digit of \(a\) if possible and \(0\) otherwise.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1474&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1474b/&quot;&gt;
    Different Divisors
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1474/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r696/1474b-different-divisors.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;To have at least four divisors \(a\) must be either a product of two primes \(d = p \cdot q\), giving four divisors: \(1, p, q, p \cdot q\), or \(d = p^3\) with divisors: \(1, p, p^2, p^3\).&lt;/p&gt;

&lt;p&gt;For the first case all those divisors need to be at least \(d\) apart, the simplest way to find them is for \(p\) to start from \(d+1\) and pick for it the first prime encountered and, similarly, for \(q\) to pick the first prime greater than or equal to \(p+d\).&lt;/p&gt;

&lt;p&gt;We can prove that it’s enough to consider only the first case as the second one would lead to a larger \(d\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1474&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1474c/&quot;&gt;
    Array Destruction
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1474/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r696/1474c-array-destruction.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Observe that \(x\) strictly decreases after each operation.  We should greedily in each step handle the largest element in the array.  Why?  Suppose at some step we did not.  That means we have \(a_i \le a_j \lt a_k\) and we decide to throw \(a_i + a_j = x\).  After that operation new \(x\) becomes \(a_j \lt a_k\) and so we’ll never be able to get rid of \(a_k\).&lt;/p&gt;

&lt;p&gt;So we sort numbers and process them from the right. In the first step what do we process the largest element with?  Well, let’s try all elements one by one.&lt;/p&gt;

&lt;p&gt;Once we know what’s the pairing we remove it, know what the next \(x\) becomes and continue.  This requires an ordered multiset and leads to \(O(n^2 \log n)\) complexity which was TLE-ing for me.&lt;/p&gt;

&lt;p&gt;Another approach is to start from the largest element and keep track of a multiset \(\mathcal{M}\) of paired elements that we haven’t processed yet.  In each step, looking at \(a_i\), we have two options:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;either the current element is in the multiset, in which case we remove it from it (essentially completing a past pairing or&lt;/li&gt;
  &lt;li&gt;it is not, in which case&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1474&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1474d/&quot;&gt;
    Cleaning
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1474/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r696/1474d-cleaning.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s first solve it without using the superability. Since piles that were not neighbours do not get connected when removing another pile, the only way to get rid of the first pile is by removing it together with the second pile, which is only possible if \(a_1 \le a_2\), in which case we’re left with \(a_2-a_1, a_3, \ldots, a_n\) and we can repeat that reasoning.  By repeating this process for every position \(i\) we can compute \(l_i\) which is the number of stones left on that position after removing all the piles to the left (or undefined is it’s not possible to remove them).  We can do a similar process from right to left and compute \(r_i\).  Now, if \(l_n = 0\) then we’re done without having to use superability.&lt;/p&gt;

&lt;p&gt;Otherwise, we need to see if it can help us.  To do that for all adjacent indices we can consider swapping them.  That means that we’re looking at: \(l_i, a_{i+1}, a_{i+2}, r_{i+3}\) (provided \(l_i\) and \(r_{i+3}\) are defined) and we swap them into: \(l_i, a_{i+2}, a_{i+1}, r_{i+3}\).  Now it’s just a simple simulation to see whether we can solve that configuration.&lt;/p&gt;

&lt;p&gt;If for all indices we cannot then the final answer is NO.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1474&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1474e/&quot;&gt;
    What Is It?
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1474/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1474&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1474f/&quot;&gt;
    1 2 3 4 ...
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1474/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;matrices&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-696.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Tue, 19 Jan 2021 00:00:00 +0000</pubDate>
        <link>//R-696</link>
        <link href="/R-696"/>
        <guid isPermaLink="true">/R-696</guid>
      </item>
    
      <item>
        <title>Round 695 (Div II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1467&quot;&gt;Codeforces Round #695 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1467&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1467a/&quot;&gt;
    Wizard of Orz
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1467/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r695/1467a-wizard-of-orz.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;With just a single panel we clearly pause it so that it shows \(9\).  Otherwise we pause the second panel when it shows \(8\), so that we get a prefix of \(9890123456\ldots\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1467&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1467b/&quot;&gt;
    Hills And Valleys
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1467/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r695/1467b-hills-and-valleys.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;First observation is that changes are very local, changing \(a_i\) might change hill/valley status of elements at positions \(i-1, i, i+1\) only.&lt;/p&gt;

&lt;p&gt;Secondly, it’s always optimal to change \(a_i\) to either \(a_{i-1}\) or \(a_{i+1}\). To see that assume that we picked \(x\) to minimize the number of hills/valleys in \(a_{i-1}, x, a_{i+1}\).  We have two options:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;if \(x &amp;lt; max(a_{i-1}, a_{i+1})\) then we can change \(x\) to be \(min(a_{i-1}, a_{i+1})\), which ensures that there’s no peak/valley at that position.&lt;/li&gt;
  &lt;li&gt;or \(x &amp;gt; min(a_{i-1}, a_{i+1})\) in which case we change it to \(max(a_{i-1}, a_{i+1})\), again ensuring it does not form a peak/valley.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once we know all that it’s enough to compute the number of peaks/valleys in the original configuration and then try all those local modifications, efficiently compute updated score and pick the minimal one.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1467&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1467c/&quot;&gt;
    Three Bags
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1467/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r695/1467c-three-bags.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Think of the operations as a rooted tree.  Nodes are the numbers in the bags. The root is the final number.  A directed edge from one number to the other indicates that we merge those numbers.  Each edge must necessarily connect nodes from different bags.&lt;/p&gt;

&lt;p&gt;What’s the total score?  With each layer of the tree we subtract numbers, so we actually end up switch between subtracting/adding them layer by layer.  That means that the final score is the sum of all elements at odd layers minus the sum of all layers at even layers.  So our goal is to put as little as possible into odd layers.&lt;/p&gt;

&lt;p&gt;A picture is worth a thousand words and the notes have two pictures of the optimal configurations but it comes down to either of those two options, where we manage to pack everything into odd layers except for:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;one element from one bag and one element from a &lt;em&gt;different&lt;/em&gt; bag or&lt;/li&gt;
  &lt;li&gt;all elements from a single bag (split between two layers)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once we know all that it’s very easy to compute those options and pick a better one.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1467&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1467d/&quot;&gt;
    Sum of Paths
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1467/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1467&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1467e/&quot;&gt;
    Distinctive Roots in a Tree
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1467/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-695.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Fri, 08 Jan 2021 00:00:00 +0000</pubDate>
        <link>//R-695</link>
        <link href="/R-695"/>
        <guid isPermaLink="true">/R-695</guid>
      </item>
    
      <item>
        <title>Round 694 (Div I+II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1470&quot;&gt;Codeforces Round #694 (Div. 1)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1471&quot;&gt;Codeforces Round #694 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1471&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1471a/&quot;&gt;
    Strange Partition
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1471/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r694/1471a-strange-partition.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;If all numbers are divisible by \(x\) then it doesn’t matter how many operations we will perform, they will never affect the result.  Otherwise they could and it is not too difficult to see that if we want to minimize the result then it’s best to collapse everything into a single number in which case the answer is:&lt;/p&gt;

\[\lceil \frac{\sum_i a_i}{x} \rceil\]

&lt;p&gt;and to maximize it it’s best not too do any operations for the result of:&lt;/p&gt;

\[\sum_i \lceil \frac{a_i}{x} \rceil\]

&lt;p&gt;The reason for that is because for any \(a, b, x\) we have:&lt;/p&gt;

\[\lceil \frac{a+b}{x} \rceil \le \lceil \frac{a}{x} \rceil + \lceil \frac{b}{x} \rceil\]

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1471&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1471b/&quot;&gt;
    Strange List
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1471/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r694/1471b-strange-list.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We essentially simulate what the robot does by passing through the array, only instead of adding new elements to the array we keep a total sum of its elements and we keep track of the divisor which is \(x\) initially and gets multiplied by \(x\) after each iteration.  If we process an element we add it to the total result (even though it’ll be added in several chunks they will all sum up to its original value).  And once we reach an element that stops being divisible we stop.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1471&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1471c/&quot;&gt;
    Strange Birthday Party
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1471/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r694/1471c-strange-birthday-party.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We solve it greedily by observing that it’s best to give cheapest gifts to people later in the array.  To prove that let’s say that we have two people \(k_i\) and \(k_j\) where \(j &amp;gt; i\), and so \(k_j \ge k_i\), who got gifts \(x\) and \(y\), respectively, with \(x \gt y\) for a total cost of \(x + y\).  Now let’s swap those gifts so that \(k_i\) gets \(y\) (if it was ok to give him \(x\) then it must also be ok to give him smaller \(y\)) and \(k_j\) gets \(min(x, C_j)\) (if it was OK to give \(x\) to \(k_i\) then it must be ok to give it to \(k_j\) as \(k_j \ge k_i\)).  The total cost now becomes \(min(x, C_j) + y\) which is less than or equal than what we had before.&lt;/p&gt;

&lt;p&gt;Now it’s just a matter of starting with giving money to everyone and then going from cheapest to more expensive gifts and handle them to people from right to left for as long as we can.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1471&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1471d/&quot;&gt;
    Strange Definition
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1471/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r694/1471d-strange-definition.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;hashing&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;First, let’s try to see what the adjacency condition means.  Let’s take:&lt;/p&gt;

\[x = p_1^{\alpha_1} \cdot \ldots \cdot p_n^{\alpha_n}\]

\[y = p_1^{\beta_1} \cdot \ldots \cdot p_n^{\beta_n}\]

&lt;p&gt;(some \(\alpha_i, \beta_i\) might be \(0\)). Then we can see that:&lt;/p&gt;

\[gcd(x, y) = p_1^{\min(\alpha_1, \beta_1)} \cdot \ldots \cdot p_n^{min(\alpha_n, \beta_n)}\]

\[lcm(x, y) = p_1^{\max(\alpha_1, \beta_1)} \cdot \ldots \cdot p_n^{max(\alpha_n, \beta_n)}\]

\[\frac{lcm(x, y)}{gcd(x, y)} = p_1^{max(\alpha_1, \beta_1) - min(\alpha_1, \beta_1)} \cdot \ldots = p_1^{\mid \alpha_1 - \beta_1 \mid} \cdot \ldots \cdot p_n^{\mid \alpha_n - \beta_n \mid}\]

&lt;p&gt;Now for a number to be a perfect square, all its exponents must be even as then:&lt;/p&gt;

\[\sqrt{p_1^{2\alpha_1} \cdot \ldots \cdot p_n^{2\alpha_n}} = p_1^{\alpha_1} \cdot \ldots \cdot p_n^{\alpha_n}\]

&lt;p&gt;Going back to the previous formula we therefore conclude that two numbers are adjacent if all their exponents have the same parity.  That means that we don’t care about the exponent, only about their parities so we can normalize all numbers by:&lt;/p&gt;

\[\mathcal{N}(p_1^{\alpha_1} \cdot \ldots \cdot p_n^{\alpha_n}) = p_1^{\alpha_1 \mod 2} \cdot \ldots \cdot p_n^{\alpha_n \mod 2}\]

&lt;p&gt;and then we also have that \(x\) is adjacent to \(y\) iff \(\mathcal{N}(x) = \mathcal{N}(y)\).&lt;/p&gt;

&lt;p&gt;So let’s normalize the input numbers and count frequencies for them (how many copies of each number we have).  The highest frequency count is our initial beauty.&lt;/p&gt;

&lt;p&gt;Now what happens when we start replacing?  If any number occurs with an even frequency then it will be immediately collapsed to \(1\) (as after multiplication all the exponents will be even), otherwise it will remain unchanged.  Which means that after the first step everything will stabilize and will not change any more.&lt;/p&gt;

&lt;p&gt;So we can just compute the initial beauty and the beauty after single step and then use those two numbers to answer queries \(w = 0\) and \(w &amp;gt; 0\), respectively.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1471&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1471e/&quot;&gt;
    Strange Shuffle
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1471/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r694/1471e-strange-shuffle.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s first see the number of card changes after a couple of turns (underlined number is the impostor)&lt;/p&gt;

\[\ldots, 4, 4, 4, \mathbf{\underline{4}}, 4, 4, 4, \ldots\]

\[\ldots, 4, 4, \mathbf{3, \underline{4}, 5}, 4, 4, \ldots\]

\[\ldots, 4, \mathbf{3, 3, \underline{4}, 5, 5}, 4, \ldots\]

\[\ldots, \mathbf{3, 3, 3, \underline{4}, 5, 5, 5}, \ldots\]

&lt;p&gt;Crucial observations are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;impostor will continue holding \(k\) cards,&lt;/li&gt;
  &lt;li&gt;affected people to the left of him will have less than \(k\) cards and to the right of him more than \(k\) cards,&lt;/li&gt;
  &lt;li&gt;number of affected people (to left and right) increases by one after each move.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The idea is to first try to find a block of affected people and, once we have that, we can zone in on the impostor using binary search.&lt;/p&gt;

&lt;p&gt;How do find the block?  In the first moves the number of affected people is so small that it’s hopeless. However, we can wait, say 500 turns, by which point the block will grow to \(500+1+500\).  We need to be careful with hitting impostor so to avoid that we will always query for two consecutive positions in every block.  Even for the maximal \(n = 10^5\) we only have \(100\) blocks and so we will identify a block in at most \(200\) queries.&lt;/p&gt;

&lt;p&gt;Let’s say we found an affected person at position \(i\).  We know whether the affected person is to the left or right of the impostor.  If he’s to the left then we know that impostor is somewhere in the segment of \([i, i+700]\) (or however many turns into the game we are); similarly for the other case, when the person is to the right of impostor.  For such a small segment we can find an impostor in \(\log s\) queries, where \(s\) is the size of the segment, so in this case we need at most \(10\) additional queries.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1471&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1471f/&quot;&gt;
    Strange Housing
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1471/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1470&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1470e/&quot;&gt;
    Strange Permutation
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1470/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1470&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1470f/&quot;&gt;
    Strange Covering
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1470/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;divide and conquer&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-694.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
        <link>//R-694</link>
        <link href="/R-694"/>
        <guid isPermaLink="true">/R-694</guid>
      </item>
    
      <item>
        <title>Educational Round 101</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1469&quot;&gt;Educational Codeforces Round 101 (Rated for Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1469&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1469a/&quot;&gt;
    Regular Bracket Sequence
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1469/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu101/1469a-regular-bracket-sequence.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Clearly the following three conditions &lt;em&gt;must&lt;/em&gt; hold for there to be an answer:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;length of the sequence must be even (so that we have equal number of opening and closing parentheses),&lt;/li&gt;
  &lt;li&gt;it cannot start with “)” (we cannot put anything before it and so it will clearly remain unmatched) and&lt;/li&gt;
  &lt;li&gt;it cannot end with “(“ (for similar reasons to the above).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But we can also prove that if the above conditions are satisfied then an answer &lt;em&gt;does&lt;/em&gt; actually exist.  Why?  Well, we have “(“ and “)” somewhere in the sequence.  Recall that to check that parenthesis are well-formed we can go from left to right and keep the number of unmatched opening parenthesis, increasing the counter by 1 on every “(“ and decreasing it by 1 on every “)”.  If the counter never go below \(0\) and is \(0\) at the end then the expression is well formed.  Now we assign question marks in the following way:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;make sure that we have equal number of “(“ and “)” in the sequence and&lt;/li&gt;
  &lt;li&gt;put all “(“ before “)” (i.e. replace first bunch of “?” with “(“ and only then use “)”).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We will get \(0\) at we have equal number of opening and closing parenthesis and we will never go below zero because we have all the “(“ before all “)”, with the exception of a single “)” which was placed for us but we know it’s not on the first position and so there’s at least one “(“ coming before it.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1469&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1469b/&quot;&gt;
    Red and Blue
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1469/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu101/1469b-red-and-blue.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Note that a prefix of \(a\) will contain some prefix of \(r\) and some prefix of \(b\).  We can choose those prefixes independently and we want to maximize their sum; then we can reconstruct \(a\) by first placing chosen elements from \(r\) then chosen elements from \(b\) and then all the rest in arbitrary order.  So simply iterate through \(r\) (and then \(b\)) and pick the largest prefix sum.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1469&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1469c/&quot;&gt;
    Building a Fence
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1469/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu101/1469c-building-a-fence.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We keep track of the valid segment at which the fence on the given position can start.  We start with \([h_1, h_1]\).  Then for the following segment we have two constraints:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;the segment must have at least one overlap with the previous one and&lt;/li&gt;
  &lt;li&gt;the lowest it can be is on the ground and the highest is \(k-1\) from the ground.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;By (carefully!) applying those constraints we get a new, possibly empty, segment of valid positions.  Solution exists if we’re able to place the last fence element on the ground, i.e. \(h_n\) belongs to the computed segment of allowed positions after last iteration.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1469&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1469d/&quot;&gt;
    Ceil Divisions
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1469/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu101/1469d-ceil-divisions.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;The idea is that if we’re solving segment \([1, x]\) then for \(x = 2\) we’re done and otherwise we want to:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;pick the largest \(y\) such that we can use it to get \(x\) to \(1\) in two divisions,&lt;/li&gt;
  &lt;li&gt;start by decreasing to \(1\) everything from \(y+1\) to \(x-1\) by division on \(x\),&lt;/li&gt;
  &lt;li&gt;divide \(x\) by \(y\) twice to get it to \(1\),&lt;/li&gt;
  &lt;li&gt;continue recursively with segment \([1, x]\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;By doing so we’re only spending one extra division (on \(x\)) and we’re going from \([1, x]\) to \([1, \sqrt{x}]\), which is plenty enough to solve this problem.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1469&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1469e/&quot;&gt;
    A Bit Similar
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1469/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;hashing&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;string suffix structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1469&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1469f/&quot;&gt;
    Power Sockets
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1469/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/Edu-101.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Mon, 28 Dec 2020 00:00:00 +0000</pubDate>
        <link>//Edu-101</link>
        <link href="/Edu-101"/>
        <guid isPermaLink="true">/Edu-101</guid>
      </item>
    
      <item>
        <title>Round 692 (Div I+II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1464&quot;&gt;Codeforces Round #692 (Div. 1, based on Technocup 2021 Elimination Round 3)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1465&quot;&gt;Codeforces Round #692 (Div. 2, based on Technocup 2021 Elimination Round 3)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1465&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1465a/&quot;&gt;
    In-game Chat
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1465/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r692/1465a-in-game-chat.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Trivial, just count the number of consecutive “)” at the end and if that number doubled is longer than the length of the string then the message is bad.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1465&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1465b/&quot;&gt;
    Fair Numbers
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1465/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r692/1465b-fair-numbers.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;A trivial approach of just iterating from \(n\) until we reach an acceptable number works.&lt;/p&gt;

&lt;p&gt;Why we won’t have to iterate too much?  Because \(lcm(1, \ldots, 9) = 2520\) which means that every \(2520\)-th number is divisible by all digits from \(1\) to \(9\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1465&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1465c/&quot;&gt;
    Peaceful Rooks
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1465/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r692/1465c-peaceful-rooks.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Looking at a single rook at \((x, y)\) we have three options:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It’s already on the diagonal, i.e. \(x == y\),&lt;/li&gt;
  &lt;li&gt;It can be moved in a single move into at least one of the following two diagonal positions: \((x, x)\) or \((y, y)\).&lt;/li&gt;
  &lt;li&gt;Both \((x, x)\) and \((y, y)\) are attacked by some other rook.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can apply the following greedy strategy: leave the rooks already well placed alone and for the remaining ones put them in a priority queue ordered in increasing number by the number of its target positions being blocked (\(0, 1, 2\)).  While getting rooks with \(0\) or \(1\) move them to diagonal with a single move.  When getting one with \(2\) we first need to unblock one of those positions and then move it so it costs us \(2\) moves.&lt;/p&gt;

&lt;p&gt;Why does that work?  Well, think of this as a graph, where each rook at position \((x, y)\) we represent as an edge \(x \to y\).  Our goal is to transform this graph into self-loops, i.e. all rooks at positions \((x, x)\).  From the fact that no two rooks attack each other we infer that there is at most one edge leading to and from each vertex.  Which in turn means that the graph can only have simple paths and simple cycles.  A path can be unwound into a bunch of self-loops with one move per each of its node.  And a single cycle can be transformed into a path with a single move (the fact that it’s always possible comes from the fact that there is at least one row/column unoccupied).  So a total number of moves is the number of rooks, minus the number of rooks which are initially on the diagonal, plus the number of cycles.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1465&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1465d/&quot;&gt;
    Grime Zoo
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1465/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r692/1465d-grime-zoo.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Assume \(x &amp;gt; y\); the other case is symmetrical (or we can just swap \(x\) and \(y\) and flip the string \(0 \to 1, 1 \to 0\)).&lt;/p&gt;

&lt;p&gt;Let’s consider what happens to a configuration \(\vec{u}\ 1 \ \vec{v}\ 0 \ \vec{z}\) if we change it to \(\vec{u}\ 0\ \vec{v}\ 1\ \vec{z}\). Firstly, observe that the block between \(\vec{u}\) and \(\vec{z}\) has the same number of \(0\)s and \(1\)s in both cases and so the cost of pairs with at least one element outside of that block will be the same.  So we can just compare \(1\ \vec{v}\ 0\) with \(0\ \vec{v}\ 1\).  Block in the middle is again the same so we can just focus on how much pairs involving first and/or last elements contribute to the answer; let’s denote it by function \(f\).  Assume that within \(\vec{v}\) we have \(v_0\) zeroes and \(v_1\) ones.  Then we have:&lt;/p&gt;

\[f(1\ \vec{v}\ 0) - f(0\ \vec{v}\ 1) = ((1+v_1)y + v_0 y) - ((1+v_1) x + v_0 x) = (1 + v_0 + v_1)(y - x)\]

&lt;p&gt;\(1 + v_0 + v_1\) is positive as all its elements are positive.  Since \(x &amp;gt; y\) that means that \(y-x\) is negative and hence so is the whole formula.  Which means that by flipping \(1\ \vec{v}\ 0\) to \(0\ \vec{v}\ 1\) we can &lt;em&gt;always&lt;/em&gt; decrease the overall cost.  Which further means that, by continuing to apply this logic, in the final answer (i.e. what we substitute question marks for) we cannot have a \(1\) followed by a \(0\).  That means it must be of the shape \(00 \ldots 11\).&lt;/p&gt;

&lt;p&gt;Now, the idea is to try to iterate over the number of \(0\)s in that final answer and pick the option that gives the lowest cost.  How can we do that efficiently?&lt;/p&gt;

&lt;p&gt;Let’s begin by computing the cost of \(11 \ldots 11\) and then we will be successively “inserting” \(0\)s from the left. To do that we iterate through the string and keep track of: number of zeroes, \(z\), and number of \(10\) pairs we’ve seen, \(oz\).  Number of ones, \(o\) and of \(01\) pairs, \(zo\), can be easily derived from that, as we have: \(z + o = i\) (where \(i\) is the number of characters we’ve considered so far) and \(zo + oz = o*z\), i.e. we need to pick some zero and some one to form a pair of distinct digits (\(01\) or \(10\)).&lt;/p&gt;

&lt;p&gt;Now we will sweep from left to right to replace ones with zeroes. To do that we will keep of four variables: \(z_l, z_r, o_l, o_r\), which are, respectively, number of zeroes/ones to the left/right of the index we’re considering.  When we see \(0\) or \(1\) we just update those variables, which is fairly simple.  When we see \(&quot;?&quot;\) we will be replacing \(1\) with a \(0\) and on top of updating those variables (careful!) we also need to update the score, we’re adding \(o_l\) \(10\) pairs to the left and \(o_r\) \(01\) pairs to the right and removing \(z_l\) \(01\) pairs to the left and \(z_r\) \(10\) pairs to the right, so in total we’re incrementing the score by \(y(o_l - z_r) + x(o_r - z_l)\).  We then take the minimal score across all considered options.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1465&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1465e/&quot;&gt;
    Poman Numbers
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1465/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r692/1465e-poman-numbers.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Crucial observation is that the last digit will always come with a plus sign, the last but one with a minus and &lt;em&gt;all the others we can choose however we like&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Let’s prove it.  Firstly, we can drop an arbitrary prefix of minuses by splitting on a single prefix character required number of times.  So we are left with a target of the form: \(+ \ldots +[---]-+\) (part in the brackets can be empty or can have more minuses).  We split it by taking all but one minuses from the last segment of minuses into the right part, i.e. left: \(+ \ldots +-\), right: \([---]+\).  Note that the left part is taken with a minus sign so we flip the targets and get left: \(- \ldots -+\), right: \([---]+\), so we obtain two smaller segments so our thesis follows by induction.&lt;/p&gt;

&lt;p&gt;Now knowing that we update target based on the last two digits and for the rest we apply a greedy approach: we sort digits in descending orders and apply each one in turn with the sign that will bring us closer to the target.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1465&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1465f/&quot;&gt;
    The Thorny Path
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1465/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1464&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1464e/&quot;&gt;
    No Game No Life
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1464/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;games&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;matrices&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1464&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1464f/&quot;&gt;
    My Beautiful Madness
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1464/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-692.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Sun, 20 Dec 2020 00:00:00 +0000</pubDate>
        <link>//R-692</link>
        <link href="/R-692"/>
        <guid isPermaLink="true">/R-692</guid>
      </item>
    
      <item>
        <title>Round 691 (Div I+II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1458&quot;&gt;Codeforces Round #691 (Div. 1)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1459&quot;&gt;Codeforces Round #691 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1459&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1459a/&quot;&gt;
    Red-Blue Shuffle
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1459/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r691/1459a-red-blue-shuffle.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;probabilities&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, note that if both digits on a single card are the same then this card will not have any impact on the result and we may as well discard it.&lt;/p&gt;

&lt;p&gt;After that all cards have different digits and so after permutation it will always be the first card that will decide the overall result.  So we simply look at all the cards and count cases where \(r_i &amp;gt; b_i\) and where \(b_i &amp;gt; r_i\) and compare those two numbers. If the former is larger than we answer “RED”, if latter “BLUE” and if they are equal then “EQUAL”.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1459&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1459b/&quot;&gt;
    Move and Turn
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1459/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r691/1459b-move-and-turn.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Couple of observations.  Firstly, the move rules simply mean that we alternate moves between moving along X and along Y axis (starting with arbitrary).  Secondly, we can think of those two moves independently, as they affect different components of a \((x, y)\) coordinate.&lt;/p&gt;

&lt;p&gt;We have two cases.  If \(n\) is even that means we’ll do \(k = n/2\) moves of each type.  Each move modifies coordinate by \(+1\) or \(-1\).  What values we can reach on the axis we’re considering?  Well: \(k, k-2, \ldots, 0, \ldots, -k+2, -k\) and there are \(k+1\) of them.  Since both axis are independent this gives an overall answer of \((k+1)^2\).&lt;/p&gt;

&lt;p&gt;What if \(n\) is odd?  We’ll do \(k = \lfloor n/2 \rfloor\) moves along one axis and\(\lceil n/2 \rceil = k + 1\) along the other axis and we can pick which is which.  For each of those choices we can use similar reasoning to the one from the previous paragraph and so we end up with \((k+1)(k+2)\) moves.&lt;/p&gt;

&lt;p&gt;Now, configurations that we reach in those two cases are disjoint.  Why is that?  That’s because each move changes parity of the values along each axis and so those parities cannot be the same after \(k\) and \(k+1\) moves.  That means that the total number of combinations in the odd case is: \(2(k+1)(k+2)\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1459&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1459c/&quot;&gt;
    Row GCD
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1459/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r691/1459c-row-gcd.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Note that the difference between two numbers must be divisible by their \(gcd\).  More formally: if \(gcd(x, y) = p\) then \(abs(x-y) % p == 0\).&lt;/p&gt;

&lt;p&gt;So we can sort the initial numbers, throw away the duplicates and pre-compute \(gcd\) of all the differences, let’s call that \(G\).  Now for a query of \(b_j\) we can simply compute the answer as: \(gcd(a_1+b_j, G)\).&lt;/p&gt;

&lt;p&gt;Another way to reason about that is as follows.  We know that \(gcd(x, y) = gcd(x-y, y)\).  We will want to compute \(gcd(a_1 + b_j, a_2+b_j, \ldots, a_n + b_j)\).  By subtracting the \(a_1+b_j\) from all the other terms we get that that formula equals to \(gcd(a_1 + b_j, a_2 - a_1, \ldots a_n - a_1)\), which equals to: \(gcd(a_1 + b_j, gcd(a_2 - a_1, \ldots a_n - a_1))\). We an easily see that the second argument does not depend on the queries and so we can precompute it and then answering each query comes down to a single \(gcd\) of 2 arguments.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1459&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1459d/&quot;&gt;
    Glass Half Spilled
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1459/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r691/1459d-glass-half-spilled.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Few observations at first.  Let’s say we chose some \(k\) glasses; what do we need to know about them to compute the final answer?  Two things only: total capacity and amount of water in them initially.  Why is that?  Well, the optimal pouring strategy is very simple: we keep water in those glasses and pour from all the others directly to them until reaching capacity.  Let’s say that our \(k\) glasses have \(W\) water in them and a total capacity of \(C\), whereas the total amount of water in all the glasses is \(W_{all}\).  The final answer then is: \(min(C, W + (W_{all}-W)/2)\), because we cannot go over total capacity \(C\), we initially have \(W\) water in the glasses and \(W_{all}-W\) water available that we can pour, loosing half of it.&lt;/p&gt;

&lt;p&gt;Once we know that we can device DP with state \(S_{(i,k,c)}\) being initial amount of water in \(k\) glasses chosen from glasses \(1..i\) such that their overall capacity is \(c\).  Knowing that we can relatively easily come up with the transitions as we have two cases for a glass: use it as one of the chosen glasses or not.&lt;/p&gt;

\[S_{(i,k,c)} = max(S_{(i-1,k,c)}, S_{(i-1,k-1,c-a_i)} + b_i)\]

&lt;p&gt;Not strictly necessary but if we are careful and do the computations in the right order we can get rid of the first dimension \(i\); see code for details.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1459&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1459e/&quot;&gt;
    Latin Square
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1459/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;matrices&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1459&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1459f/&quot;&gt;
    Flip and Reverse
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1459/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1458&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1458e/&quot;&gt;
    Nim Shortcuts
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1458/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;games&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1458&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1458f/&quot;&gt;
    Range Diameter Sum
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1458/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;games&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-691.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Sat, 19 Dec 2020 00:00:00 +0000</pubDate>
        <link>//R-691</link>
        <link href="/R-691"/>
        <guid isPermaLink="true">/R-691</guid>
      </item>
    
      <item>
        <title>Educational Round 100</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1463&quot;&gt;Educational Codeforces Round 100 (Rated for Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1463&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1463a/&quot;&gt;
    Dungeon
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1463/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu100/1463a-dungeon.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Note that we repeatedly fire \(6\) shots at whatever we want and then the following \(3\) at all of the monsters.  That means that we can pass the dungeon beautifully if and only if:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;sum of monster strengths is divisible by \(9\) and&lt;/li&gt;
  &lt;li&gt;strength of each monster is at least \((a+b+c)/9\) (so that it does not die before we’re done)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1463&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1463b/&quot;&gt;
    Find The Array
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1463/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu100/1463b-find-the-array.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;One option is for each \(b_i\) to take power of \(2\) that is closest to \(a_i\).  Hence at every position we’re at most by factor of \(2\) away from \(a_i\) and so are we for the whole sum.  Since all elements are powers of \(2\) we’re also satisfying the condition of divisibility.&lt;/p&gt;

&lt;p&gt;Another option is to consider \((a_1, 1, a_3, 1, a_5 \ldots)\) and \((1, a_2, 1, a_4, 1 \ldots)\); one of them is guaranteed to be the right answer.  Divisibility condition is trivially satisfied for both.  Denote by \(S_{odd}\) and \(S_{even}\) the sum of elements at odd/even positions in \(a\).  \(S_{odd} + S_{even} = S\) and so either \(S_{odd} \le \frac{S}{2}\) or \(S_{even} \le \frac{S}{2}\).  Assume it’s the former.  Then we pick \((1, a_2, 1, a_4, 1 \ldots)\) for \(b\) and it’s easy to see that \(\sum_{i \in 1..n} \mid a_i - b_i \mid \le S_{odd}\) and so \(2 \sum_{i \in 1..n} \mid a_i - b_i \mid \le S\). // check&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1463&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1463c/&quot;&gt;
    Busy Robot
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1463/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu100/1463c-busy-robot.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Fairly simple, just a matter of clean implementation.  We can keep track of: position of the robot and its target.  After moving to the next command we move the robot and if it’s done with the previous command, update it to the current one.  We additionally keep track of whether he passed the target of the previous command.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1463&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1463d/&quot;&gt;
    Pairs
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1463/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu100/1463d-pairs.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Intuition: the set of valid \(x\) forms a contiguous segment.&lt;/p&gt;

&lt;p&gt;To compute the left border we start from number \(1\), iterate upwards and calculate the number of elements in \(b\) vs not in \(b\).  We take the largest difference between the two.  More formally:&lt;/p&gt;

\[l = max_{i \in 1..n} max(0, 2*\mid b_i \cap \{1, \ldots i\} \mid - i)\]

&lt;p&gt;Similarly for right border except we go from \(2n\) down to \(1\).&lt;/p&gt;

\[r = max_{i \in 1..n} max(0, 2*\mid b_i \cap \{n, n-1, \ldots n-i+1\} \mid - i)\]

&lt;p&gt;The final answer is the length of the segment, i.e. \(r-l+1\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1463&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1463e/&quot;&gt;
    Plan of Lectures
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1463/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dsu&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1463&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1463f/&quot;&gt;
    Max Correct Set
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1463/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/Edu-100.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Thu, 17 Dec 2020 00:00:00 +0000</pubDate>
        <link>//Edu-100</link>
        <link href="/Edu-100"/>
        <guid isPermaLink="true">/Edu-100</guid>
      </item>
    
      <item>
        <title>Round 690 (Div III)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1462&quot;&gt;Codeforces Round #690 (Div. 3)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1462&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1462a/&quot;&gt;
    Favorite Sequence
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1462/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r690/1462a-favorite-sequence.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We simply need to reverse the process.  We can do that by either maintaining two pointers or by deriving the formula for the element to take based on the parity of the result index.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1462&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1462b/&quot;&gt;
    Last Year's Substring
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1462/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r690/1462b-last-years-substring.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;One option is to match the prefix with “2020” and similarly the suffix (in reverse).  If the sum of those matched substrings is at least \(4\) then it means that the answer is positive.&lt;/p&gt;

&lt;p&gt;Alternatively we can observe that we need to end up with a \(4\) characters string, which means that we need to delete \(n-4\) contiguous characters.  There are at most 5 ways to pick them and we can try them all and check whether what’s left matches “2020”.  In other words for \((x, y)\) we take \(x\) character prefix and \(y\) character suffix and we do that for: \((0, 4), (1, 3), (2, 2), (3, 1), (4, 0)\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1462&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1462c/&quot;&gt;
    Unique Number
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1462/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r690/1462c-unique-number.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Given the ridiculously low limit on \(x\) it was possible to just precompute all solutions by a naive brute-force.&lt;/p&gt;

&lt;p&gt;If we want to solve it “properly” then a number of observations:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Zeroes are useless (they increase the number but do not increase the sum)&lt;/li&gt;
  &lt;li&gt;Numbers should go in increasing order (order does not matter for the sum but smaller digits on more significant positions will lead to a smaller number)&lt;/li&gt;
  &lt;li&gt;We can check what’s the minimal number of digits by considering a prefix of \(987654321\) until reaching (or exceeding) the required sum.&lt;/li&gt;
  &lt;li&gt;If we found some answer in the following step then we optionally need to decrease it by the difference between its sum and the required sum.  That difference will always be at most \(8\) and it’s always optimal to decrease the initial \(9\).&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1462&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1462d/&quot;&gt;
    Add to Neighbour and Remove
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1462/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r690/1462d-add-to-neighbour-and-remove.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Note that our operations essentially mean that we can collapse a block of contiguous elements into one equal to the sum of elements we collapsed.  And after doing that all elements must be equal.  Which means we must find blocks that can be collapsed to the required sum.&lt;/p&gt;

&lt;p&gt;We know what’s the required sum.  Let’s say we know the solution ends up with \(k\) blocks.  Then each block must have a sum of: \(\frac{\sum_i a_i}{k}\) since all operations preserve the total sum.  If that number is not an integer then clearly such \(k\) cannot work.  If it is then it remains to be checked greedily whether we can find blocks summing up to that value.&lt;/p&gt;

&lt;p&gt;All that remains to be done is to check all \(k\) in decreasing order from \(n\) (no operations at all) to \(1\) (everything collapsed to a single element, which is always a valid answer).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1462&lt;/tiny&gt;E1

  
  &lt;a href=&quot;/codeforces-editorials/problems/1462e1/&quot;&gt;
    Close Tuples (easy version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1462/problem/E1&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r690/1462e1-close-tuples-easy.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s say the minimum number in a triple we consider is \(k\).  Let’s denote by \(n_{eq}\) the number of elements \(a_i = k\) and by \(n_{gt}\) the number of elements in \(a_i \in \{k+1, k+2\}\).&lt;/p&gt;

&lt;p&gt;We have the following options for the formation of the triple:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;all elements equal to \(k\); there are \({n_{eq}}\choose{3}\) such configurations.&lt;/li&gt;
  &lt;li&gt;two elements equal to \(k\), one greater; there are \({n_{eq}\choose{2}} \cdot n_{gt}\) such configurations.&lt;/li&gt;
  &lt;li&gt;one element equal to \(k\), two greater; there are \(n_{eq} \cdot {n_{gt}\choose{2}}\) such configurations.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We now need to sum those values over all possible \(k\)s and we’re done.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1462&lt;/tiny&gt;E2

  
  &lt;a href=&quot;/codeforces-editorials/problems/1462e2/&quot;&gt;
    Close Tuples (hard version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1462/problem/E2&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r690/1462e2-close-tuples-hard.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Note that the order does not matter so let’s assume that the array is sorted in an ascending order for ease of reasoning (and let’s actually sort it so).  Now we’ll consider numbers from left to right as the potential minimal elements in a triple, so that all the remaining elements of the triple must be to their right.  Once we consider a number \(v\) at a given position we use binary search to find index of the element \(v+k\) to the right of it.  So now  know how many elements, other than \(v\) itself, fall into the \([v, v+k]\) segment which can be used to form a triple “rooted” at \(v\), if there are \(n\) such elements then they add \(n\choose{m-1}\) to the answer (\(v\) is the \(m\)‘th element).  What remains to be done is to be sure to precompute factorials so that we can compute those binomial coefficients efficiently.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1462&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1462f/&quot;&gt;
    The Treasure of The Segments
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1462/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r690/1462f-the-treasure-of-the-segments.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;This basically comes down to a single observation.  Let’s say we consider a segment \([l, r]\).  What can we say about a segment \([p, q]\) that does &lt;strong&gt;not&lt;/strong&gt; intersect it?  Well, it’s either:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(p &amp;gt; r\) or&lt;/li&gt;
  &lt;li&gt;\(q &amp;lt; l\) and&lt;/li&gt;
  &lt;li&gt;crucially, it cannot be both.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So we can just form an array of all beginnings of segments (sorted) and all endings (sorted) and use them with a binary search to quickly compute for a given \([l, r]\) segment how many segments it does not intersect (we will need to remove that many to form an answer).  Now we just pick the best answer over all initial segments and we’re done.&lt;/p&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-690.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate>
        <link>//R-690</link>
        <link href="/R-690"/>
        <guid isPermaLink="true">/R-690</guid>
      </item>
    
  </channel>
</rss>
