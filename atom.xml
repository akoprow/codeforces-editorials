<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Codeforces editorials</title>
    <description>Codeforces editorials</description>
    <link></link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <author>
      <name>Adam Koprowski</name>
      <email>Adam.Koprowski@gmail.com</email>
      <uri></uri>
    </author>
    
      <item>
        <title>Round 711 (Div II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1498&quot;&gt;CodeCraft-21 and Codeforces Round #711 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1498&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1498a/&quot;&gt;
    GCD Sum
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1498/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r711/1498a-gcd-sum.kt&quot;&gt;(Code)&lt;/a&gt;

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Simply try consecutive numbers until hitting one that fulfils the requirements.  We won’t have to try for long as numbers divisible by \(3\) have sum of their digits divisible by \(3\) and so at least every third number works.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1498&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1498b/&quot;&gt;
    Box Fitting
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1498/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r711/1498b-box-fitting.kt&quot;&gt;(Code)&lt;/a&gt;

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Simple greedy strategy works:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;continue packing largest box that still fits,&lt;/li&gt;
  &lt;li&gt;when nothing fits any more take a new box of size \(w\).&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1498&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1498c/&quot;&gt;
    Planar Reflections
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1498/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r711/1498c-planar-reflections.kt&quot;&gt;(Code)&lt;/a&gt;

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;This screams DP.  Let’s call by \(\mathcal{D}_{i, j}\) the number of particles we finally get after a single one hits a plane so that it will \(i\) planes to go through going right and it has power \(j\).&lt;/p&gt;

&lt;p&gt;For boundary conditions clearly if power is \(1\) then answer is \(1\) as it won’t get cloned.&lt;/p&gt;

&lt;p&gt;Otherwise we will get:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(\mathcal{D}_{i-1, j}\) particles after moving right, i.e. we have one fewer planes to go through and our power does not change and&lt;/li&gt;
  &lt;li&gt;\(\mathcal{D}_{n-i, j-1}\) particles after moving left, i.e. our power goes down by one and going to the left is the same as going through the right in the mirror image, so we appropriately adjust the number of planes on our way.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Another option was to have another dimension of the DP indicating direction of travel and it’s quite possible that this was easier to code quickly and correctly.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1498&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1498d/&quot;&gt;
    Bananas in a Microwave
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1498/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1498&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1498e/&quot;&gt;
    Two Houses
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1498/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;probabilities&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1498&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1498f/&quot;&gt;
    Christmas Game
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1498/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;games&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-711.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Mon, 29 Mar 2021 00:00:00 +0100</pubDate>
        <link>//R-711</link>
        <link href="/R-711"/>
        <guid isPermaLink="true">/R-711</guid>
      </item>
    
      <item>
        <title>Round 709 (Div I+II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1483&quot;&gt;Codeforces Round #709 (Div. 1, based on Technocup 2021 Final Round)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1484&quot;&gt;Codeforces Round #709 (Div. 2, based on Technocup 2021 Final Round)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1484&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1484a/&quot;&gt;
    Prison Break
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1484/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r709/1484a-prison-break.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;It’s fairly easy to find a solution with \(n \cdot m\), for instance doing a snake like pattern from top-left to bottom, going row by row.  An argument why that’s optimal is: if we think about it as a graph we start with \(n \cdot m\) components and with one move we connect at most two into ones, so we need \(n \cdot m - 1\) move to make the graph connected, plus one to connect with the outside world.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1484&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1484b/&quot;&gt;
    Restore Modulo
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1484/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r709/1484b-restore-modulo.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s look at all the differences of consecutive elements.  We have few cases:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;if there’s just one distinct value we can choose infinitely many large \(m\)s.&lt;/li&gt;
  &lt;li&gt;if there are more than two distinct values then there is no answer.&lt;/li&gt;
  &lt;li&gt;why can we have two values?  Because one (positive) might be a “regular” one bumping up by \(c\) and the other one (negative) might be once we “wrap up” modulo \(m\).  In this case the positive one is \(c\) and \(m\) is the difference between the two.  What remains to be done is to check whether this is indeed a valid solution.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1484&lt;/tiny&gt;C / &lt;tiny&gt;1483&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1484c/&quot;&gt;
    Basic Diplomacy
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1484/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r709/1484c-basic-diplomacy.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;flows&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Greedy.  If there are days with \(0\) candidates there is no answer.  For days with \(1\) candidate let’s choose him.  From then one we have a choice and let’s greedily choose a friend that was used least times so far.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1484&lt;/tiny&gt;D / &lt;tiny&gt;1483&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1484d/&quot;&gt;
    Playlist
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1484/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r709/1484d-playlist.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dsu&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;It helps to first think how we would naively simulate it.  We need to remove entries so let’s keep everything on a doubly linked circular list.&lt;/p&gt;

&lt;p&gt;Why simple simulation is not good enough?  Because we can have an input like lots of \(2\)s followed by lots of \(3\) and we only do one deletion per “round” so this is going to be too slow.&lt;/p&gt;

&lt;p&gt;One way to speed it up is to in addition to regular pointers in the list add “shortcut” links.  If we go through a block \(a_1, \ldots a_n\) without doing any deletions and then finally do a deletion from \(a_n\) to \(b\) then we add shortcuts from \(a_1, \ldots a_{n-1}\) to \(a_n\) as those numbers (on their own) will never be reduced.&lt;/p&gt;

&lt;p&gt;From here on it’s just a matter of careful implementation; when done properly this is actually short and sweet.  What helps a lot is that we have a fixed initial size of the input so instead of doing any pointers we just store appropriate indices in static arrays.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1484&lt;/tiny&gt;E / &lt;tiny&gt;1483&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1484e/&quot;&gt;
    Skyline Photo
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1484/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1484&lt;/tiny&gt;F / &lt;tiny&gt;1483&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1484f/&quot;&gt;
    Useful Edges
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1484/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;shortest paths&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1483&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1483e/&quot;&gt;
    Vabank
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1483/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1483&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1483f/&quot;&gt;
    Exam
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1483/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dsu&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;string suffix structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-709.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Sun, 21 Mar 2021 00:00:00 +0000</pubDate>
        <link>//R-709</link>
        <link href="/R-709"/>
        <guid isPermaLink="true">/R-709</guid>
      </item>
    
      <item>
        <title>Educational Round 106</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1499&quot;&gt;Educational Codeforces Round 106 (Rated for Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1499&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1499a/&quot;&gt;
    Domino on Windowsill
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1499/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu106/1499a-domino-on-windowsill.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Fairly simple; we can place \(min(k_1, k_2)\) dominoes vertically and then we’re left with \(max(k_1, k_2) - min(k_1, k_2)\) consecutive cells where we can put half as many horizontal dominoes.  The case for white dominoes is analogous (and it’s easy to compute \(k_1\) and \(k_2\) for that case).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1499&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1499b/&quot;&gt;
    Binary Removals
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1499/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu106/1499b-binary-removals.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Eventually we want to have all \(0\)s on some prefix and all \(1\)s from then on.  What’s the longest prefix where we can make all \(0\)s?  Well, until we hit two \(1\)s next to each other.  From that point onwards we can make all \(1\)s until we hit two \(0\)s next to each other.  If by doing those two steps we processed the whole string we’re good; otherwise the answer is clearly “NO”.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1499&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1499c/&quot;&gt;
    Minimum Grid Path
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1499/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu106/1499c-minimum-grid-path.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, clearly both axis are independent (and controlled by even/odd \(c_i\)) so we can kinda decompose into two subproblems.&lt;/p&gt;

&lt;p&gt;If we had to use all \(c_i\) then the optimal strategy is fairly clear:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;make minimal number of steps possible, i.e. \(1\), for all “turns” but the one with minimal \(c_i\),&lt;/li&gt;
  &lt;li&gt;and then make all the remaining steps for the cheapest (applicable) \(c_i\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;However, we do not have to use all \(c_i\); we might do with just a prefix.  It’s fairly easy to scan from \(2\) to \(n\) and at each point compute in constant time what the cost would be if we were to use only that many \(c_i\).  Then just pick the best option.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1499&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1499d/&quot;&gt;
    The Number of Pairs
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1499/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu106/1499d-the-number-of-pairs.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, let’s look at \(a\) and \(b\) in such a way that it is easy to reason about \(gcd\) and \(lcm\), namely, say \(a = g \cdot p\) and \(b = g \cdot q\) such that \(gcd(p, q) = 1\), i.e. they are co-prime.  It’s then easy to see that \(gcd(a, b) = g\) and \(lcm(a, b) = g \cdot p \cdot q\).  Let’s now look again at the original equation:&lt;/p&gt;

\[c \cdot lcm(a, b) - d \cdot gcd(a, b) = x\]

\[c \cdot g \cdot p \cdot q - d \cdot g = x\]

\[g \cdot (c \cdot p \cdot q - d) = x\]

&lt;p&gt;Since \(g\) is a factor on the left hand side we conclude that \(x\) must be divisible by \(x\), so firstly let’s iterate through all divisors of \(x\) as candidates for \(g\).&lt;/p&gt;

&lt;p&gt;Once we have a fixed \(g\):&lt;/p&gt;

\[c \cdot p \cdot q = \frac{x}{g} + d\]

&lt;p&gt;and so again we see that \(\frac{x}{g} + d\) must be divisible by \(c\); if it’s not we can skip such a candidate.&lt;/p&gt;

&lt;p&gt;Now finally we get:&lt;/p&gt;

\[p \cdot q = \frac{\frac{x}{g} + d}{c}\]

&lt;p&gt;In other words we know what the product of \(p \cdot q\) should be equal to.  Recall that we can choose \(p\) and \(q\) any way we want provided that they are co-prime.  This means that any prime factor of \(p \cdot q\) must go to either \(p\) or \(q\), but not both.  In other words there are \(2^s\) ways to choose \(p\) and \(q\) where \(s\) is the number of prime factors of \(p \cdot q\).&lt;/p&gt;

&lt;p&gt;The tricky bit is that if we naively use Eratosthenes sieve we have \(\sqrt{x}\) factors for \(x\) and for each we need \(log x\) time for a total of \(O(\sqrt{x}\ \log{x})\), which is not fast enough.&lt;/p&gt;

&lt;p&gt;What we need to do is to precompute the number of prime factors for all numbers in the range we care about (i.e. up to \(2 \cdot 10^7\)).  Sieve gives us a smaller prime factor for every number.  Suppose we are looking at \(x\) with its smaller prime being \(p\).  We have two cases:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;smaller prime of \(\frac{x}{p}\) is also \(p\), in which case \(x\) has as many prime factors as \(\frac{x}{p}\),&lt;/li&gt;
  &lt;li&gt;or it has one more, if they are different.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1499&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1499e/&quot;&gt;
    Chaotic Merge
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1499/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1499&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1499f/&quot;&gt;
    Diameter Cuts
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1499/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1499&lt;/tiny&gt;G

  
  &lt;a href=&quot;/codeforces-editorials/problems/1499g/&quot;&gt;
    Graph Coloring
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1499/problem/G&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/Edu-106.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Thu, 18 Mar 2021 00:00:00 +0000</pubDate>
        <link>//Edu-106</link>
        <link href="/Edu-106"/>
        <guid isPermaLink="true">/Edu-106</guid>
      </item>
    
      <item>
        <title>Round 708 (Div II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1497&quot;&gt;Codeforces Round #708 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1497&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1497a/&quot;&gt;
    Meximization
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1497/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r708/1497a-meximization.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Greedy: put all distinct elements in ascending order, as that will maximize the series of MEXes; then all duplicates follow in any order as they won’t affect the MEX.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1497&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1497b/&quot;&gt;
    M-arrays
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1497/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r708/1497b-m-arrays.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Count all elements by their remainder modulo \(m\).  All elements with remainder \(0\) must go to a group on their own.  Then we can group together \(i\) and \(m-i\), interleaving those two groups but be careful because:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;we can use one more from one group than the other,&lt;/li&gt;
  &lt;li&gt;when \(i\) and \(m-i\) are the same we can put them all in one group.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1497&lt;/tiny&gt;C1

  
  &lt;a href=&quot;/codeforces-editorials/problems/1497c1/&quot;&gt;
    k-LCM (easy version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1497/problem/C1&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r708/1497c1-k-lcm-easy.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Few cases:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;if \(n \mod 2 = 1\) then take \((1, \lfloor \frac{n}{2} \rfloor, \lfloor \frac{n}{2} \rfloor)\) with an \(lcm\) of \(\lfloor \frac{n}{2} \rfloor\).&lt;/li&gt;
  &lt;li&gt;if \(n \mod 3 = 0\) then take \((\frac{n}{3}, \frac{n}{3}, \frac{n}{3})\) with an \(lcm\) of \(\frac{n}{3}\) (turns out this case is actually not needed).&lt;/li&gt;
  &lt;li&gt;if \(n \mod 4 = 0\) then take \((\frac{n}{2}, \frac{n}{4}, \frac{n}{4})\) with an \(lcm\) of \(\frac{n}{2}\).&lt;/li&gt;
  &lt;li&gt;otherwise \(n\) is even but is not a multiple of \(4\) (i.e. \(\frac{n}{2}\) is odd) and take \((\frac{n}{2}-1, \frac{n}{2}-1, 2)\) with an \(lcm\) of \(\frac{n}{2}-1\).&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1497&lt;/tiny&gt;C2

  
  &lt;a href=&quot;/codeforces-editorials/problems/1497c2/&quot;&gt;
    k-LCM (hard version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1497/problem/C2&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r708/1497c2-k-lcm-hard.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Actually just take \(1\) for all but \(3\) values and for the remaining three values use the solution for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C1&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1497&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1497d/&quot;&gt;
    Genius
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1497/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;shortest paths&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1497&lt;/tiny&gt;E1

  
  &lt;a href=&quot;/codeforces-editorials/problems/1497e1/&quot;&gt;
    Square-free division (easy version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1497/problem/E1&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r708/1497e1-square-free-division-easy.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1497&lt;/tiny&gt;E2

  
  &lt;a href=&quot;/codeforces-editorials/problems/1497e2/&quot;&gt;
    Square-free division (hard version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1497/problem/E2&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r708/1497e2-square-free-division-hard.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;hashing&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-708.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Wed, 17 Mar 2021 00:00:00 +0000</pubDate>
        <link>//R-708</link>
        <link href="/R-708"/>
        <guid isPermaLink="true">/R-708</guid>
      </item>
    
      <item>
        <title>Round 706 (Div I+II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1495&quot;&gt;Codeforces Round #706 (Div. 1)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1496&quot;&gt;Codeforces Round #706 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1496&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1496a/&quot;&gt;
    Split it!
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1496/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r706/1496a-split-it.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Note that the part in the middle, \(a_{k+1}\), has no constraints and is arbitrary so we want to make all \(a_1, \ldots, a_k\) as short as possible. Notice also that if any \(a_i = s \cdot t\) then it can be split into two: \(s\) and \(t\).  Which means all \(a_i\) are single letters.  Which means we need to have:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;first \(k\) letters concatenated with last \(k\) letters must be a palindrome and&lt;/li&gt;
  &lt;li&gt;\(n &amp;gt; 2k\) (so that we have at least one letter left for \(a_{k+1}\)).&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1496&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1496b/&quot;&gt;
    Max and Mex
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1496/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r706/1496b-max-and-mex.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let \(x = mex(S)\) and \(y = max(S)\).&lt;/p&gt;

&lt;p&gt;If \(x &amp;gt; y\) then \(x = y+1\) and \(\lceil \frac{x+y}{2} \rceil = \lceil \frac{2y+1}{2} \rceil = y+2\), which means from now on we’ll always be adding a new element in every step, so just bump the result by however many steps are left and we’re done.&lt;/p&gt;

&lt;p&gt;If \(x &amp;lt; y\) then just compute \(\lceil \frac{x+y}{2} \rceil\), add it to the set and continue simulating.  This cannot go on for more than \(n\) steps at which point we’ll start hitting the previous case, so the complexity is good enough.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1496&lt;/tiny&gt;C / &lt;tiny&gt;1495&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1496c/&quot;&gt;
    Diamond Miner
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1496/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r706/1496c-diamond-miner.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, observe that we can transform each \((x, y)\) point to \((\mid x \mid, \mid y \mid)\) without affecting the answer.  So now we’re playing on a single positive quadrant of the coordinate system and it’s easy to see (or prove from triangle inequality) that the optimal solution is to avoid lines intersecting and so to greedily sort all \(x\) and \(y\) coordinates and match them in that order.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1496&lt;/tiny&gt;D / &lt;tiny&gt;1495&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1496d/&quot;&gt;
    Let's Go Hiking
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1496/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r706/1496d-lets-go-hiking.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;games&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly note that all the numbers don’t matter only for each pair of numbers which one is bigger.  Visualize this as a game on “hills” created from the numbers; first player can only be descending while the second player can only be ascending.&lt;/p&gt;

&lt;p&gt;Observations:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;the first player must start on a hill; if he did not then there’s only one possible move for him to do and the second player can block him and win.&lt;/li&gt;
  &lt;li&gt;the number of steps he can do to left and right must be equal; if it is not then the second player can place himself appropriately on the longest of the branches and win.&lt;/li&gt;
  &lt;li&gt;both left and right branch must have even lengths; for odd lengths the second player places himself on the bottom of one of the branches and wins, regardless if the first player goes along the same branch or chooses the other one.&lt;/li&gt;
  &lt;li&gt;there cannot be another monotone sequence of equal or longer length than the ones at the starting point we’re considering, as then the second player just starts there and have at least as many steps as we do and win.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This last observation in particular means that the answer will always be \(0\) or \(1\).  It’s fairly easy to find the unique winning starting point (if it exists).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1496&lt;/tiny&gt;E / &lt;tiny&gt;1495&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1496e/&quot;&gt;
    Garden of the Sun
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1496/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly let’s unpack all the fluff from the description: we have a number of \(X\)s and we want to connect all of them, by adding new \(X\)s, in such a way that we cannot create any cycles.&lt;/p&gt;

&lt;p&gt;We can do that by fully filling every third column.  If we have any \(X\)s on the remaining two columns they will automatically be connected to their closer column.  So what remains to be done is just to extend any of them into a full connection between said columns (or just add a “bridge” if no \(X\)s exist in the two columns under consideration).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1496&lt;/tiny&gt;F / &lt;tiny&gt;1495&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1496f/&quot;&gt;
    BFS Trees
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1496/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;shortest paths&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1495&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1495e/&quot;&gt;
    Qingshan and Daniel
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1495/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1495&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1495f/&quot;&gt;
    Squares
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1495/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-706.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Wed, 10 Mar 2021 00:00:00 +0000</pubDate>
        <link>//R-706</link>
        <link href="/R-706"/>
        <guid isPermaLink="true">/R-706</guid>
      </item>
    
      <item>
        <title>Round 705 (Div II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1493&quot;&gt;Codeforces Round #705 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1493&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1493a/&quot;&gt;
    Anti-knapsack
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1493/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r705/1493a-anti-knapsack.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, we clearly cannot add \(k\) itself and we can add anything larger than \(k\) as by the virtue of being larger it can never help form a sum up to \(k\).&lt;/p&gt;

&lt;p&gt;The rest is greedy in spirit: we take decreasing number from \(k-1\) for as long as we can and it turns out that we can go down to \(\lceil \frac{k}{2} \rceil\) without getting a pair of numbers (and due to numbers being relatively large, hence, also more than two numbers) that adds to \(k\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1493&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1493b/&quot;&gt;
    Planet Lapituletti
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1493/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r705/1493b-planet-lapituletti.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Simple on the surface but the devil is in the (implementation) details.  Let’s say the given time is \(H:M\).&lt;/p&gt;

&lt;p&gt;There are two possible approaches: brute-force by going through all possible hour/time combinations and from the correct ones choose the one that happens soonest after \(H:M\).  Hour/time is correct if:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;it only contains symmetrical digits (\(0, 1, 2, 5, 8\)),&lt;/li&gt;
  &lt;li&gt;mirrored image is a valid time, i.e. its hour and minute are within the given bounds.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Another option was to:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Iterate minutes from \(M+1\) to the last valid minute (\(m-1\)) and if that together with the original hour is valid then clearly that’s the answer (we stay within the same hour).&lt;/li&gt;
  &lt;li&gt;If there is no solution above then that means there is no solution within the given hour.  But then it’s easy to see that minutes will be \(00\) as it’s always valid and it’s the smallest value for minutes.  So let’s iterate &lt;em&gt;hours&lt;/em&gt; from \(H+1\) to the last valid hour (\(h-1\)) and if that paired with \(00\) for minutes is valid then that’s our answer (we stay within the same day).&lt;/li&gt;
  &lt;li&gt;Otherwise, we need to go to the following day and then \(00:00\) is the answer.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1493&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1493c/&quot;&gt;
    K-beautiful Strings
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1493/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r705/1493c-k-beautiful-strings.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;So we are given string \(s\) and are trying to find \(t\) such that:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(t\) is beautiful and&lt;/li&gt;
  &lt;li&gt;\(t \ge s\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The definition of lexicographic order is spelled out for us in the exercise but note that we do not need to worry about the first case, as \(s\) and \(t\) have the same length.  Since \(t \ge s\), let’s first get the equal part out of the way: if \(s\) is beautiful then \(t = s\).&lt;/p&gt;

&lt;p&gt;Ok, so now we know that \(t &amp;gt; s\).  Firstly, if \(n\) is not divisible by \(k\) then the answer clearly does not exist as there are no beautiful strings.  Interestingly, if it is then the answer does exist because the string consisting of all “z”s is then beautiful and larger or equal to \(s\).&lt;/p&gt;

&lt;p&gt;The idea now is to find the position where \(s\) and \(t\) differ, let’s say it’s \(p\).  By definition of lexicographic comparison we then have:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(t_i = s_i\) for \(i &amp;lt; p\) [prefix],&lt;/li&gt;
  &lt;li&gt;on position \(p\) we try to pick the smallest character \(c &amp;gt; s_p\),&lt;/li&gt;
  &lt;li&gt;on positions larger than \(p\) we are trying to find the smallest possible string [suffix].&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that the larger the \(p\) the better, so let’s consider its possible values by going from right to left in \(s\).  We keep track of the frequency of all letter on the prefix before \(p\).  We also consider all options for character \(c\) at position \(p\), such that \(c &amp;gt; s_p\) (which we include in the frequency counts).  Now we go through frequency counts and if any letter occurs a number of times not divisible by \(k\) then we know how many extra copies of it we will have to add to make it so.  If by the end of this process the number of letters we have to add is not larger than the number of spaces we have available in the suffix then we found a solution.&lt;/p&gt;

&lt;p&gt;To construct the solution we have the set of letter that we need to place in the suffix.  If that set is smaller than the number of positions on the suffix then we fill the remaining “slots” with “a” (as we’re trying to minimize the suffix).  Now all that remains to be done is to sort all those letters (again, we’re trying to minimize the suffix).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1493&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1493d/&quot;&gt;
    GCD of an Array
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1493/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r705/1493d-gcd-of-an-array.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Remember that to compute \(gcd\) of a list of numbers we first find all the factors in those numbers and then for each factor pick the minimal power of that factor across all those numbers&lt;/p&gt;

\[a_1 = p_1^{\alpha_{1,1}}\cdot \ldots \cdot p_f^{\alpha_{1,f}},\ \ \ \ \ldots \ \ \ \ a_n = p_1^{\alpha_{n,1}}\cdot \ldots \cdot p_f^{\alpha_{n,f}}\]

\[gcd(a_1, \ldots a_n) = p_1^{min(\alpha_{1,1}, \ldots \alpha_{n,1})} \cdot \ldots \cdot p_f^{min(\alpha_{1,f}, \ldots \alpha_{n,f})}\]

&lt;p&gt;So now we want to keep track of two things:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;for every position in the array a map of all the factors and their powers of the element at that position and&lt;/li&gt;
  &lt;li&gt;globally, for every factor, a multiset of their powers across all elements in the array.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It’s easy to initialize it at the beginning and it’s also easy to compute initial \(gcd\) based on the above formula.&lt;/p&gt;

&lt;p&gt;Now for every query we do the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;factorize given \(x = p_1^{\alpha_1} \cdot \ldots \cdot p_v^{\alpha_v}\).&lt;/li&gt;
  &lt;li&gt;for every factor \(p_i\) replacing mapping \(p_i \to \beta_i\) with \(p_i \to \beta_i + \alpha_i\), i.e. increase the respective power for that factor, for the \(i\)‘th element in the array.&lt;/li&gt;
  &lt;li&gt;in global multisets, for \(p_i\), remove the old value of \(\beta_i\) and instead add \(\beta_i + \alpha_i\).&lt;/li&gt;
  &lt;li&gt;if by doing so (in the last step) the minimal element in the multiset changed from \(mn_{old}\) to \(mn_{new}\), update the global \(gcd\) by multiplying it by \(p_i^{mn_{new} - mn_{old}}\)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1493&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1493e/&quot;&gt;
    Enormous XOR
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1493/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1493&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1493f/&quot;&gt;
    Enchanted Matrix
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1493/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-705.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Sat, 06 Mar 2021 00:00:00 +0000</pubDate>
        <link>//R-705</link>
        <link href="/R-705"/>
        <guid isPermaLink="true">/R-705</guid>
      </item>
    
      <item>
        <title>Educational Round 105</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1494&quot;&gt;Educational Codeforces Round 105 (Rated for Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1494&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1494a/&quot;&gt;
    ABC String
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1494/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu105/1494a-abc-string.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Probably the easiest solution is just to brute force it and try all combinations of parenthesis for all of \(A, B, C\), since there are only \(2^3 = 8\) combinations.  Alternatively, we can observe that the sequence must start with opening and must end with a closing parenthesis.&lt;/p&gt;

&lt;p&gt;Once we have a fixed meaning for every letter it’s just a matter of applying the classical algorithm of counting \(+1\) for opening and \(-1\) for closing parenthesis and the sequence is valid if:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;we never go below \(0\) (closing parenthesis that is unmatched) and&lt;/li&gt;
  &lt;li&gt;at the end we reach \(0\) (everything balanced out in the end)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1494&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1494b/&quot;&gt;
    Berland Crossword
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1494/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu105/1494b-berland-crossword.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Note that the tricky bit is the corners.  Imagine we knew what’s in every corner.  Then the problem is easy as for every border we have \(n-2\) slots excluding corners and so the number of blocks we need to place there \(v\), which is the original constrain from the problem minus \(0\), \(1\), or \(2\) depending how many blocks are already in the two relevant corners, must be \(0 \le v \le n-2\).&lt;/p&gt;

&lt;p&gt;So now we can just try all the combinations for corners (filled/unfilled) since there are only \(2^4 = 16\) and apply the reasoning from above and clearly we have an answer overall if we have an answer for any of the configurations.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1494&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1494c/&quot;&gt;
    1D Sokoban
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1494/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu105/1494c-1d-sokoban.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, note that our position relative to the blocks cannot change.  Which means that the final solution can always be expressed as:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;going \(x\) steps to the right,&lt;/li&gt;
  &lt;li&gt;coming back to the origin.&lt;/li&gt;
  &lt;li&gt;going \(y\) steps to the left.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since the first step is only concerned with blocks/targets on the positive part of the axis and last step only with those on the negative part we can split this problem into two.&lt;/p&gt;

&lt;p&gt;So now we only have blocks/targets to the right of us and the question is: how many steps to the right should we make?&lt;/p&gt;

&lt;p&gt;Next observation is that the only configurations that we should consider are:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;don’t do anything and&lt;/li&gt;
  &lt;li&gt;stop just before &lt;em&gt;some&lt;/em&gt; target, i.e. at positions \(b_i-1\) for some \(i\).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Why is it enough to only consider configurations where we stop right before some target?  Imagine instead we stopped at position \(p\) such that position \(p+1\) is not special.  By moving there we will be pushing a number of boxes, let’s say \(t\) of them.  In this scenario the boxes are covering the segment \([p+1, p+t]\).  Let’s say that the closest special position is at \(p+q\) (\(q &amp;gt; 1\)).  If instead we moved to \(p+q-1\) (right before that special position) the boxes would cover \([p+q, p+q+v-1]\).  Comparing that with the original segment we lost some positions on the left, but none of them was special and we added some positions on the right, some of which might, so we end up with a not worse (and possibly better) outcome.&lt;/p&gt;

&lt;p&gt;Ok, so let’s start by computing how many boxes initially are at special positions.  That’s our initial score and it covers the first option above (don’t do anything).&lt;/p&gt;

&lt;p&gt;Now, let’s iterate over special positions.  We will be keeping track of how many boxes we’re pushing, \(t\), initially \(t=0\). Let’s call it our “train”.  Once we move to position \(b_i\) all the boxes to the left, i.e. all \(a_j &amp;lt; b_i\) will join our train.  But our train sits on \([b_i, b_i+t]\) so all the boxes in &lt;em&gt;that&lt;/em&gt; segment also join the train, so we need to be careful there when updating \(t\).&lt;/p&gt;

&lt;p&gt;Moreover, for every box that joins the train and was initially on a special position we must make sure to decrease our score by \(1\) (we removed a box from a special position).  However, we can add to the score the number of special positions in the segment \([b_i, b_it+t]\), which is where our train sits.  To efficiently compute that we can either use an appropriate data structure or do two binary searches to find left-most and right-most special position that falls in the range.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1494&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1494d/&quot;&gt;
    Dogeforces
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1494/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dsu&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1494&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1494e/&quot;&gt;
    A-Z Graph
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1494/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1494&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1494f/&quot;&gt;
    Delete The Edges
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1494/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/Edu-105.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Tue, 02 Mar 2021 00:00:00 +0000</pubDate>
        <link>//Edu-105</link>
        <link href="/Edu-105"/>
        <guid isPermaLink="true">/Edu-105</guid>
      </item>
    
      <item>
        <title>Global Round 13</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1491&quot;&gt;Codeforces Global Round 13&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1491&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1491a/&quot;&gt;
    K-th Largest Value
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1491/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/gr/gr13/1491a-kth-largest-value.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Since we have \(n\) elements that are only \(0\) or \(1\) knowing how many \(1\)s (or \(0\)s) there are is enough to know what the \(k\)-th largest element will be (i.e. it will be \(1\) if we have at least \(k\) ones).  So it’s enough to keep track of the number of ones and update it appropriately when flipping some element.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1491&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1491b/&quot;&gt;
    Minimal Cost
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1491/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/gr/gr13/1491b-minimal-cost.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s think about it geometrically , i.e. as if the obstacles where drawing a line (a pixelated one :).  To block us that line will need to:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;be uninterrupted (i.e. continuous) and&lt;/li&gt;
  &lt;li&gt;it can either go to the left border of the board (cutting us off) or to the bottom border (splitting the board into two).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What does it mean for the line to be uninterrupted?  It means that for consecutive rows the difference in columns is at most \(1\); otherwise we can “slip through”.&lt;/p&gt;

&lt;p&gt;When does it reach the left border?  When (uninterrupted) it reaches column \(0\).&lt;/p&gt;

&lt;p&gt;When does it reach the bottom border?  When (uninterrupted) it extends to the last row.&lt;/p&gt;

&lt;p&gt;Now, if neither condition is true, we can pass without any changes.&lt;/p&gt;

&lt;p&gt;If the line is a straight vertical line.  In this case we have two make two moves to move one obstacle out of the way: the first one to left/right and the second one either left/right or top/down, whichever is cheaper.&lt;/p&gt;

&lt;p&gt;In the remaining cases it’s always enough to move only one obstacle either up/down or left/right.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1491&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1491c/&quot;&gt;
    Pekora and Trampoline
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1491/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/gr/gr13/1491c-pekora-and-trampoline.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, if we start jumping at trampoline \(i\), this will not affect any trampolines to the left of it.  Imagine there is an “unfinished” (value other than \(1\)) trampoline to the left.  We will have to jump starting from it, so we might as well start there, as jumping from \(i\) and then from \(j\) is at least as good, and potentially better!,  as jumping from \(j\) and then from \(i\) (\(j &amp;gt; i\)).&lt;/p&gt;

&lt;p&gt;So a greedy approach works: always start from the leftmost “unfinished” trampoline.&lt;/p&gt;

&lt;p&gt;How do we simulate it?  For each trampoline keep track of how many times it was reached previously (starting with all \(0\)); let’s call it \(d_i\).  When we consider position \(i\):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;we need to start afresh on it \(max(0, a_i - 1 - d_i)\) times and we need to add that value to the final result.&lt;/li&gt;
  &lt;li&gt;we will jump on it when it has values: \(a_i, a_i-1, \ldots, 2\) which means we need to increment \(d_{i+2}, \ldots d_{i + a_i}\) (as long as they are within bounds)&lt;/li&gt;
  &lt;li&gt;we will jump on it \(min(0, d_i - (a_i -1))\) with it having value \(1\), which is by how much we should increment \(d_{i+1}\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Amazingly, the source code to this problem is at most half the size of this text…&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1491&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1491d/&quot;&gt;
    Zookeeper and The Infinite Zoo
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1491/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/gr/gr13/1491d-zookeeper-and-the-infinite-zoo.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Ok, firstly let’s try to understand what kind of moves can we do, exactly.  We can transition \(u \to u + v\) iff \(u \&amp;amp; v = u\).  In other words, we’re in \(u\) we can pick a sub-mask of \(u\) and add it to \(u\).&lt;/p&gt;

&lt;p&gt;Can we simplify this?  Note that if the sub-mask we pick has only one bit set then we have a transition \(u \to u + 2^i\) which will &lt;em&gt;not&lt;/em&gt; affect bits \(j &amp;lt; i\).  That in turns mean we can decompose a move \(u \to u + (2^{i_1} + 2^{i_2} + \ldots 2^{i_n})\) into \(n\) moves with single bit masks: \(u \to u + 2^{i_1} \to \ldots \to u + (2^{i_1} + 2^{i_2} + \ldots 2^{i_n})\) (\(i_1 &amp;gt; i_2 &amp;gt; \ldots i_n\)).&lt;/p&gt;

&lt;p&gt;So we can restrict our thinking to moves of the shape \(u \to u + 2^i\) and we know that bit \(i\) is set in \(u\).  How do such moves look like?&lt;/p&gt;

&lt;p&gt;If bit \(i+1\) in \(u\) is not set then what happens on those two bits is: \(01 + 01 = 10\), i.e. we shifted the bit to the left.  Let’s call this move &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If a number of higher bits in \(u\) is set then instead it looks like this: \(11\ldots11 + 01 = 100\ldots00\), i.e. we also shifted the highest bit to the left but also zeroed in a number of following \(1\)s.  Let’s call this type of move &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Those are the only two types of moves we can make so in particular:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;we can never move a bit to the right and&lt;/li&gt;
  &lt;li&gt;we can decrease but never increase the number of bits.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This starts looking like a skeleton of an algorithm.  Look at \(u\) and \(v\), if \(v &amp;gt; u\) the answer is clearly “NO”.  Same if \(v\) has more bits than \(u\).  Otherwise we will try to match bits in \(u\) to bits in \(v\), from least significant positions and for every match of bit \(i\) in \(u\) with bit \(j\) in \(v\) we want \(i \le j\) (remember, we can only shift to the left).&lt;/p&gt;

&lt;p&gt;Now the claim is that if such matching exists then the answer is “YES”.  This is not completely obvious as remember that \(u\) might have more bits than \(v\)!  However, we can always get rid of those bits with moves &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt;.  Formal argument follows (implicitly by induction on number of bits).&lt;/p&gt;

&lt;p&gt;We’re matching \(u\) with \(v\) and \(u \le v\).  First let’s assume that they both have the same highest bit set, so we have a match at that position and we can move to lower bits.&lt;/p&gt;

&lt;p&gt;If instead \(u = 0\ldots1_1\) and \(v = 1\ldots\) and \(u\) has \(p\) bits more set than \(u\) then we get rid of spurious \(1\)s with move &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; as follows (we index \(1\)s):&lt;/p&gt;

&lt;p&gt;\(u = 0 \ldots 1_1 \ldots 1_2 \ldots 1_3 \ldots 1_p \to 0 1_1 1_2 \ldots 1_p \to 10\ldots0\) so \(u\) and \(v\) now agree on the highest bits &lt;em&gt;and&lt;/em&gt; have the same number of \(1\)s so from now on we can finish the problem with moves &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; only.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1491&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1491e/&quot;&gt;
    Fib-tree
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1491/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;divide and conquer&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1491&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1491f/&quot;&gt;
    Magnets
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1491/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1491&lt;/tiny&gt;G

  
  &lt;a href=&quot;/codeforces-editorials/problems/1491g/&quot;&gt;
    Switch and Flip
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1491/problem/G&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1491&lt;/tiny&gt;H

  
  &lt;a href=&quot;/codeforces-editorials/problems/1491h/&quot;&gt;
    Yuezheng Ling and Dynamic Tree
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1491/problem/H&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1491&lt;/tiny&gt;I

  
  &lt;a href=&quot;/codeforces-editorials/problems/1491i/&quot;&gt;
    Ruler Of The Zoo
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1491/problem/I&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/GR-13.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Sun, 28 Feb 2021 00:00:00 +0000</pubDate>
        <link>//GR-13</link>
        <link href="/GR-13"/>
        <guid isPermaLink="true">/GR-13</guid>
      </item>
    
      <item>
        <title>Round 704 (Div II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1492&quot;&gt;Codeforces Round #704 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1492&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1492a/&quot;&gt;
    Three swimmers
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1492/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r704/1492a-three-swimmers.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Clearly the answer is the minimum over answers per lane.  For swimmer who does laps in \(a\) how long will we have to wait for him after arriving at time \(p\)?  Let’s look at \(a \mod p\).  If \(a \mod p = 0\) then he arrives just at the point when we do so the answer is \(0\); otherwise it’s \(a - a \mod p\) as we’ll need to wait for him to complete his lap.  Now take a minimum over answers for \(a, b, c\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1492&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1492b/&quot;&gt;
    Card Deck
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1492/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r704/1492b-card-deck.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Clearly at each point we want to split the deck so that we get the largest card first.  So at each point we need to find the index of the remaining max.  One way to do it is to have a sorted map from values to their indices.  We always operate on a segment of the deck of the form \([1, r]\) (\(1\)-based indexing for indices) with initially \(r = n\).  After finding that maximum is at index \(p\) we go from \(p\) to \(r\), add those cards to the answer and remove from our map with indices.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1492&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1492c/&quot;&gt;
    Maximum width
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1492/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r704/1492c-maximum-width.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;The problem can be seen as having to map all letters in \(t\) to equal letters in \(s\) (in the same order), in such a way that the gap between some two letters in \(s\) is as large as possible.  Firstly, for every \(i\) let’s compute \(mx_i\) and \(mn_i\) which are maximal and minimal, respectively, indices in \(s\) that we can match it with.  Once we have that then clearly the answer is just \(max_{i \in 1..m-1} mn_{i+1}-mn_i\).&lt;/p&gt;

&lt;p&gt;How do we compute them?  For \(mn_i\) a simple greedy approach works where we iterate over \(t\) and move a pointer over \(s\), matching it as soon as we can.  \(mx_i\) can be done in the same way, except matching greedily from the back.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1492&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1492d/&quot;&gt;
    Genius's Gambit
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1492/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1492&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1492e/&quot;&gt;
    Almost Fault-Tolerant Database
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1492/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-704.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate>
        <link>//R-704</link>
        <link href="/R-704"/>
        <guid isPermaLink="true">/R-704</guid>
      </item>
    
      <item>
        <title>Round 703 (Div II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1486&quot;&gt;Codeforces Round #703 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486a/&quot;&gt;
    Shifting Stacks
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r703/1486a-shifting-stacks.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s think what’s the minimal happy configuration.  Clearly it’s stacks with \(1, 2, 3, \ldots\), so if we don’t have that many blocks in total we won’t be able to make a right sequence.  Also, blocks can only move to the right and so the aforementioned condition needs to hold for every index.  If it does then we win as we can clearly send all the surplus above what’s required to the right.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486b/&quot;&gt;
    Eastern Exhibition
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r703/1486b-eastern-exhibition.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;geometry&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Clearly we can decompose this 2D problem into two 1D problems and then just multiply the results.  How do we solve a 1D problem?  Well, the optimal location is always at the median and if there there is an even number of elements than any position between two medians will do.  The intuition for that is clear: there are as many houses to the left as there are to the right so moving left increases the distance by \(1\) and at the same time, for the equal number of houses, decreases by \(1\), not changing it overall.  So if two median houses are at locations \(x_1\) and \(x_2\) (\(x_2 \ge x_1\))we just return the number of points between them, their locations included, that is \(x_2-x_1+1\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;C1

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486c1/&quot;&gt;
    Guessing the Greatest (easy version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/C1&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r703/1486c1-guessing-the-greatest-easy.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;It’s fairly easy to see that binary search is the way to go.  \(log_2 10^5 &amp;lt; 17\), so we can do \(2\) queries at every step.  How do we decide if the max is in the left or the right part?  Well, firstly let’s ask for the whole interval, i.e. \([l, r]\).  Assume that the answer, \(x\), is in the left part (other case is symmetrical), i.e. \(x \in [l, m]\) (\(m = \frac{l+r}{2}\)).  In that case let’s ask for that interval \([l, m]\).  If the answer is \(x\) again then that means that globally second element is there and it’s also a second element in the left part so max must be there as well; otherwise we go to the right part.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;C2

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486c2/&quot;&gt;
    Guessing the Greatest (hard version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/C2&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r703/1486c2-guessing-the-greatest-hard.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Now we need to be more efficient as \(2\) queries per move will not do anymore.&lt;/p&gt;

&lt;p&gt;Note how we were wasting some queries in our strategy?  I.e. if both answers were the same, so we asked for \([l, r]\) and \([l, m]\) (or \([m, r]\)) and got the same answer then we continue with the \([l, m]\) range (\([m, r]\)) and &lt;em&gt;don’t have to ask for it again&lt;/em&gt;.  The same is not true for the other case, but I thought that we can take advantage of this asymmetry: rather than making both intervals the same, let’s make them unequal so that the case where we have to ask twice gains us more.  Unfortunately a) the math does not work out (we still need more than \(20\) queries) and b) this reasoning is flawed as we &lt;em&gt;cannot&lt;/em&gt; pick which part the answer will be in and so don’t know which segment to make smaller/larger.&lt;/p&gt;

&lt;p&gt;Instead the solution is quite simple really.  Let’s get the global answer for \([1, n]\), say it’s \(x\).  Now let’s figure out whether our answer is to the left or to the right of \(x\), just as we did in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C1&lt;/code&gt;.  Let’s say that it’s to the right of \(x\) (the other case being symmetrical).  Note that our answer is simply the &lt;em&gt;smallest&lt;/em&gt; \(p \in [x+1, n]\) such that the answer for \([x, p]\) is \(x\).  That’s simply because if the global max is not in our range then the globally second element will &lt;em&gt;not&lt;/em&gt; be the second largest element in the range.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486d/&quot;&gt;
    Max Median
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486e/&quot;&gt;
    Paired Payment
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;shortest paths&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486f/&quot;&gt;
    Pairs of Paths
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-703.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Thu, 18 Feb 2021 00:00:00 +0000</pubDate>
        <link>//R-703</link>
        <link href="/R-703"/>
        <guid isPermaLink="true">/R-703</guid>
      </item>
    
  </channel>
</rss>
