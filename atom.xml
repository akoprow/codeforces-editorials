<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Codeforces editorials</title>
    <description>Codeforces editorials</description>
    <link></link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <author>
      <name>Adam Koprowski</name>
      <email>Adam.Koprowski@gmail.com</email>
      <uri></uri>
    </author>
    
      <item>
        <title>Round 703 (Div II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1486&quot;&gt;Codeforces Round #703 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486a/&quot;&gt;
    Shifting Stacks
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r703/1486a-shifting-stacks.kt&quot;&gt;(Code)&lt;/a&gt;

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s think what’s the minimal happy configuration.  Clearly it’s stacks with \(1, 2, 3, \ldots\), so if we don’t have that many blocks in total we won’t be able to make a right sequence.  Also, blocks can only move to the right and so the aforementioned condition needs to hold for every index.  If it does then we win as we can clearly send all the surplus above what’s required to the right.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486b/&quot;&gt;
    Eastern Exhibition
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r703/1486b-eastern-exhibition.kt&quot;&gt;(Code)&lt;/a&gt;

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;geometry&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Clearly we can decompose this 2D problem into two 1D problems and then just multiply the results.  How do we solve a 1D problem?  Well, the optimal location is always at the median and if there there is an even number of elements than any position between two medians will do.  The intuition for that is clear: there are as many houses to the left as there are to the right so moving left increases the distance by \(1\) and at the same time, for the equal number of houses, decreases by \(1\), not changing it overall.  So if two median houses are at locations \(x_1\) and \(x_2\) (\(x_2 \ge x_1\))we just return the number of points between them, their locations included, that is \(x_2-x_1+1\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;C1

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486c1/&quot;&gt;
    Guessing the Greatest (easy version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/C1&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r703/1486c1-guessing-the-greatest-easy.kt&quot;&gt;(Code)&lt;/a&gt;

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;It’s fairly easy to see that binary search is the way to go.  \(log_2 10^5 &amp;lt; 17\), so we can do \(2\) queries at every step.  How do we decide if the max is in the left or the right part?  Well, firstly let’s ask for the whole interval, i.e. \([l, r]\).  Assume that the answer, \(x\), is in the left part (other case is symmetrical), i.e. \(x \in [l, m]\) (\(m = \frac{l+r}{2}\)).  In that case let’s ask for that interval \([l, m]\).  If the answer is \(x\) again then that means that globally second element is there and it’s also a second element in the left part so max must be there as well; otherwise we go to the right part.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;C2

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486c2/&quot;&gt;
    Guessing the Greatest (hard version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/C2&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r703/1486c2-guessing-the-greatest-hard.kt&quot;&gt;(Code)&lt;/a&gt;

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Now we need to be more efficient as \(2\) queries per move will not do anymore.&lt;/p&gt;

&lt;p&gt;Note how we were wasting some queries in our strategy?  I.e. if both answers were the same, so we asked for \([l, r]\) and \([l, m]\) (or \([m, r]\)) and got the same answer then we continue with the \([l, m]\) range (\([m, r]\)) and &lt;em&gt;don’t have to ask for it again&lt;/em&gt;.  The same is not true for the other case, but I thought that we can take advantage of this asymmetry: rather than making both intervals the same, let’s make them unequal so that the case where we have to ask twice gains us more.  Unfortunately a) the math does not work out (we still need more than \(20\) queries) and b) this reasoning is flawed as we &lt;em&gt;cannot&lt;/em&gt; pick which part the answer will be in and so don’t know which segment to make smaller/larger.&lt;/p&gt;

&lt;p&gt;Instead the solution is quite simple really.  Let’s get the global answer for \([1, n]\), say it’s \(x\).  Now let’s figure out whether our answer is to the left or to the right of \(x\), just as we did in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C1&lt;/code&gt;.  Let’s say that it’s to the right of \(x\) (the other case being symmetrical).  Note that our answer is simply the &lt;em&gt;smallest&lt;/em&gt; \(p \in [x+1, n]\) such that the answer for \([x, p]\) is \(x\).  That’s simply because if the global max is not in our range then the globally second element will &lt;em&gt;not&lt;/em&gt; be the second largest element in the range.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486d/&quot;&gt;
    Max Median
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486e/&quot;&gt;
    Paired Payment
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;shortest paths&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486f/&quot;&gt;
    Pairs of Paths
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-703.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Thu, 18 Feb 2021 00:00:00 +0000</pubDate>
        <link>//R-703</link>
        <link href="/R-703"/>
        <guid isPermaLink="true">/R-703</guid>
      </item>
    
      <item>
        <title>Educational Round 104</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1487&quot;&gt;Educational Codeforces Round 104 (Rated for Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1487&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1487a/&quot;&gt;
    Arena
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1487/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu104/1487a-arena.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Notice that if we have two heroes with levels \(a_i\) and \(a_j\) such that \(a_i &amp;gt; a_j\) then \(a_i\) can easily reach arbitrarily high level by continuing to fight with \(a_j\) over and over again.  So any hero that initially has at least one other hero who’s weaker than him can do that.  Also notice that if for any hero there is no one weaker than him initially then this will continue to be this case as the levels are only ever increasing and so such hero will forever remain at his level and won’t be able to reach \(100^{500}\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1487&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1487b/&quot;&gt;
    Cat Cycle
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1487/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu104/1487b-cat-cycle.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;The case when \(n\) is even is each as the cats never “collide”.&lt;/p&gt;

&lt;p&gt;Otherwise, we can see that they’ll collide every \(\lfloor \frac{n}{2} \rfloor\) moves, so in total they’ll collide \(C = \frac{k}{n/2}\) times.  Each collision means that cat \(A\) moves by \(2\) spots rather than \(1\) (since the next one is occupied) and so he’ll eventually reach position \(((k+C) % n\) (0-based).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1487&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1487c/&quot;&gt;
    Minimum Ties
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1487/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu104/1487c-minimum-ties.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;matrices&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We have a total of \(G = \frac{n \cdot (n-1)}{2}\) games and the number of wins for each team must be equal and so each team should win \(\lfloor \frac{G}{n} \rfloor\) times and also lose that many times.  How do we construct such schedule of games?  The easiest way is for team \(i\) to win against the following teams, i.e. \(i+1, i+2, \ldots\) (everything modulo \(n\)).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1487&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1487d/&quot;&gt;
    Pythagorean Triples
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1487/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu104/1487d-pythagorean-triples.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We need to have \(a^2 + b^2 = c^2\) and \(a^2 - c = b\).  If we subtract the second equation from the first we get:&lt;/p&gt;

\[b^2 + c = c^2 - b \iff b(b+1) = (c-1)c \iff b = c-1\]

&lt;p&gt;Now solving for \(a\):&lt;/p&gt;

\[a^2 - c = b \iff a^2 - (b+1)  = b \iff a^2 = 2b + 1\]

&lt;p&gt;For this to have a solution:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(a^2\) must be odd and so \(a\) must be odd and&lt;/li&gt;
  &lt;li&gt;\(a \neq 1\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Any \(a\) with those two constraints gives a unique solution for \(b\) and \(c\) and such that \(b &amp;lt; c &amp;lt; a \le n\) and so is valid.&lt;/p&gt;

&lt;p&gt;So we simply must compute the number of odd numbers \(a &amp;gt; 1\) such that \(a^2 \le n\).  Naive solution should be \(O(\sqrt(n))\) which should be good enough but I did that and got TLE so instead I used binary search to find the answer.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1487&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1487e/&quot;&gt;
    Cheap Dinner
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1487/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu104/1487e-cheap-dinner.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;For two courses we want to precompute cheapest valid combo of those courses for any choice of the first course.&lt;/p&gt;

&lt;p&gt;How do we combine it for 4 dishes?  Well, let’s start with drinks + desserts, for every drink computing the cheapest combo with a dessert. Now that we move to second courses note that we do not care any more which dessert went into the combo.  So let’s do second courses + drink/dessert combo, having best option for all three for every second course.  Finally we combine that with first courses and we’re done (the code to do it is shorter than this description…).&lt;/p&gt;

&lt;p&gt;So we just reduced this problem to two dishes only.  How do we solve that?  Well, let’s sort the second dish by increasing price and for every first dish let’s go though those options in order stopping at first for which the combo is not forbidden (or concluding there’s no option for the given first dish).  Note that the key here is that there are not too many forbidden combos so we know that the total work we’ll do is bounded by that, more precisely for \(n\) options for first dish, \(m\) for the second and \(f\) forbidden pairs, one pass costs us \(O(m \log{m} + max(n, f))\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1487&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1487f/&quot;&gt;
    Ones
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1487/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1487&lt;/tiny&gt;G

  
  &lt;a href=&quot;/codeforces-editorials/problems/1487g/&quot;&gt;
    String Counting
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1487/problem/G&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/Edu-104.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
        <link>//Edu-104</link>
        <link href="/Edu-104"/>
        <guid isPermaLink="true">/Edu-104</guid>
      </item>
    
      <item>
        <title>Round 700 (Div I+II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1479&quot;&gt;Codeforces Round #700 (Div. 1)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1480&quot;&gt;Codeforces Round #700 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1480&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1480a/&quot;&gt;
    Yet Another String Game
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1480/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r700/1480a-yet-another-string-game.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;games&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Since we’re looking at lexicographic ordering, it’s pretty clear everyone in their move should always change the most significant available letter.  Note that even if it’s Alice’s turn and the first character is “a”, so she cannot improve it from her point of view, she should still change it to “b” (next best), because if she did not Bob would next change it to “z”!&lt;/p&gt;

&lt;p&gt;So Alice changes all letters at odd positions and Bob at even positions.  Alice changes to “a” if possible, or “b” otherwise and Bob changes to “z” if possible and “y” otherwise.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1480&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1480b/&quot;&gt;
    The Great Hero
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1480/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r700/1480b-the-great-hero.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Clearly we need \(\lceil \frac{b_i}{A} \rceil\) rounds to kill monster \(i\) and in the process we will sustain \(a_i \cdot \lceil \frac{b_i}{A} \rceil\) damage.  Our health needs to remain above zero for all, except perhaps the last round.  So let’s pick the largest \(a_i\), i.e. we will leave monster \(i\) as the last to fight, and check if:&lt;/p&gt;

\[B &amp;gt; \sum_i {a_i \cdot \lceil \frac{b_i}{A} \rceil} - \max_i {a_i}\]

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1480&lt;/tiny&gt;C / &lt;tiny&gt;1479&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1480c/&quot;&gt;
    Searching Local Minimum
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1480/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r700/1480c-searching-local-minimum.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Binary search is the answer.  Our goal is to maintain a segment \([l, r]\) such that \(a_{l-1} &amp;gt; a_l\) and \(a_{r+1} &amp;gt; a_r\).  Those two boundary conditions ensure that there must be a local minimum within the segment.  We start with \([1, n]\), where those inequalities hold “in absentia” (also note that there must be a minimum in \([1, n]\) as it contains \(1\) which is a minimum).&lt;/p&gt;

&lt;p&gt;Now how do we perform the step in binary search?  Let’s pick \(m\) in the middle of \([l, r]\) as usual.  However, just asking for \(a_m\) is not enough, we must also ask for \(a_{m+1}\).  Now we have the following options:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(a_{m+1} &amp;lt; a_m\) in which case we continue with \([m+1, r]\), as it clearly fulfils our conditions,&lt;/li&gt;
  &lt;li&gt;\(a_m &amp;gt; a_{m+1}\) and then we continue with \([l, m]\).&lt;/li&gt;
  &lt;li&gt;we cannot have \(a_m = a_{m+1}\) as all numbers are distinct in a permutation.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1480&lt;/tiny&gt;D1 / &lt;tiny&gt;1479&lt;/tiny&gt;B1

  
  &lt;a href=&quot;/codeforces-editorials/problems/1480d1/&quot;&gt;
    Painting the Array I
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1480/problem/D1&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r700/1480d1-painting-the-array-i.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;The following greedy strategy works, let’s construct two optimal subsequences and their last elements (as only those matter) be \(a_l\) and \(a_r\) and we’re now looking at element \(b\).  Then:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;if \(a_l = b\) and \(a_r \neq b\) then assign \(b\) to the right subsequence and we increase the score by \(1\).&lt;/li&gt;
  &lt;li&gt;similarly, if \(a_r = b\) and \(a_l \neq b\) then assign \(b\) to the left subsequence and we increase the score by \(1\).&lt;/li&gt;
  &lt;li&gt;if \(a_l = a_r = b\) then clearly it does not matter to which sequence we assign it.&lt;/li&gt;
  &lt;li&gt;finally if \(a_l \neq b\) and \(a_r \neq b\) then assign \(b\) then check whether in the remaining subsequence we will first get another \(a_l\) or another \(a_r\).  In the former case assign \(b\) to \(a_l\), in the latter to \(a_r\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Formally proving that this works is not trivial.&lt;/p&gt;

&lt;p&gt;I had a completely different reasoning to this which goes something likes this (and unfortunately does not generalize to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;D2&lt;/code&gt;):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;let’s count the longest blocks of equal numbers&lt;/li&gt;
  &lt;li&gt;if the block has one element we can always score \(1\) for it.&lt;/li&gt;
  &lt;li&gt;no matter how long the block we can never score more than \(2\) for it, as at best we can start two new segments in \(a_l\) and \(a_r\).&lt;/li&gt;
  &lt;li&gt;but clearly we cannot always score \(2\) as in the sequence: \(2, 2, 1, 2, 2\).&lt;/li&gt;
  &lt;li&gt;let’s keep count of: last seen double and number of “neutral” elements, starting with no doubles and 0 neutral elements.&lt;/li&gt;
  &lt;li&gt;if we see a single number then if it’s equal to last seen double then we decrement the number of “neutral” elements, otherwise we increment it and regardless we increase score by one.&lt;/li&gt;
  &lt;li&gt;if we get two neutral elements then we can forget about the last double, it’s been neutralized by them (i.e. we know that in both \(a_l\) and \(a_r\) last element is different to it).&lt;/li&gt;
  &lt;li&gt;if we see a second number that is different than the last double then we increment the score by one, reset neutral elements and remember that this element is the new double.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1480&lt;/tiny&gt;D2 / &lt;tiny&gt;1479&lt;/tiny&gt;B2

  
  &lt;a href=&quot;/codeforces-editorials/problems/1480d2/&quot;&gt;
    Painting the Array II
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1480/problem/D2&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r700/1480d2-painting-the-array-ii.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;The generic greedy solution from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;D1&lt;/code&gt; generalizes, only if we see an element that is different than both \(a_l\) and \(a_r\) then we assign it to the sequence whose front element comes &lt;em&gt;sooner&lt;/em&gt; rather than &lt;em&gt;later&lt;/em&gt;.  Showing that it works is not easy.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1480&lt;/tiny&gt;E / &lt;tiny&gt;1479&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1480e/&quot;&gt;
    Continuous City
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1480/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1479&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1479d/&quot;&gt;
    Odd Mineral Resource
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1479/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;probabilities&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1479&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1479e/&quot;&gt;
    School Clubs
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1479/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;fft&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;probabilities&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-700.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate>
        <link>//R-700</link>
        <link href="/R-700"/>
        <guid isPermaLink="true">/R-700</guid>
      </item>
    
      <item>
        <title>Round 699 (Div II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1481&quot;&gt;Codeforces Round #699 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1481&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1481a/&quot;&gt;
    Space Navigation
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1481/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r699/1481a-space-navigation.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, all the talk about reordering is a distraction as the order of instructions has no impact on the final coordinate.  Further, observe that we can easily decompose this 2D problem into two 1D problems along both axis.  Let’s denote by \(\mathcal{T}_U, \mathcal{T}_D, \mathcal{T}_L, \mathcal{T}_R\) the total number of steps that we can make in the respective direction (i.e. \(U, D, L, R\)).  The minimal coordinate we can reach along \(X\) axis is \(-\mathcal{T}_L\) and that’s by keeping all \(L\) moves and deleting all \(R\) instructions.  Similarly the maximal is \(R\).  And we can reach anything in between by deleting some more instructions from those extreme configurations.  So we can reach \([-\mathcal{T}_L, \mathcal{T}_R]\) along the \(X\)-axis and \([-\mathcal{T}_U, \mathcal{T}_D]\) along the \(Y\)-axis and we just need to check if our target lies within that rectangle.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1481&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1481b/&quot;&gt;
    New Colony
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1481/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r699/1481b-new-colony.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We just need to make a simple observation that if we reach a configuration where a boulder falls into the collection system then clearly all the subsequent ones will too.  And moreover since all heights are at most \(100\), this game will have at most \(100\cdot n\) steps before it’s over.  So we can just do the simulation of the boulder falling and even with the naive approach we end up with a \(O(100\cdot n^2)\) solution which is plenty good.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1481&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1481c/&quot;&gt;
    Fence Painting
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1481/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r699/1481c-fence-painting.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Crucial observation here is that the last painter is the key, as whatever he paints will have to remain of color \(c_m\).  Let’s find \(i\) such that \(b_i = c_m\).  We have three options:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(a_i \neq b_i\), we prefer this option over the next one, as in this way the work of the last painter is useful and we might have to make use of that in order to get to the solution,&lt;/li&gt;
  &lt;li&gt;\(a_i = b_i\), in which case his work wasn’t necessarily required but we end up with the right color and clearly we did not have the need for painting anything in this color (if we did, we’d have fallen into the previous case),&lt;/li&gt;
  &lt;li&gt;there is no \(i\) such that \(b_i = c_m\), in which case clearly there is no solution as the painter has to paint and some plank will end up with that color.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If we fell into one of the first two cases then all that remains is for the remaining painters to greedily one by one:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;if the painter paints in a color that we need for some plank then let’s use him there,&lt;/li&gt;
  &lt;li&gt;otherwise let’s make him paint plank \(i\), as the last painter will repaint in anyway.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now we only need to check if we repainted all the planks that needed repainting and we’re done.&lt;/p&gt;

&lt;p&gt;My solution during the live round was somewhat more complicated than that.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1481&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1481d/&quot;&gt;
    AB Graph
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1481/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r699/1481d-ab-graph.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Nice one!  Firstly, let’s get rid of a trivial case: if we have two nodes, say \(u\) and \(v\), connected with the same letter in both directions, i.e. \(u \stackrel{a}{\leftrightarrow} v\) or \(u \stackrel{b}{\leftrightarrow} v\), then we can just follow this cycle for \(m\) steps and get a single repeated letter, which is trivially a palindrome.&lt;/p&gt;

&lt;p&gt;Another easy case is when \(m\) is odd.  Then we can just pick any two nodes and go in the loop between for the required number of steps and no matter what letters on them, we’ll get a palindrome.&lt;/p&gt;

&lt;p&gt;So what remains is an even \(m\) with a graph with no trivial same-letter loop.  Note that in this case we can have at most one node that is connected to everything else by \(a\) (if there were two we’d have an \(a\)-cycle between them) and at most one node that is connected to everything else by \(b\); all the other nodes must have at least one \(a\) and at least one \(b\) connection.  Let’s pick such a node.  Node that it’s impossible only if our graph has only 2 nodes  \(u \leftrightarrow v\) with two different letters, in which case clearly we cannot construct an even length palindrome.  Otherwise, we have a situation like this:&lt;/p&gt;

\[x \underset{a}{\overset{b}{\leftrightarrows}} y \underset{a}{\overset{b}{\leftrightarrows}} z\]

&lt;p&gt;The crucial observation is that we can always make an even length palindrome in this configuration.  The winning combo is: \(y \to^a z \to^b y \to^b x \to^a y \to \ldots\), only depending on whether \(\frac{m}{2}\) is even or odd, we need to start at second or first element, respectively.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1481&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1481e/&quot;&gt;
    Sorting Books
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1481/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1481&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1481f/&quot;&gt;
    AB Tree
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1481/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-699.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Fri, 05 Feb 2021 00:00:00 +0000</pubDate>
        <link>//R-699</link>
        <link href="/R-699"/>
        <guid isPermaLink="true">/R-699</guid>
      </item>
    
      <item>
        <title>Educational Round 103</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1476&quot;&gt;Educational Codeforces Round 103 (Rated for Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476a/&quot;&gt;
    K-divisible Sum
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu103/1476a-k-divisible-sum.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We essentially have three cases:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(n \ge k\) and \(n\) is divisible by \(k\) then the answer is \(1\) as all elements equal to \(1\) are a correct solution&lt;/li&gt;
  &lt;li&gt;\(n \ge k\) but \(n\) not divisible by \(k\) then the answer is \(2\) as all \(1\) is not divisible by \(k\) and we need to bump up some elements to \(2\).&lt;/li&gt;
  &lt;li&gt;\(k &amp;lt; n\) the answer is \(\lceil \frac{k}{n} \rceil\) as we are aiming for the total sum to be \(k\) in this case and that’s the maximum we will need to put in a single element.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476b/&quot;&gt;
    Inflation
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu103/1476b-inflation.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We want:&lt;/p&gt;

\[\frac{p_i}{p_0 + \ldots + p_{i-1}} \le \frac{k}{100}\]

&lt;p&gt;or, equivalently:&lt;/p&gt;

\[100 \cdot p_i \le k \cdot (p_0 + \ldots + p_{i-1})\]

&lt;p&gt;We compute that by keeping track of the running sum.  If at any point the equation does not hold we compute the delta by which we need to increase the running sum, i.e.:&lt;/p&gt;

\[\lceil \frac{100 \cdot p_i - k \cdot (p_0 + \ldots + p_{i-1}}{k} \rceil\]

&lt;p&gt;we update the running sum and continue further.  The sum of all the deltas is our answer.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476c/&quot;&gt;
    Longest Simple Cycle
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu103/1476c-longest-simple-cycle.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;It’s clear that the cycle’s right side will be one of the chains.  So we’ll iterate over that chain, \(i\), and will keep track of the current longest cycle that we can built to the left of \(i\), let’s call that \(q_i\).  To simplify things, notice that we can swap \(a_i\) and \(b_i\) without influencing the result, so let’s normalize it so that always \(a_i &amp;lt; b_i\).&lt;/p&gt;

&lt;p&gt;We have two cases.  If \(a_i = b_i\) then the current chain is connected to the same vertex so \(q_i = 2\) as we can only use the two links to that vertex.&lt;/p&gt;

&lt;p&gt;Otherwise we have two options (a picture is worth a thousand words so see notes for a diagram)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;either we follow the links to the previous chain and then follow that chain, that gives us \(2 + b_i - a_i\) or&lt;/li&gt;
  &lt;li&gt;we follow the links and then combine it with the longest cycle so far for \(2 + q_{i-1} + (a_i - 1) + (c_{i-1} - b_i)\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We combine those two options for the final formula:&lt;/p&gt;

\[q_i = 2 + max(b_i - a_i, q_{i-1} + (a_i - 1) + (c_{i-1} - b_i))\]

&lt;p&gt;Now at each position we close the cycle so need to add the path traversed along the last chain so the final answer is \(max_i (q_i + c_i - 1)\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476d/&quot;&gt;
    Journey
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu103/1476d-journey.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dsu&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;The crucial observation is that if we start at city \(i\) and move to other city \(j\), we can always come back to \(i\).  We can easily see that that’s possible after one step and we can prove it for arbitrary number of steps by induction (or just convince ourselves that it works by observing \(2\) or \(3\) steps).&lt;/p&gt;

&lt;p&gt;So now for each city we compute \(L(i)\) and \(L_rev(i)\) denoting how many steps to the left can we move from city \(i\) in initial/reversed setup (all arrows reversed), respectively.  We have \(L(i) = L_rev(i-1)+1\) if \(s_{i-1} = &quot;L&quot;\) and \(0\) otherwise.  Similarly \(L_rev(i) = L(i-1) + 1\) if \(s_{i-1} = &quot;R&quot;\) and \(0\) otherwise.&lt;/p&gt;

&lt;p&gt;Now, we do the same for \(R(i)\) and \(R_rev(i)\) to compute our moves to the right.  And we combine it for each city by seeing how far we can go to the left and right, plus the city itself, giving us the final answer for city \(i\) of: \(L_i + R_i + 1\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476e/&quot;&gt;
    Pattern Matching
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476f/&quot;&gt;
    Lanterns
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;G

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476g/&quot;&gt;
    Minimum Difference
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/G&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/Edu-103.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Fri, 29 Jan 2021 00:00:00 +0000</pubDate>
        <link>//Edu-103</link>
        <link href="/Edu-103"/>
        <guid isPermaLink="true">/Edu-103</guid>
      </item>
    
      <item>
        <title>Round 698 (Div I+II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1477&quot;&gt;Codeforces Round #698 (Div. 1)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1478&quot;&gt;Codeforces Round #698 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1478&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1478a/&quot;&gt;
    Nezzar and Colorful Balls
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1478/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r698/1478a-nezzar-and-colorful-balls.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Clearly all the balls with the same number must get different colors so let’s look at all the numbers, count how many times they occur, and take maximum over that.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1478&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1478b/&quot;&gt;
    Nezzar and Lucky Number
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1478/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r698/1478b-nezzar-and-lucky-numbers.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, if given number \(v\) itself contains digit \(d\) then it itself is the answer.&lt;/p&gt;

&lt;p&gt;Otherwise, if \(v \ge 10\cdot d + d\) then we can always represent it as:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(v_1 = 10 \cdot d + (l \mod 10)\) and&lt;/li&gt;
  &lt;li&gt;\(v_2 = d + (l - (l \mod 10))\) where \(l = x - 10\cdot d - d\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(l \ge 0\) because of our initial assumption.&lt;/li&gt;
  &lt;li&gt;\(d\) is the second least significant digit in \(v_1\), so \(v_1\) is lucky.&lt;/li&gt;
  &lt;li&gt;\(d\) is the least significant digit in \(v_2\), so \(v_2\) is lucky.&lt;/li&gt;
  &lt;li&gt;\(v_1 + v_2 = 10 \cdot d + (l \mod 10) + d + (l - (l \mod 10)) = v\).&lt;/li&gt;
  &lt;li&gt;hence \(v_1\) and \(v_2\) are a valid solution.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Otherwise, our only bet is to put together a number of \(d\)s (which are obviously lucky) and see whether what remains has \(d\) as least significant digit (hence is also lucky).  Since we only care about values modulo \(d\) they will quickly start cycling so we only need to consider taking between \(1\) and \(9\) copies of \(d\).&lt;/p&gt;

&lt;p&gt;TODO: Prove/argue why otherwise the answer is no.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1478&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1478c/&quot;&gt;
    Nezzar and Symmetric Array
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1478/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r698/1478c-nezzar-and-symetric-array.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1478&lt;/tiny&gt;D / &lt;tiny&gt;1477&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1478d/&quot;&gt;
    Nezzar and Board
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1478/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:1800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1478&lt;/tiny&gt;E / &lt;tiny&gt;1477&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1478e/&quot;&gt;
    Nezzar and Binary String
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1478/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1478&lt;/tiny&gt;F / &lt;tiny&gt;1477&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1478f/&quot;&gt;
    Nezzar and Nice Beatmap
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1478/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;geometry&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1477&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1477d/&quot;&gt;
    Nezzar and Hidden Permutations
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1477/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1477&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1477e/&quot;&gt;
    Nezzar and Tournaments
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1477/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1477&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1477f/&quot;&gt;
    Nezzar and Chocolate Bars
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1477/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;fft&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;probabilities&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-698.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate>
        <link>//R-698</link>
        <link href="/R-698"/>
        <guid isPermaLink="true">/R-698</guid>
      </item>
    
      <item>
        <title>Round 697 (Div III)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1475&quot;&gt;Codeforces Round #697 (Div. 3)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1475&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1475a/&quot;&gt;
    Odd Divisor
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1475/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475a-odd-divisor.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Surprisingly difficult for Div III A, me thinks!&lt;/p&gt;

&lt;p&gt;Problem limits are too large to check all divisors of numbers.  So we need to do better than that.  Let’s think about factorization of a given number \(x\):&lt;/p&gt;

\[x = p_1^{\alpha_1} \cdot \ldots p_n^{\alpha_n}\]

&lt;p&gt;If any of the factors is odd then clearly \(x\) is divisible by an odd factor.  Now, the only prime number that isn’t odd is \(2\) itself.  So the only number \(x\) that does not have an odd divisor is if \(x = 2^i\) for some \(i\).&lt;/p&gt;

&lt;p&gt;So we only need to check if \(x\) is a power of \(2\); either naively, or, if we want to be fancy, by checking if \(x \&amp;amp; (x-1) = 0\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1475&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1475b/&quot;&gt;
    New Year's Number
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1475/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475b-new-years-numer.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Suppose that there is \(x\) and \(y\) such that:&lt;/p&gt;

\[n = 2020 \cdot x + 2021 \cdot y = 2020 \cdot (x + y) + y\]

&lt;p&gt;We can see that \(n - y\) is divisible by \(2020\).  Take \(y = n \mod 2020\) and we get that \(x = \frac{n-y}{2020} - y\) and we only need to check that \(x \ge 0\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1475&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1475c/&quot;&gt;
    Ball in Berland
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1475/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475c-ball-in-berland.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;hashing&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We can iterate over pairs \((a_i, b_i)\) and for each one we can add:&lt;/p&gt;

\[k - F_a(a_i) - F_b(b_i) - 1\]

&lt;p&gt;where \(F_v(x)\) is the number of \(x\) within vector \(v\).  In other words:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;we take \((a_i, b_i)\) as the first pair,&lt;/li&gt;
  &lt;li&gt;out of the k-1 remaining pairs how many are there that &lt;em&gt;cannot&lt;/em&gt; complement the first pair?  Well, all the ones with boy \(a_i\) in it (as he’s taken) and all the ones with girl \(b_i\) (she’s also taken).  Note that there is only one pair \((a_i, b_i)\) so all the other pairs excluded because of the girl and because of the boy are disjoint, which is why the formula works.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1475&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1475d/&quot;&gt;
    Cleaning the Phone
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1475/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475d-cleaning-the-phone.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s split applications into two groups: one with \(b_i = 1\) (normal) and the other with \(b_i = 2\) (important).  For each group let’s take the application size in decreasing order and compute prefix sums.&lt;/p&gt;

&lt;p&gt;We will iterate over \(x\), indicating how many elements we take from the normal group, from \(0\) up to all the elements in the group.  We compute how much size will that free us up which is the sum of the first \(x\) elements.  Based on that we compute how much more space we need to free up with important applications.  We find the number of important applications we need to remove, \(y\), using binary search.&lt;/p&gt;

&lt;p&gt;Having those two we know that we will loose \(2y+x\) convenience points and we pick the minimum one.&lt;/p&gt;

&lt;p&gt;Actually, instead of binary search we can use two pointers as as we take more and more of normal applications, we will always be decreasing the number of important applications.  So we don’t even need prefix sums, just two pointers over those two arrays.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1475&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1475e/&quot;&gt;
    Advertising Agency
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1475/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475e-advertising-agency.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Clearly we must pick the bloggers with most followers.  So we can sort by the number of followers and choose the first \(k\) of them.&lt;/p&gt;

&lt;p&gt;The only leeway we have is when the last chosen blogger has \(x\) followers and some not chosen bloggers also have \(x\) followers; we can swap them and still have the maximum number of followers.  In other words all bloggers with \(x\) followers are interchangeable for us.  Suppose there are \(k\) such bloggers in the prefix we picked and \(n\) in total in our pool of bloggers.  Well clearly the number of ways in which we can choose them is \({n}\choose{k}\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1475&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1475f/&quot;&gt;
    Unusual Matrix
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1475/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475f-unusual-matrix.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Few observations.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Order of operations does not matter (because xor is commutative)&lt;/li&gt;
  &lt;li&gt;It does not make sense to apply the same operation twice (as it then will cancel itself out)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;One way to think about it is that going from \(a\) to \(b\) is equivalent to going to a matrix of all zeroes from a matrix \(c\) where \(c_{i,j} = [a_{i,j} \neq b_{i,j}]\) (i.e. \(1\) if given cells in both matrices are different, \(0$ otherwise).  So matrix\)c$$ essentially tells us which cells we need to flip (to zero them).&lt;/p&gt;

&lt;p&gt;Now, we will now say that columns \(i\) and \(j\) are compatible if either:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;for each row \(p\), \(c_{p,i} = c_{p,i}\) or&lt;/li&gt;
  &lt;li&gt;for each row \(p\), \(a_{p,i} \neq c_{p,i}\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the first case those columns are already equal, in the second case we can make them equal by applying xor to either of the columns.&lt;/p&gt;

&lt;p&gt;Now, let’s check if all columns are compatible with the first one.  If they are we can make all rows identical.  And if we have all rows identical it’s a win, we just flip all those column which are all \(1\) and get a matrix full of zeroes.&lt;/p&gt;

&lt;p&gt;Otherwise, we cannot make all rows equal by applying row operations and so column operations will not help us because there will always be at least one column with some \(0\) and some \(1\) and then that will remain so after applying an operation to it.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1475&lt;/tiny&gt;G

  
  &lt;a href=&quot;/codeforces-editorials/problems/1475g/&quot;&gt;
    Strange Beauty
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1475/problem/G&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475g-strange-beauty.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, let’s sort the input array.  Now for each number \(x\) we will want to see how many numbers smaller than \(x\) we can put together with \(x\) to form a beautiful array.  We keep track of a mapping from a number to that value, let’s call that \(f\), and when seeing \(x\) update mapping for \(x\) to:&lt;/p&gt;

\[\max_{d \in \mathcal{D}(x)} f(d)+1\]

&lt;p&gt;where \(\mathcal{D}{x}\) is a set of all divisors of \(x\).  In other words we go through all divisors of \(d\) (those are all numbers that can be with \(x\) in a beautiful array) and pick the best one, adding \(1\) because we extend the sequence with \(x\).&lt;/p&gt;

&lt;p&gt;To do that we need to efficiently iterate through all divisors of any number and we do that by precomputing all divisors of all numbers up to \(2 \cdot 10^5\) using the sieve of Eratosthenes.&lt;/p&gt;

&lt;p&gt;I actually had a lot of problems avoiding TLE on this problem with Kotlin.&lt;/p&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-697.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Mon, 25 Jan 2021 00:00:00 +0000</pubDate>
        <link>//R-697</link>
        <link href="/R-697"/>
        <guid isPermaLink="true">/R-697</guid>
      </item>
    
      <item>
        <title>Round 696 (Div II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1474&quot;&gt;Codeforces Round #696 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1474&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1474a/&quot;&gt;
    Puzzle From the Future
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1474/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r696/1474a-puzzle-from-the-future.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly note that we always have a choice for every position in \(a\) (\(0\) or \(1\)), which in turn will always lead to a choice for a digit in \(d\).  That means we can make all the digits in \(d\) different and hence make \(d\) of maximum possible length \(n\).  So now it comes down to greedily making digits in \(d\) as large as possible from left to right which we can do by choosing \(1\) for a digit of \(a\) if possible and \(0\) otherwise.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1474&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1474b/&quot;&gt;
    Different Divisors
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1474/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r696/1474b-different-divisors.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;To have at least four divisors \(a\) must be either a product of two primes \(d = p \cdot q\), giving four divisors: \(1, p, q, p \cdot q\), or \(d = p^3\) with divisors: \(1, p, p^2, p^3\).&lt;/p&gt;

&lt;p&gt;For the first case all those divisors need to be at least \(d\) apart, the simplest way to find them is for \(p\) to start from \(d+1\) and pick for it the first prime encountered and, similarly, for \(q\) to pick the first prime greater than or equal to \(p+d\).&lt;/p&gt;

&lt;p&gt;We can prove that it’s enough to consider only the first case as the second one would lead to a larger \(d\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1474&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1474c/&quot;&gt;
    Array Destruction
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1474/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r696/1474c-array-destruction.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Observe that \(x\) strictly decreases after each operation.  We should greedily in each step handle the largest element in the array.  Why?  Suppose at some step we did not.  That means we have \(a_i \le a_j \lt a_k\) and we decide to throw \(a_i + a_j = x\).  After that operation new \(x\) becomes \(a_j \lt a_k\) and so we’ll never be able to get rid of \(a_k\).&lt;/p&gt;

&lt;p&gt;So we sort numbers and process them from the right. In the first step what do we process the largest element with?  Well, let’s try all elements one by one.&lt;/p&gt;

&lt;p&gt;Once we know what’s the pairing we remove it, know what the next \(x\) becomes and continue.  This requires an ordered multiset and leads to \(O(n^2 \log n)\) complexity which was TLE-ing for me.&lt;/p&gt;

&lt;p&gt;Another approach is to start from the largest element and keep track of a multiset \(\mathcal{M}\) of paired elements that we haven’t processed yet.  In each step, looking at \(a_i\), we have two options:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;either the current element is in the multiset, in which case we remove it from it (essentially completing a past pairing or&lt;/li&gt;
  &lt;li&gt;it is not, in which case&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1474&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1474d/&quot;&gt;
    Cleaning
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1474/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r696/1474d-cleaning.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s first solve it without using the superability. Since piles that were not neighbours do not get connected when removing another pile, the only way to get rid of the first pile is by removing it together with the second pile, which is only possible if \(a_1 \le a_2\), in which case we’re left with \(a_2-a_1, a_3, \ldots, a_n\) and we can repeat that reasoning.  By repeating this process for every position \(i\) we can compute \(l_i\) which is the number of stones left on that position after removing all the piles to the left (or undefined is it’s not possible to remove them).  We can do a similar process from right to left and compute \(r_i\).  Now, if \(l_n = 0\) then we’re done without having to use superability.&lt;/p&gt;

&lt;p&gt;Otherwise, we need to see if it can help us.  To do that for all adjacent indices we can consider swapping them.  That means that we’re looking at: \(l_i, a_{i+1}, a_{i+2}, r_{i+3}\) (provided \(l_i\) and \(r_{i+3}\) are defined) and we swap them into: \(l_i, a_{i+2}, a_{i+1}, r_{i+3}\).  Now it’s just a simple simulation to see whether we can solve that configuration.&lt;/p&gt;

&lt;p&gt;If for all indices we cannot then the final answer is NO.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1474&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1474e/&quot;&gt;
    What Is It?
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1474/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1474&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1474f/&quot;&gt;
    1 2 3 4 ...
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1474/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;matrices&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-696.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Tue, 19 Jan 2021 00:00:00 +0000</pubDate>
        <link>//R-696</link>
        <link href="/R-696"/>
        <guid isPermaLink="true">/R-696</guid>
      </item>
    
      <item>
        <title>Round 695 (Div II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1467&quot;&gt;Codeforces Round #695 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1467&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1467a/&quot;&gt;
    Wizard of Orz
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1467/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r695/1467a-wizard-of-orz.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;With just a single panel we clearly pause it so that it shows \(9\).  Otherwise we pause the second panel when it shows \(8\), so that we get a prefix of \(9890123456\ldots\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1467&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1467b/&quot;&gt;
    Hills And Valleys
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1467/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r695/1467b-hills-and-valleys.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;First observation is that changes are very local, changing \(a_i\) might change hill/valley status of elements at positions \(i-1, i, i+1\) only.&lt;/p&gt;

&lt;p&gt;Secondly, it’s always optimal to change \(a_i\) to either \(a_{i-1}\) or \(a_{i+1}\). To see that assume that we picked \(x\) to minimize the number of hills/valleys in \(a_{i-1}, x, a_{i+1}\).  We have two options:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;if \(x &amp;lt; max(a_{i-1}, a_{i+1})\) then we can change \(x\) to be \(min(a_{i-1}, a_{i+1})\), which ensures that there’s no peak/valley at that position.&lt;/li&gt;
  &lt;li&gt;or \(x &amp;gt; min(a_{i-1}, a_{i+1})\) in which case we change it to \(max(a_{i-1}, a_{i+1})\), again ensuring it does not form a peak/valley.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once we know all that it’s enough to compute the number of peaks/valleys in the original configuration and then try all those local modifications, efficiently compute updated score and pick the minimal one.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1467&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1467c/&quot;&gt;
    Three Bags
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1467/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r695/1467c-three-bags.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Think of the operations as a rooted tree.  Nodes are the numbers in the bags. The root is the final number.  A directed edge from one number to the other indicates that we merge those numbers.  Each edge must necessarily connect nodes from different bags.&lt;/p&gt;

&lt;p&gt;What’s the total score?  With each layer of the tree we subtract numbers, so we actually end up switch between subtracting/adding them layer by layer.  That means that the final score is the sum of all elements at odd layers minus the sum of all layers at even layers.  So our goal is to put as little as possible into odd layers.&lt;/p&gt;

&lt;p&gt;A picture is worth a thousand words and the notes have two pictures of the optimal configurations but it comes down to either of those two options, where we manage to pack everything into odd layers except for:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;one element from one bag and one element from a &lt;em&gt;different&lt;/em&gt; bag or&lt;/li&gt;
  &lt;li&gt;all elements from a single bag (split between two layers)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once we know all that it’s very easy to compute those options and pick a better one.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1467&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1467d/&quot;&gt;
    Sum of Paths
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1467/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1467&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1467e/&quot;&gt;
    Distinctive Roots in a Tree
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1467/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-695.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Fri, 08 Jan 2021 00:00:00 +0000</pubDate>
        <link>//R-695</link>
        <link href="/R-695"/>
        <guid isPermaLink="true">/R-695</guid>
      </item>
    
      <item>
        <title>Round 694 (Div I+II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1470&quot;&gt;Codeforces Round #694 (Div. 1)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1471&quot;&gt;Codeforces Round #694 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1471&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1471a/&quot;&gt;
    Strange Partition
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1471/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r694/1471a-strange-partition.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;If all numbers are divisible by \(x\) then it doesn’t matter how many operations we will perform, they will never affect the result.  Otherwise they could and it is not too difficult to see that if we want to minimize the result then it’s best to collapse everything into a single number in which case the answer is:&lt;/p&gt;

\[\lceil \frac{\sum_i a_i}{x} \rceil\]

&lt;p&gt;and to maximize it it’s best not too do any operations for the result of:&lt;/p&gt;

\[\sum_i \lceil \frac{a_i}{x} \rceil\]

&lt;p&gt;The reason for that is because for any \(a, b, x\) we have:&lt;/p&gt;

\[\lceil \frac{a+b}{x} \rceil \le \lceil \frac{a}{x} \rceil + \lceil \frac{b}{x} \rceil\]

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1471&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1471b/&quot;&gt;
    Strange List
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1471/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r694/1471b-strange-list.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We essentially simulate what the robot does by passing through the array, only instead of adding new elements to the array we keep a total sum of its elements and we keep track of the divisor which is \(x\) initially and gets multiplied by \(x\) after each iteration.  If we process an element we add it to the total result (even though it’ll be added in several chunks they will all sum up to its original value).  And once we reach an element that stops being divisible we stop.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1471&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1471c/&quot;&gt;
    Strange Birthday Party
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1471/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r694/1471c-strange-birthday-party.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We solve it greedily by observing that it’s best to give cheapest gifts to people later in the array.  To prove that let’s say that we have two people \(k_i\) and \(k_j\) where \(j &amp;gt; i\), and so \(k_j \ge k_i\), who got gifts \(x\) and \(y\), respectively, with \(x \gt y\) for a total cost of \(x + y\).  Now let’s swap those gifts so that \(k_i\) gets \(y\) (if it was ok to give him \(x\) then it must also be ok to give him smaller \(y\)) and \(k_j\) gets \(min(x, C_j)\) (if it was OK to give \(x\) to \(k_i\) then it must be ok to give it to \(k_j\) as \(k_j \ge k_i\)).  The total cost now becomes \(min(x, C_j) + y\) which is less than or equal than what we had before.&lt;/p&gt;

&lt;p&gt;Now it’s just a matter of starting with giving money to everyone and then going from cheapest to more expensive gifts and handle them to people from right to left for as long as we can.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1471&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1471d/&quot;&gt;
    Strange Definition
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1471/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r694/1471d-strange-definition.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;hashing&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;First, let’s try to see what the adjacency condition means.  Let’s take:&lt;/p&gt;

\[x = p_1^{\alpha_1} \cdot \ldots \cdot p_n^{\alpha_n}\]

\[y = p_1^{\beta_1} \cdot \ldots \cdot p_n^{\beta_n}\]

&lt;p&gt;(some \(\alpha_i, \beta_i\) might be \(0\)). Then we can see that:&lt;/p&gt;

\[gcd(x, y) = p_1^{\min(\alpha_1, \beta_1)} \cdot \ldots \cdot p_n^{min(\alpha_n, \beta_n)}\]

\[lcm(x, y) = p_1^{\max(\alpha_1, \beta_1)} \cdot \ldots \cdot p_n^{max(\alpha_n, \beta_n)}\]

\[\frac{lcm(x, y)}{gcd(x, y)} = p_1^{max(\alpha_1, \beta_1) - min(\alpha_1, \beta_1)} \cdot \ldots = p_1^{\mid \alpha_1 - \beta_1 \mid} \cdot \ldots \cdot p_n^{\mid \alpha_n - \beta_n \mid}\]

&lt;p&gt;Now for a number to be a perfect square, all its exponents must be even as then:&lt;/p&gt;

\[\sqrt{p_1^{2\alpha_1} \cdot \ldots \cdot p_n^{2\alpha_n}} = p_1^{\alpha_1} \cdot \ldots \cdot p_n^{\alpha_n}\]

&lt;p&gt;Going back to the previous formula we therefore conclude that two numbers are adjacent if all their exponents have the same parity.  That means that we don’t care about the exponent, only about their parities so we can normalize all numbers by:&lt;/p&gt;

\[\mathcal{N}(p_1^{\alpha_1} \cdot \ldots \cdot p_n^{\alpha_n}) = p_1^{\alpha_1 \mod 2} \cdot \ldots \cdot p_n^{\alpha_n \mod 2}\]

&lt;p&gt;and then we also have that \(x\) is adjacent to \(y\) iff \(\mathcal{N}(x) = \mathcal{N}(y)\).&lt;/p&gt;

&lt;p&gt;So let’s normalize the input numbers and count frequencies for them (how many copies of each number we have).  The highest frequency count is our initial beauty.&lt;/p&gt;

&lt;p&gt;Now what happens when we start replacing?  If any number occurs with an even frequency then it will be immediately collapsed to \(1\) (as after multiplication all the exponents will be even), otherwise it will remain unchanged.  Which means that after the first step everything will stabilize and will not change any more.&lt;/p&gt;

&lt;p&gt;So we can just compute the initial beauty and the beauty after single step and then use those two numbers to answer queries \(w = 0\) and \(w &amp;gt; 0\), respectively.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1471&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1471e/&quot;&gt;
    Strange Shuffle
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1471/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r694/1471e-strange-shuffle.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s first see the number of card changes after a couple of turns (underlined number is the impostor)&lt;/p&gt;

\[\ldots, 4, 4, 4, \mathbf{\underline{4}}, 4, 4, 4, \ldots\]

\[\ldots, 4, 4, \mathbf{3, \underline{4}, 5}, 4, 4, \ldots\]

\[\ldots, 4, \mathbf{3, 3, \underline{4}, 5, 5}, 4, \ldots\]

\[\ldots, \mathbf{3, 3, 3, \underline{4}, 5, 5, 5}, \ldots\]

&lt;p&gt;Crucial observations are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;impostor will continue holding \(k\) cards,&lt;/li&gt;
  &lt;li&gt;affected people to the left of him will have less than \(k\) cards and to the right of him more than \(k\) cards,&lt;/li&gt;
  &lt;li&gt;number of affected people (to left and right) increases by one after each move.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The idea is to first try to find a block of affected people and, once we have that, we can zone in on the impostor using binary search.&lt;/p&gt;

&lt;p&gt;How do find the block?  In the first moves the number of affected people is so small that it’s hopeless. However, we can wait, say 500 turns, by which point the block will grow to \(500+1+500\).  We need to be careful with hitting impostor so to avoid that we will always query for two consecutive positions in every block.  Even for the maximal \(n = 10^5\) we only have \(100\) blocks and so we will identify a block in at most \(200\) queries.&lt;/p&gt;

&lt;p&gt;Let’s say we found an affected person at position \(i\).  We know whether the affected person is to the left or right of the impostor.  If he’s to the left then we know that impostor is somewhere in the segment of \([i, i+700]\) (or however many turns into the game we are); similarly for the other case, when the person is to the right of impostor.  For such a small segment we can find an impostor in \(\log s\) queries, where \(s\) is the size of the segment, so in this case we need at most \(10\) additional queries.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1471&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1471f/&quot;&gt;
    Strange Housing
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1471/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1470&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1470e/&quot;&gt;
    Strange Permutation
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1470/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1470&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1470f/&quot;&gt;
    Strange Covering
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1470/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;divide and conquer&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-694.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
        <link>//R-694</link>
        <link href="/R-694"/>
        <guid isPermaLink="true">/R-694</guid>
      </item>
    
  </channel>
</rss>
