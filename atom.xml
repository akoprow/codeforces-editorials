<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Codeforces editorials</title>
    <description>Codeforces editorials</description>
    <link></link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <author>
      <name>Adam Koprowski</name>
      <email>Adam.Koprowski@gmail.com</email>
      <uri></uri>
    </author>
    
      <item>
        <title>Round 703 (Div II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1486&quot;&gt;Codeforces Round #703 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486a/&quot;&gt;
    Shifting Stacks
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r703/1486a-shifting-stacks.kt&quot;&gt;(Code)&lt;/a&gt;

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s think what’s the minimal happy configuration.  Clearly it’s stacks with \(1, 2, 3, \ldots\), so if we don’t have that many blocks in total we won’t be able to make a right sequence.  Also, blocks can only move to the right and so the aforementioned condition needs to hold for every index.  If it does then we win as we can clearly send all the surplus above what’s required to the right.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486b/&quot;&gt;
    Eastern Exhibition
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r703/1486b-eastern-exhibition.kt&quot;&gt;(Code)&lt;/a&gt;

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;geometry&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Clearly we can decompose this 2D problem into two 1D problems and then just multiply the results.  How do we solve a 1D problem?  Well, the optimal location is always at the median and if there there is an even number of elements than any position between two medians will do.  The intuition for that is clear: there are as many houses to the left as there are to the right so moving left increases the distance by \(1\) and at the same time, for the equal number of houses, decreases by \(1\), not changing it overall.  So if two median houses are at locations \(x_1\) and \(x_2\) (\(x_2 \ge x_1\))we just return the number of points between them, their locations included, that is \(x_2-x_1+1\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;C1

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486c1/&quot;&gt;
    Guessing the Greatest (easy version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/C1&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r703/1486c1-guessing-the-greatest-easy.kt&quot;&gt;(Code)&lt;/a&gt;

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;It’s fairly easy to see that binary search is the way to go.  \(log_2 10^5 &amp;lt; 17\), so we can do \(2\) queries at every step.  How do we decide if the max is in the left or the right part?  Well, firstly let’s ask for the whole interval, i.e. \([l, r]\).  Assume that the answer, \(x\), is in the left part (other case is symmetrical), i.e. \(x \in [l, m]\) (\(m = \frac{l+r}{2}\)).  In that case let’s ask for that interval \([l, m]\).  If the answer is \(x\) again then that means that globally second element is there and it’s also a second element in the left part so max must be there as well; otherwise we go to the right part.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;C2

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486c2/&quot;&gt;
    Guessing the Greatest (hard version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/C2&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r703/1486c2-guessing-the-greatest-hard.kt&quot;&gt;(Code)&lt;/a&gt;

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Now we need to be more efficient as \(2\) queries per move will not do anymore.&lt;/p&gt;

&lt;p&gt;Note how we were wasting some queries in our strategy?  I.e. if both answers were the same, so we asked for \([l, r]\) and \([l, m]\) (or \([m, r]\)) and got the same answer then we continue with the \([l, m]\) range (\([m, r]\)) and &lt;em&gt;don’t have to ask for it again&lt;/em&gt;.  The same is not true for the other case, but I thought that we can take advantage of this asymmetry: rather than making both intervals the same, let’s make them unequal so that the case where we have to ask twice gains us more.  Unfortunately a) the math does not work out (we still need more than \(20\) queries) and b) this reasoning is flawed as we &lt;em&gt;cannot&lt;/em&gt; pick which part the answer will be in and so don’t know which segment to make smaller/larger.&lt;/p&gt;

&lt;p&gt;Instead the solution is quite simple really.  Let’s get the global answer for \([1, n]\), say it’s \(x\).  Now let’s figure out whether our answer is to the left or to the right of \(x\), just as we did in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C1&lt;/code&gt;.  Let’s say that it’s to the right of \(x\) (the other case being symmetrical).  Note that our answer is simply the &lt;em&gt;smallest&lt;/em&gt; \(p \in [x+1, n]\) such that the answer for \([x, p]\) is \(x\).  That’s simply because if the global max is not in our range then the globally second element will &lt;em&gt;not&lt;/em&gt; be the second largest element in the range.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486d/&quot;&gt;
    Max Median
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486e/&quot;&gt;
    Paired Payment
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;shortest paths&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486f/&quot;&gt;
    Pairs of Paths
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-703.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Thu, 18 Feb 2021 00:00:00 +0000</pubDate>
        <link>//R-703</link>
        <link href="/R-703"/>
        <guid isPermaLink="true">/R-703</guid>
      </item>
    
      <item>
        <title>Round 702 (Div III)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1490&quot;&gt;Codeforces Round #702 (Div. 3)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1490&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1490a/&quot;&gt;
    Dense Array
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1490/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r702/1490a-dense-array.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Clearly, whatever we insert between any two elements will not affect any other pair so we can solve each pair independently.  For a given pair \(a_i, a_{i+1}\) let’s take \(x = min(a_i, a_{i+1})\) and \(y = max(a_i, a_{i+1})\).  If \(2*x \ge y\) then we’re good.  Otherwise, we want to insert \(2x, 4x, 8x, \ldots\) and we can figure out how many of those elements we need with a simple loop.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1490&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1490b/&quot;&gt;
    Balanced Remainders
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1490/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r702/1490b-balanced-remainders.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Numbers don’t matter, only their remainder modulo \(3\).  Let’s count \(c_0, c_1, c_2\) being the number of elements with respective remainders.  In a single move we can decrement \(c_i\) and increment \(c_{(i+1) \mod 3}\).  One greedy approach that we can take is:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;as long as there’s \(c_i\) that is too large, take it and move it to “the next slot” (\(\mod 3\)).&lt;/li&gt;
  &lt;li&gt;it can be shown that at most two rounds through all \(c_i\) will do.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1490&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1490c/&quot;&gt;
    Sum of Cubes
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1490/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r702/1490c-sum-of-cubes.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Note that \(\sqrt[3]{10^{12}} = 10^4\), so in other words the largest number that is useful to use is \(10000\), so for all numbers up to that limit we can precompute their cubes and store in a set.  Then if we want to see if \(x\) can be represented as sum of cubes, iterate over stored cubes smaller than \(x\) and for each \(v^3\), check if \(x - v^3\) is in our precomputed set (i.e. is a cube of some number).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1490&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1490d/&quot;&gt;
    Permutation Transformation
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1490/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r702/1490d-permutation-transformation.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;divide and conquer&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We pretty much just do what the problem describes, via a recursion with three arguments: \((l, r, d)\) being the segment we still operate on \([l, r]\) and current depth \(d\).  We start with \((1, n, 0)\).  At a recursion step we find maximum in \(a_l, \ldots, a_r\) at position \(p\).  We denote \(d\) as the answer for \(a_p\) and we recursively descend into \((l, p-1, d+1)\) and \((p+1, r, d+1)\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1490&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1490e/&quot;&gt;
    Accidental Victory
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1490/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r702/1490e-accidental-victory.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s sort players by the number of tokens they have.  Note that problem speaks about possibility of winning so if we just find one scenario where we win that’s good enough for there to be a non-zero probability that this will actually happen, so that’s good enough.&lt;/p&gt;

&lt;p&gt;Firstly note that we can win with all the players that have not more tokens than we do and by doing so collect their tokens.  So we want to find the number of tokens that we need to have to win.  One option is by doing binary search.  Another is a more direct approach, which is linear after sorting and that’s what I did; see code for details.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1490&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1490f/&quot;&gt;
    Equalize the Array
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1490/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r702/1490f-equalize-the-array.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;The crucial observation is that the winning \(C\) must be a frequency of some element in the array.  And we can have at most \(\sqrt{n}\) different candidates for \(C\) (elements with counts \(1, 2, 3, \ldots\) has a quadratic growth).  So let’s just compute frequencies of all elements to get our candidates.&lt;/p&gt;

&lt;p&gt;Now for a given \(C\) computing the cost to make array \(C\)-beautiful is easy, as for a given element with \(x\) occurrences we have to pay:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(x\) if \(x &amp;lt; C\) as we need to remove all \(x\) copies.&lt;/li&gt;
  &lt;li&gt;\(0\) if \(x = C\),&lt;/li&gt;
  &lt;li&gt;\(x-C\) if \(x &amp;gt; C\) as we need to remove extra copies.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Then we simply pick the best option over all candidate \(C\)s.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1490&lt;/tiny&gt;G

  
  &lt;a href=&quot;/codeforces-editorials/problems/1490g/&quot;&gt;
    Old Floppy Drive 
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1490/problem/G&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r702/1490g-old-floppy-drive.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s start by computing all the points where the disk might stop in a single round, i.e. pairs \((p_i, v_i)\) point on disk \(1 \le p \le n\) and \(v_i = \sum_{i \le p} a_i\).  Note that those points will form an increasing sequence as if we had \(x\) followed by \(y\) and \(y &amp;lt; x\) then it we were to stop at \(y\) we’d have stopped instead at \(x\) before.  Once we have that for a single query we have few cases&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(x \le v_t\) assuming we have \(t\) pairs of possible stopping points.  In this case the disk will stop within the first spin and we can find the point where it stops with binary search.&lt;/li&gt;
  &lt;li&gt;\(x &amp;gt; v_t\) and \(\sum_{i \in 1..n} a_i \le 0\), which means we won’t reach the right point within the first spin and with every spin \(x\) is not increasing so it will never stop.&lt;/li&gt;
  &lt;li&gt;Otherwise, we compute how many full spins we need to get to \(x \le v_t\) (i.e. first case above).  So we know by how much we need to decrease \(x\) and hence how many full spins are required.  After that we’re back in the first case above.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-702.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Tue, 16 Feb 2021 00:00:00 +0000</pubDate>
        <link>//R-702</link>
        <link href="/R-702"/>
        <guid isPermaLink="true">/R-702</guid>
      </item>
    
      <item>
        <title>Educational Round 104</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1487&quot;&gt;Educational Codeforces Round 104 (Rated for Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1487&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1487a/&quot;&gt;
    Arena
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1487/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu104/1487a-arena.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Notice that if we have two heroes with levels \(a_i\) and \(a_j\) such that \(a_i &amp;gt; a_j\) then \(a_i\) can easily reach arbitrarily high level by continuing to fight with \(a_j\) over and over again.  So any hero that initially has at least one other hero who’s weaker than him can do that.  Also notice that if for any hero there is no one weaker than him initially then this will continue to be this case as the levels are only ever increasing and so such hero will forever remain at his level and won’t be able to reach \(100^{500}\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1487&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1487b/&quot;&gt;
    Cat Cycle
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1487/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu104/1487b-cat-cycle.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;The case when \(n\) is even is each as the cats never “collide”.&lt;/p&gt;

&lt;p&gt;Otherwise, we can see that they’ll collide every \(\lfloor \frac{n}{2} \rfloor\) moves, so in total they’ll collide \(C = \frac{k}{n/2}\) times.  Each collision means that cat \(A\) moves by \(2\) spots rather than \(1\) (since the next one is occupied) and so he’ll eventually reach position \(((k+C) % n\) (0-based).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1487&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1487c/&quot;&gt;
    Minimum Ties
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1487/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu104/1487c-minimum-ties.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;matrices&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We have a total of \(G = \frac{n \cdot (n-1)}{2}\) games and the number of wins for each team must be equal and so each team should win \(\lfloor \frac{G}{n} \rfloor\) times and also lose that many times.  How do we construct such schedule of games?  The easiest way is for team \(i\) to win against the following teams, i.e. \(i+1, i+2, \ldots\) (everything modulo \(n\)).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1487&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1487d/&quot;&gt;
    Pythagorean Triples
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1487/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu104/1487d-pythagorean-triples.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We need to have \(a^2 + b^2 = c^2\) and \(a^2 - c = b\).  If we subtract the second equation from the first we get:&lt;/p&gt;

\[b^2 + c = c^2 - b \iff b(b+1) = (c-1)c \iff b = c-1\]

&lt;p&gt;Now solving for \(a\):&lt;/p&gt;

\[a^2 - c = b \iff a^2 - (b+1)  = b \iff a^2 = 2b + 1\]

&lt;p&gt;For this to have a solution:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(a^2\) must be odd and so \(a\) must be odd and&lt;/li&gt;
  &lt;li&gt;\(a \neq 1\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Any \(a\) with those two constraints gives a unique solution for \(b\) and \(c\) and such that \(b &amp;lt; c &amp;lt; a \le n\) and so is valid.&lt;/p&gt;

&lt;p&gt;So we simply must compute the number of odd numbers \(a &amp;gt; 1\) such that \(a^2 \le n\).  Naive solution should be \(O(\sqrt(n))\) which should be good enough but I did that and got TLE so instead I used binary search to find the answer.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1487&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1487e/&quot;&gt;
    Cheap Dinner
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1487/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu104/1487e-cheap-dinner.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;For two courses we want to precompute cheapest valid combo of those courses for any choice of the first course.&lt;/p&gt;

&lt;p&gt;How do we combine it for 4 dishes?  Well, let’s start with drinks + desserts, for every drink computing the cheapest combo with a dessert. Now that we move to second courses note that we do not care any more which dessert went into the combo.  So let’s do second courses + drink/dessert combo, having best option for all three for every second course.  Finally we combine that with first courses and we’re done (the code to do it is shorter than this description…).&lt;/p&gt;

&lt;p&gt;So we just reduced this problem to two dishes only.  How do we solve that?  Well, let’s sort the second dish by increasing price and for every first dish let’s go though those options in order stopping at first for which the combo is not forbidden (or concluding there’s no option for the given first dish).  Note that the key here is that there are not too many forbidden combos so we know that the total work we’ll do is bounded by that, more precisely for \(n\) options for first dish, \(m\) for the second and \(f\) forbidden pairs, one pass costs us \(O(m \log{m} + max(n, f))\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1487&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1487f/&quot;&gt;
    Ones
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1487/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1487&lt;/tiny&gt;G

  
  &lt;a href=&quot;/codeforces-editorials/problems/1487g/&quot;&gt;
    String Counting
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1487/problem/G&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/Edu-104.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
        <link>//Edu-104</link>
        <link href="/Edu-104"/>
        <guid isPermaLink="true">/Edu-104</guid>
      </item>
    
      <item>
        <title>Round 701 (Div II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1485&quot;&gt;Codeforces Round #701 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1485&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1485a/&quot;&gt;
    Add and Divide
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1485/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r701/1485a-add-and-divide.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;ternary search&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;It’s fairly easy to realize that we want to increase \(b\) as much as possible before starting to divide by it (by looking at those two operations next to each other it’s obvious).  So just make sure that \(b\) isn’t \(1\) (if it is increase it once) and then keep on increasing \(b\) and for each one check what the score is by doing repeated division.  What’s the stop condition?  Once a given \(b\) gives us score worse than what we’ve got as a best one so far.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1485&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1485b/&quot;&gt;
    Replace and Keep Sorted
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1485/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r701/1485b-replace-and-keep-sorted.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Note that to make array \(k\)-similar we pick a position, say \(i\), and replace the value at that position to \(a_{i-1} &amp;lt; v &amp;lt; a_{i+1}\) and \(v \neq a_i\).&lt;/p&gt;

&lt;p&gt;It’s possible to compute things directly but the simplest solution (I think) is to use prefix sums.  Compute on each position how many \(k\)-similar arrays we can make by changing value at this position, which is trivial given the observation above.  Now for each query just take the sum over the segment, only be careful with segment boundaries as for them we now get more solutions as we loose part of the constraints.  So for a segment \([l, r]\) at position \(l\) we can put anything smaller than \(a_{l+1}\) and different than \(a_l\) so we have \(a_{l+1}-2\) options.  Similarly at position \(r\) we can put anything greater than \(a_{r-1}\) and different than \(a_r\) so we have \(k - a_{r-1} - 1\) options.  For the rest of the segment just take the sum using precomputed prefix sums.  Be careful for the case where \(l = r\) in which case any single number other than \(a_l\) is a solution.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1485&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1485c/&quot;&gt;
    Floor and Mod
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1485/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r701/1485c-floor-and-mod.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s say that \(\lfloor \frac{a}{b} \rfloor = a \mod b = k\).  How do those pairs look like for \(k=1\)?  We must have \((v+1, v)\) as then \(\lfloor \frac{v+1}{v} \rfloor = 1 = (v+1) \mod v\).  Then for \(2\) we get: \((2v+2, v)\) with \(\lfloor \frac{2v+2}{v} \rfloor = 2 = 2v+2 \mod v\) etc.&lt;/p&gt;

&lt;p&gt;So let’s iterate over \(k\).  For a given \(k\) we have:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(a = kb + k\),&lt;/li&gt;
  &lt;li&gt;\(b &amp;gt; k\),&lt;/li&gt;
  &lt;li&gt;\(1 \le b \le y\),&lt;/li&gt;
  &lt;li&gt;\(a \le x\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Substituting \(a\) in the last equation we get: \(kb + k \le x\) so we end up with the following constraints on \(b\):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(b \le \frac{x}{k}-1\) and&lt;/li&gt;
  &lt;li&gt;\(k &amp;lt; b \le y\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So the number of solutions for a given \(k\) is: \(max(0, min(y, \frac{x}{k}-1) - k)\).  And from the fact that smallest \(a\) is \(k(k+1) + k\) and \(a \le x\), we easily get an upper bound of the number of iterations to be \(\sqrt{x}\).&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: I used a somewhat different reasoning in the live contest and never validated the above via a submission.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1485&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1485d/&quot;&gt;
    Multiples and Power Differences
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1485/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r701/1485d-multiples-and-power-differences.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;The trick is to realize that there are relatively few solutions and rather than looking for them we must find a trick that “always works”.  The idea is to divide the board into 2-colors so that we always have adjacent cells of different colors and then write into them \(p+q\) and \(p\).  From the problem we have the following constraints:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(p, q \ge 1\),&lt;/li&gt;
  &lt;li&gt;\(p\) is a multiple of the value in one of the cells,&lt;/li&gt;
  &lt;li&gt;\(p+q\) is a multiple of the value in the other cell,&lt;/li&gt;
  &lt;li&gt;\(q\) is equal to \(k^4\) for some \(k\),&lt;/li&gt;
  &lt;li&gt;\(p + q \le 10^6\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Can we find a \((p, q)\) pair that satisfies those constraints?  Turns out we can.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(p\) must be a multiple of a number in given cell (any cell) so our best bet is \(lcm(1, 2, \ldots 16) = 720720\).&lt;/li&gt;
  &lt;li&gt;\(q\) must be a multiple of a number in a given cell &lt;em&gt;and&lt;/em&gt; a \(4\)‘th power of some number so we can just take \(v^4\) where \(v\) is the value in the cell.&lt;/li&gt;
  &lt;li&gt;\(p + q = 720720 + v^4 \le 720720 + 16^4 = 786256 \le 10^6\).&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1485&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1485e/&quot;&gt;
    Move and Swap
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1485/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1485&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1485f/&quot;&gt;
    Copy or Prefix Sum
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1485/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-701.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Fri, 12 Feb 2021 00:00:00 +0000</pubDate>
        <link>//R-701</link>
        <link href="/R-701"/>
        <guid isPermaLink="true">/R-701</guid>
      </item>
    
      <item>
        <title>Round 700 (Div I+II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1479&quot;&gt;Codeforces Round #700 (Div. 1)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1480&quot;&gt;Codeforces Round #700 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1480&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1480a/&quot;&gt;
    Yet Another String Game
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1480/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r700/1480a-yet-another-string-game.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;games&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Since we’re looking at lexicographic ordering, it’s pretty clear everyone in their move should always change the most significant available letter.  Note that even if it’s Alice’s turn and the first character is “a”, so she cannot improve it from her point of view, she should still change it to “b” (next best), because if she did not Bob would next change it to “z”!&lt;/p&gt;

&lt;p&gt;So Alice changes all letters at odd positions and Bob at even positions.  Alice changes to “a” if possible, or “b” otherwise and Bob changes to “z” if possible and “y” otherwise.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1480&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1480b/&quot;&gt;
    The Great Hero
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1480/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r700/1480b-the-great-hero.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Clearly we need \(\lceil \frac{b_i}{A} \rceil\) rounds to kill monster \(i\) and in the process we will sustain \(a_i \cdot \lceil \frac{b_i}{A} \rceil\) damage.  Our health needs to remain above zero for all, except perhaps the last round.  So let’s pick the largest \(a_i\), i.e. we will leave monster \(i\) as the last to fight, and check if:&lt;/p&gt;

\[B &amp;gt; \sum_i {a_i \cdot \lceil \frac{b_i}{A} \rceil} - \max_i {a_i}\]

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1480&lt;/tiny&gt;C / &lt;tiny&gt;1479&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1480c/&quot;&gt;
    Searching Local Minimum
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1480/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r700/1480c-searching-local-minimum.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Binary search is the answer.  Our goal is to maintain a segment \([l, r]\) such that \(a_{l-1} &amp;gt; a_l\) and \(a_{r+1} &amp;gt; a_r\).  Those two boundary conditions ensure that there must be a local minimum within the segment.  We start with \([1, n]\), where those inequalities hold “in absentia” (also note that there must be a minimum in \([1, n]\) as it contains \(1\) which is a minimum).&lt;/p&gt;

&lt;p&gt;Now how do we perform the step in binary search?  Let’s pick \(m\) in the middle of \([l, r]\) as usual.  However, just asking for \(a_m\) is not enough, we must also ask for \(a_{m+1}\).  Now we have the following options:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(a_{m+1} &amp;lt; a_m\) in which case we continue with \([m+1, r]\), as it clearly fulfils our conditions,&lt;/li&gt;
  &lt;li&gt;\(a_m &amp;gt; a_{m+1}\) and then we continue with \([l, m]\).&lt;/li&gt;
  &lt;li&gt;we cannot have \(a_m = a_{m+1}\) as all numbers are distinct in a permutation.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1480&lt;/tiny&gt;D1 / &lt;tiny&gt;1479&lt;/tiny&gt;B1

  
  &lt;a href=&quot;/codeforces-editorials/problems/1480d1/&quot;&gt;
    Painting the Array I
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1480/problem/D1&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r700/1480d1-painting-the-array-i.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;The following greedy strategy works, let’s construct two optimal subsequences and their last elements (as only those matter) be \(a_l\) and \(a_r\) and we’re now looking at element \(b\).  Then:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;if \(a_l = b\) and \(a_r \neq b\) then assign \(b\) to the right subsequence and we increase the score by \(1\).&lt;/li&gt;
  &lt;li&gt;similarly, if \(a_r = b\) and \(a_l \neq b\) then assign \(b\) to the left subsequence and we increase the score by \(1\).&lt;/li&gt;
  &lt;li&gt;if \(a_l = a_r = b\) then clearly it does not matter to which sequence we assign it.&lt;/li&gt;
  &lt;li&gt;finally if \(a_l \neq b\) and \(a_r \neq b\) then assign \(b\) then check whether in the remaining subsequence we will first get another \(a_l\) or another \(a_r\).  In the former case assign \(b\) to \(a_l\), in the latter to \(a_r\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Formally proving that this works is not trivial.&lt;/p&gt;

&lt;p&gt;I had a completely different reasoning to this which goes something likes this (and unfortunately does not generalize to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;D2&lt;/code&gt;):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;let’s count the longest blocks of equal numbers&lt;/li&gt;
  &lt;li&gt;if the block has one element we can always score \(1\) for it.&lt;/li&gt;
  &lt;li&gt;no matter how long the block we can never score more than \(2\) for it, as at best we can start two new segments in \(a_l\) and \(a_r\).&lt;/li&gt;
  &lt;li&gt;but clearly we cannot always score \(2\) as in the sequence: \(2, 2, 1, 2, 2\).&lt;/li&gt;
  &lt;li&gt;let’s keep count of: last seen double and number of “neutral” elements, starting with no doubles and 0 neutral elements.&lt;/li&gt;
  &lt;li&gt;if we see a single number then if it’s equal to last seen double then we decrement the number of “neutral” elements, otherwise we increment it and regardless we increase score by one.&lt;/li&gt;
  &lt;li&gt;if we get two neutral elements then we can forget about the last double, it’s been neutralized by them (i.e. we know that in both \(a_l\) and \(a_r\) last element is different to it).&lt;/li&gt;
  &lt;li&gt;if we see a second number that is different than the last double then we increment the score by one, reset neutral elements and remember that this element is the new double.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1480&lt;/tiny&gt;D2 / &lt;tiny&gt;1479&lt;/tiny&gt;B2

  
  &lt;a href=&quot;/codeforces-editorials/problems/1480d2/&quot;&gt;
    Painting the Array II
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1480/problem/D2&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r700/1480d2-painting-the-array-ii.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;The generic greedy solution from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;D1&lt;/code&gt; generalizes, only if we see an element that is different than both \(a_l\) and \(a_r\) then we assign it to the sequence whose front element comes &lt;em&gt;sooner&lt;/em&gt; rather than &lt;em&gt;later&lt;/em&gt;.  Showing that it works is not easy.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1480&lt;/tiny&gt;E / &lt;tiny&gt;1479&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1480e/&quot;&gt;
    Continuous City
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1480/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1479&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1479d/&quot;&gt;
    Odd Mineral Resource
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1479/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;probabilities&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1479&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1479e/&quot;&gt;
    School Clubs
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1479/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;fft&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;probabilities&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-700.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate>
        <link>//R-700</link>
        <link href="/R-700"/>
        <guid isPermaLink="true">/R-700</guid>
      </item>
    
      <item>
        <title>Round 699 (Div II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1481&quot;&gt;Codeforces Round #699 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1481&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1481a/&quot;&gt;
    Space Navigation
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1481/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r699/1481a-space-navigation.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, all the talk about reordering is a distraction as the order of instructions has no impact on the final coordinate.  Further, observe that we can easily decompose this 2D problem into two 1D problems along both axis.  Let’s denote by \(\mathcal{T}_U, \mathcal{T}_D, \mathcal{T}_L, \mathcal{T}_R\) the total number of steps that we can make in the respective direction (i.e. \(U, D, L, R\)).  The minimal coordinate we can reach along \(X\) axis is \(-\mathcal{T}_L\) and that’s by keeping all \(L\) moves and deleting all \(R\) instructions.  Similarly the maximal is \(R\).  And we can reach anything in between by deleting some more instructions from those extreme configurations.  So we can reach \([-\mathcal{T}_L, \mathcal{T}_R]\) along the \(X\)-axis and \([-\mathcal{T}_U, \mathcal{T}_D]\) along the \(Y\)-axis and we just need to check if our target lies within that rectangle.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1481&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1481b/&quot;&gt;
    New Colony
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1481/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r699/1481b-new-colony.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We just need to make a simple observation that if we reach a configuration where a boulder falls into the collection system then clearly all the subsequent ones will too.  And moreover since all heights are at most \(100\), this game will have at most \(100\cdot n\) steps before it’s over.  So we can just do the simulation of the boulder falling and even with the naive approach we end up with a \(O(100\cdot n^2)\) solution which is plenty good.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1481&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1481c/&quot;&gt;
    Fence Painting
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1481/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r699/1481c-fence-painting.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Crucial observation here is that the last painter is the key, as whatever he paints will have to remain of color \(c_m\).  Let’s find \(i\) such that \(b_i = c_m\).  We have three options:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(a_i \neq b_i\), we prefer this option over the next one, as in this way the work of the last painter is useful and we might have to make use of that in order to get to the solution,&lt;/li&gt;
  &lt;li&gt;\(a_i = b_i\), in which case his work wasn’t necessarily required but we end up with the right color and clearly we did not have the need for painting anything in this color (if we did, we’d have fallen into the previous case),&lt;/li&gt;
  &lt;li&gt;there is no \(i\) such that \(b_i = c_m\), in which case clearly there is no solution as the painter has to paint and some plank will end up with that color.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If we fell into one of the first two cases then all that remains is for the remaining painters to greedily one by one:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;if the painter paints in a color that we need for some plank then let’s use him there,&lt;/li&gt;
  &lt;li&gt;otherwise let’s make him paint plank \(i\), as the last painter will repaint in anyway.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now we only need to check if we repainted all the planks that needed repainting and we’re done.&lt;/p&gt;

&lt;p&gt;My solution during the live round was somewhat more complicated than that.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1481&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1481d/&quot;&gt;
    AB Graph
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1481/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r699/1481d-ab-graph.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Nice one!  Firstly, let’s get rid of a trivial case: if we have two nodes, say \(u\) and \(v\), connected with the same letter in both directions, i.e. \(u \stackrel{a}{\leftrightarrow} v\) or \(u \stackrel{b}{\leftrightarrow} v\), then we can just follow this cycle for \(m\) steps and get a single repeated letter, which is trivially a palindrome.&lt;/p&gt;

&lt;p&gt;Another easy case is when \(m\) is odd.  Then we can just pick any two nodes and go in the loop between for the required number of steps and no matter what letters on them, we’ll get a palindrome.&lt;/p&gt;

&lt;p&gt;So what remains is an even \(m\) with a graph with no trivial same-letter loop.  Note that in this case we can have at most one node that is connected to everything else by \(a\) (if there were two we’d have an \(a\)-cycle between them) and at most one node that is connected to everything else by \(b\); all the other nodes must have at least one \(a\) and at least one \(b\) connection.  Let’s pick such a node.  Node that it’s impossible only if our graph has only 2 nodes  \(u \leftrightarrow v\) with two different letters, in which case clearly we cannot construct an even length palindrome.  Otherwise, we have a situation like this:&lt;/p&gt;

\[x \underset{a}{\overset{b}{\leftrightarrows}} y \underset{a}{\overset{b}{\leftrightarrows}} z\]

&lt;p&gt;The crucial observation is that we can always make an even length palindrome in this configuration.  The winning combo is: \(y \to^a z \to^b y \to^b x \to^a y \to \ldots\), only depending on whether \(\frac{m}{2}\) is even or odd, we need to start at second or first element, respectively.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1481&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1481e/&quot;&gt;
    Sorting Books
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1481/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1481&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1481f/&quot;&gt;
    AB Tree
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1481/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-699.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Fri, 05 Feb 2021 00:00:00 +0000</pubDate>
        <link>//R-699</link>
        <link href="/R-699"/>
        <guid isPermaLink="true">/R-699</guid>
      </item>
    
      <item>
        <title>Educational Round 103</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1476&quot;&gt;Educational Codeforces Round 103 (Rated for Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476a/&quot;&gt;
    K-divisible Sum
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu103/1476a-k-divisible-sum.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We essentially have three cases:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(n \ge k\) and \(n\) is divisible by \(k\) then the answer is \(1\) as all elements equal to \(1\) are a correct solution&lt;/li&gt;
  &lt;li&gt;\(n \ge k\) but \(n\) not divisible by \(k\) then the answer is \(2\) as all \(1\) is not divisible by \(k\) and we need to bump up some elements to \(2\).&lt;/li&gt;
  &lt;li&gt;\(k &amp;lt; n\) the answer is \(\lceil \frac{k}{n} \rceil\) as we are aiming for the total sum to be \(k\) in this case and that’s the maximum we will need to put in a single element.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476b/&quot;&gt;
    Inflation
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu103/1476b-inflation.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We want:&lt;/p&gt;

\[\frac{p_i}{p_0 + \ldots + p_{i-1}} \le \frac{k}{100}\]

&lt;p&gt;or, equivalently:&lt;/p&gt;

\[100 \cdot p_i \le k \cdot (p_0 + \ldots + p_{i-1})\]

&lt;p&gt;We compute that by keeping track of the running sum.  If at any point the equation does not hold we compute the delta by which we need to increase the running sum, i.e.:&lt;/p&gt;

\[\lceil \frac{100 \cdot p_i - k \cdot (p_0 + \ldots + p_{i-1}}{k} \rceil\]

&lt;p&gt;we update the running sum and continue further.  The sum of all the deltas is our answer.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476c/&quot;&gt;
    Longest Simple Cycle
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu103/1476c-longest-simple-cycle.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;It’s clear that the cycle’s right side will be one of the chains.  So we’ll iterate over that chain, \(i\), and will keep track of the current longest cycle that we can built to the left of \(i\), let’s call that \(q_i\).  To simplify things, notice that we can swap \(a_i\) and \(b_i\) without influencing the result, so let’s normalize it so that always \(a_i &amp;lt; b_i\).&lt;/p&gt;

&lt;p&gt;We have two cases.  If \(a_i = b_i\) then the current chain is connected to the same vertex so \(q_i = 2\) as we can only use the two links to that vertex.&lt;/p&gt;

&lt;p&gt;Otherwise we have two options (a picture is worth a thousand words so see notes for a diagram)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;either we follow the links to the previous chain and then follow that chain, that gives us \(2 + b_i - a_i\) or&lt;/li&gt;
  &lt;li&gt;we follow the links and then combine it with the longest cycle so far for \(2 + q_{i-1} + (a_i - 1) + (c_{i-1} - b_i)\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We combine those two options for the final formula:&lt;/p&gt;

\[q_i = 2 + max(b_i - a_i, q_{i-1} + (a_i - 1) + (c_{i-1} - b_i))\]

&lt;p&gt;Now at each position we close the cycle so need to add the path traversed along the last chain so the final answer is \(max_i (q_i + c_i - 1)\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476d/&quot;&gt;
    Journey
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu103/1476d-journey.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dsu&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;The crucial observation is that if we start at city \(i\) and move to other city \(j\), we can always come back to \(i\).  We can easily see that that’s possible after one step and we can prove it for arbitrary number of steps by induction (or just convince ourselves that it works by observing \(2\) or \(3\) steps).&lt;/p&gt;

&lt;p&gt;So now for each city we compute \(L(i)\) and \(L_rev(i)\) denoting how many steps to the left can we move from city \(i\) in initial/reversed setup (all arrows reversed), respectively.  We have \(L(i) = L_rev(i-1)+1\) if \(s_{i-1} = &quot;L&quot;\) and \(0\) otherwise.  Similarly \(L_rev(i) = L(i-1) + 1\) if \(s_{i-1} = &quot;R&quot;\) and \(0\) otherwise.&lt;/p&gt;

&lt;p&gt;Now, we do the same for \(R(i)\) and \(R_rev(i)\) to compute our moves to the right.  And we combine it for each city by seeing how far we can go to the left and right, plus the city itself, giving us the final answer for city \(i\) of: \(L_i + R_i + 1\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476e/&quot;&gt;
    Pattern Matching
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476f/&quot;&gt;
    Lanterns
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;G

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476g/&quot;&gt;
    Minimum Difference
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/G&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/Edu-103.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Fri, 29 Jan 2021 00:00:00 +0000</pubDate>
        <link>//Edu-103</link>
        <link href="/Edu-103"/>
        <guid isPermaLink="true">/Edu-103</guid>
      </item>
    
      <item>
        <title>Round 698 (Div I+II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1477&quot;&gt;Codeforces Round #698 (Div. 1)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1478&quot;&gt;Codeforces Round #698 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1478&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1478a/&quot;&gt;
    Nezzar and Colorful Balls
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1478/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r698/1478a-nezzar-and-colorful-balls.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Clearly all the balls with the same number must get different colors so let’s look at all the numbers, count how many times they occur, and take maximum over that.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1478&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1478b/&quot;&gt;
    Nezzar and Lucky Number
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1478/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r698/1478b-nezzar-and-lucky-numbers.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, if given number \(v\) itself contains digit \(d\) then it itself is the answer.&lt;/p&gt;

&lt;p&gt;Otherwise, if \(v \ge 10\cdot d + d\) then we can always represent it as:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(v_1 = 10 \cdot d + (l \mod 10)\) and&lt;/li&gt;
  &lt;li&gt;\(v_2 = d + (l - (l \mod 10))\) where \(l = x - 10\cdot d - d\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(l \ge 0\) because of our initial assumption.&lt;/li&gt;
  &lt;li&gt;\(d\) is the second least significant digit in \(v_1\), so \(v_1\) is lucky.&lt;/li&gt;
  &lt;li&gt;\(d\) is the least significant digit in \(v_2\), so \(v_2\) is lucky.&lt;/li&gt;
  &lt;li&gt;\(v_1 + v_2 = 10 \cdot d + (l \mod 10) + d + (l - (l \mod 10)) = v\).&lt;/li&gt;
  &lt;li&gt;hence \(v_1\) and \(v_2\) are a valid solution.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Otherwise, our only bet is to put together a number of \(d\)s (which are obviously lucky) and see whether what remains has \(d\) as least significant digit (hence is also lucky).  Since we only care about values modulo \(d\) they will quickly start cycling so we only need to consider taking between \(1\) and \(9\) copies of \(d\).&lt;/p&gt;

&lt;p&gt;TODO: Prove/argue why otherwise the answer is no.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1478&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1478c/&quot;&gt;
    Nezzar and Symmetric Array
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1478/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r698/1478c-nezzar-and-symetric-array.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1478&lt;/tiny&gt;D / &lt;tiny&gt;1477&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1478d/&quot;&gt;
    Nezzar and Board
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1478/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:1800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1478&lt;/tiny&gt;E / &lt;tiny&gt;1477&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1478e/&quot;&gt;
    Nezzar and Binary String
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1478/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1478&lt;/tiny&gt;F / &lt;tiny&gt;1477&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1478f/&quot;&gt;
    Nezzar and Nice Beatmap
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1478/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;geometry&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1477&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1477d/&quot;&gt;
    Nezzar and Hidden Permutations
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1477/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1477&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1477e/&quot;&gt;
    Nezzar and Tournaments
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1477/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1477&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1477f/&quot;&gt;
    Nezzar and Chocolate Bars
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1477/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;fft&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;probabilities&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-698.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate>
        <link>//R-698</link>
        <link href="/R-698"/>
        <guid isPermaLink="true">/R-698</guid>
      </item>
    
      <item>
        <title>Round 697 (Div III)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1475&quot;&gt;Codeforces Round #697 (Div. 3)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1475&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1475a/&quot;&gt;
    Odd Divisor
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1475/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475a-odd-divisor.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Surprisingly difficult for Div III A, me thinks!&lt;/p&gt;

&lt;p&gt;Problem limits are too large to check all divisors of numbers.  So we need to do better than that.  Let’s think about factorization of a given number \(x\):&lt;/p&gt;

\[x = p_1^{\alpha_1} \cdot \ldots p_n^{\alpha_n}\]

&lt;p&gt;If any of the factors is odd then clearly \(x\) is divisible by an odd factor.  Now, the only prime number that isn’t odd is \(2\) itself.  So the only number \(x\) that does not have an odd divisor is if \(x = 2^i\) for some \(i\).&lt;/p&gt;

&lt;p&gt;So we only need to check if \(x\) is a power of \(2\); either naively, or, if we want to be fancy, by checking if \(x \&amp;amp; (x-1) = 0\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1475&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1475b/&quot;&gt;
    New Year's Number
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1475/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475b-new-years-numer.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Suppose that there is \(x\) and \(y\) such that:&lt;/p&gt;

\[n = 2020 \cdot x + 2021 \cdot y = 2020 \cdot (x + y) + y\]

&lt;p&gt;We can see that \(n - y\) is divisible by \(2020\).  Take \(y = n \mod 2020\) and we get that \(x = \frac{n-y}{2020} - y\) and we only need to check that \(x \ge 0\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1475&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1475c/&quot;&gt;
    Ball in Berland
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1475/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475c-ball-in-berland.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;hashing&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We can iterate over pairs \((a_i, b_i)\) and for each one we can add:&lt;/p&gt;

\[k - F_a(a_i) - F_b(b_i) - 1\]

&lt;p&gt;where \(F_v(x)\) is the number of \(x\) within vector \(v\).  In other words:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;we take \((a_i, b_i)\) as the first pair,&lt;/li&gt;
  &lt;li&gt;out of the k-1 remaining pairs how many are there that &lt;em&gt;cannot&lt;/em&gt; complement the first pair?  Well, all the ones with boy \(a_i\) in it (as he’s taken) and all the ones with girl \(b_i\) (she’s also taken).  Note that there is only one pair \((a_i, b_i)\) so all the other pairs excluded because of the girl and because of the boy are disjoint, which is why the formula works.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1475&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1475d/&quot;&gt;
    Cleaning the Phone
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1475/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475d-cleaning-the-phone.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s split applications into two groups: one with \(b_i = 1\) (normal) and the other with \(b_i = 2\) (important).  For each group let’s take the application size in decreasing order and compute prefix sums.&lt;/p&gt;

&lt;p&gt;We will iterate over \(x\), indicating how many elements we take from the normal group, from \(0\) up to all the elements in the group.  We compute how much size will that free us up which is the sum of the first \(x\) elements.  Based on that we compute how much more space we need to free up with important applications.  We find the number of important applications we need to remove, \(y\), using binary search.&lt;/p&gt;

&lt;p&gt;Having those two we know that we will loose \(2y+x\) convenience points and we pick the minimum one.&lt;/p&gt;

&lt;p&gt;Actually, instead of binary search we can use two pointers as as we take more and more of normal applications, we will always be decreasing the number of important applications.  So we don’t even need prefix sums, just two pointers over those two arrays.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1475&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1475e/&quot;&gt;
    Advertising Agency
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1475/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475e-advertising-agency.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Clearly we must pick the bloggers with most followers.  So we can sort by the number of followers and choose the first \(k\) of them.&lt;/p&gt;

&lt;p&gt;The only leeway we have is when the last chosen blogger has \(x\) followers and some not chosen bloggers also have \(x\) followers; we can swap them and still have the maximum number of followers.  In other words all bloggers with \(x\) followers are interchangeable for us.  Suppose there are \(k\) such bloggers in the prefix we picked and \(n\) in total in our pool of bloggers.  Well clearly the number of ways in which we can choose them is \({n}\choose{k}\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1475&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1475f/&quot;&gt;
    Unusual Matrix
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1475/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475f-unusual-matrix.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Few observations.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Order of operations does not matter (because xor is commutative)&lt;/li&gt;
  &lt;li&gt;It does not make sense to apply the same operation twice (as it then will cancel itself out)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;One way to think about it is that going from \(a\) to \(b\) is equivalent to going to a matrix of all zeroes from a matrix \(c\) where \(c_{i,j} = [a_{i,j} \neq b_{i,j}]\) (i.e. \(1\) if given cells in both matrices are different, \(0$ otherwise).  So matrix\)c$$ essentially tells us which cells we need to flip (to zero them).&lt;/p&gt;

&lt;p&gt;Now, we will now say that columns \(i\) and \(j\) are compatible if either:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;for each row \(p\), \(c_{p,i} = c_{p,i}\) or&lt;/li&gt;
  &lt;li&gt;for each row \(p\), \(a_{p,i} \neq c_{p,i}\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the first case those columns are already equal, in the second case we can make them equal by applying xor to either of the columns.&lt;/p&gt;

&lt;p&gt;Now, let’s check if all columns are compatible with the first one.  If they are we can make all rows identical.  And if we have all rows identical it’s a win, we just flip all those column which are all \(1\) and get a matrix full of zeroes.&lt;/p&gt;

&lt;p&gt;Otherwise, we cannot make all rows equal by applying row operations and so column operations will not help us because there will always be at least one column with some \(0\) and some \(1\) and then that will remain so after applying an operation to it.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1475&lt;/tiny&gt;G

  
  &lt;a href=&quot;/codeforces-editorials/problems/1475g/&quot;&gt;
    Strange Beauty
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1475/problem/G&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r697/1475g-strange-beauty.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, let’s sort the input array.  Now for each number \(x\) we will want to see how many numbers smaller than \(x\) we can put together with \(x\) to form a beautiful array.  We keep track of a mapping from a number to that value, let’s call that \(f\), and when seeing \(x\) update mapping for \(x\) to:&lt;/p&gt;

\[\max_{d \in \mathcal{D}(x)} f(d)+1\]

&lt;p&gt;where \(\mathcal{D}{x}\) is a set of all divisors of \(x\).  In other words we go through all divisors of \(d\) (those are all numbers that can be with \(x\) in a beautiful array) and pick the best one, adding \(1\) because we extend the sequence with \(x\).&lt;/p&gt;

&lt;p&gt;To do that we need to efficiently iterate through all divisors of any number and we do that by precomputing all divisors of all numbers up to \(2 \cdot 10^5\) using the sieve of Eratosthenes.&lt;/p&gt;

&lt;p&gt;I actually had a lot of problems avoiding TLE on this problem with Kotlin.&lt;/p&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-697.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Mon, 25 Jan 2021 00:00:00 +0000</pubDate>
        <link>//R-697</link>
        <link href="/R-697"/>
        <guid isPermaLink="true">/R-697</guid>
      </item>
    
      <item>
        <title>Round 696 (Div II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1474&quot;&gt;Codeforces Round #696 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1474&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1474a/&quot;&gt;
    Puzzle From the Future
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1474/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r696/1474a-puzzle-from-the-future.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly note that we always have a choice for every position in \(a\) (\(0\) or \(1\)), which in turn will always lead to a choice for a digit in \(d\).  That means we can make all the digits in \(d\) different and hence make \(d\) of maximum possible length \(n\).  So now it comes down to greedily making digits in \(d\) as large as possible from left to right which we can do by choosing \(1\) for a digit of \(a\) if possible and \(0\) otherwise.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1474&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1474b/&quot;&gt;
    Different Divisors
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1474/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r696/1474b-different-divisors.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;To have at least four divisors \(a\) must be either a product of two primes \(d = p \cdot q\), giving four divisors: \(1, p, q, p \cdot q\), or \(d = p^3\) with divisors: \(1, p, p^2, p^3\).&lt;/p&gt;

&lt;p&gt;For the first case all those divisors need to be at least \(d\) apart, the simplest way to find them is for \(p\) to start from \(d+1\) and pick for it the first prime encountered and, similarly, for \(q\) to pick the first prime greater than or equal to \(p+d\).&lt;/p&gt;

&lt;p&gt;We can prove that it’s enough to consider only the first case as the second one would lead to a larger \(d\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1474&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1474c/&quot;&gt;
    Array Destruction
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1474/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r696/1474c-array-destruction.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Observe that \(x\) strictly decreases after each operation.  We should greedily in each step handle the largest element in the array.  Why?  Suppose at some step we did not.  That means we have \(a_i \le a_j \lt a_k\) and we decide to throw \(a_i + a_j = x\).  After that operation new \(x\) becomes \(a_j \lt a_k\) and so we’ll never be able to get rid of \(a_k\).&lt;/p&gt;

&lt;p&gt;So we sort numbers and process them from the right. In the first step what do we process the largest element with?  Well, let’s try all elements one by one.&lt;/p&gt;

&lt;p&gt;Once we know what’s the pairing we remove it, know what the next \(x\) becomes and continue.  This requires an ordered multiset and leads to \(O(n^2 \log n)\) complexity which was TLE-ing for me.&lt;/p&gt;

&lt;p&gt;Another approach is to start from the largest element and keep track of a multiset \(\mathcal{M}\) of paired elements that we haven’t processed yet.  In each step, looking at \(a_i\), we have two options:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;either the current element is in the multiset, in which case we remove it from it (essentially completing a past pairing or&lt;/li&gt;
  &lt;li&gt;it is not, in which case&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1474&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1474d/&quot;&gt;
    Cleaning
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1474/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r696/1474d-cleaning.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s first solve it without using the superability. Since piles that were not neighbours do not get connected when removing another pile, the only way to get rid of the first pile is by removing it together with the second pile, which is only possible if \(a_1 \le a_2\), in which case we’re left with \(a_2-a_1, a_3, \ldots, a_n\) and we can repeat that reasoning.  By repeating this process for every position \(i\) we can compute \(l_i\) which is the number of stones left on that position after removing all the piles to the left (or undefined is it’s not possible to remove them).  We can do a similar process from right to left and compute \(r_i\).  Now, if \(l_n = 0\) then we’re done without having to use superability.&lt;/p&gt;

&lt;p&gt;Otherwise, we need to see if it can help us.  To do that for all adjacent indices we can consider swapping them.  That means that we’re looking at: \(l_i, a_{i+1}, a_{i+2}, r_{i+3}\) (provided \(l_i\) and \(r_{i+3}\) are defined) and we swap them into: \(l_i, a_{i+2}, a_{i+1}, r_{i+3}\).  Now it’s just a simple simulation to see whether we can solve that configuration.&lt;/p&gt;

&lt;p&gt;If for all indices we cannot then the final answer is NO.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1474&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1474e/&quot;&gt;
    What Is It?
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1474/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1474&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1474f/&quot;&gt;
    1 2 3 4 ...
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1474/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;matrices&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-696.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Tue, 19 Jan 2021 00:00:00 +0000</pubDate>
        <link>//R-696</link>
        <link href="/R-696"/>
        <guid isPermaLink="true">/R-696</guid>
      </item>
    
  </channel>
</rss>
