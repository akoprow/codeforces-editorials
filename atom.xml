<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Codeforces editorials</title>
    <description>Codeforces editorials</description>
    <link></link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <author>
      <name>Adam Koprowski</name>
      <email>Adam.Koprowski@gmail.com</email>
      <uri></uri>
    </author>
    
      <item>
        <title>Round 724 (Div II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1536&quot;&gt;Codeforces Round #724 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1536&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1536a/&quot;&gt;
    Omkar and Bad Story
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1536/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r724/1536a-omkar-and-bad-story.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Tricky until you realize that:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If any number is negative then the answer is “NO”.  This is because: take that negative number and the largest other number \(p\) (there must be at least one).  The difference between them will be larger than \(p\) and we’d have to repeat this process ad infinitum adding new numbers so no dice.&lt;/li&gt;
  &lt;li&gt;Otherwise all the numbers are between \(0\) and \(100\) so \(0, 1, \ldots, 100\) is always a valid answer.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1536&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1536b/&quot;&gt;
    Prinzessin der Verurteilung
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1536/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r724/1536b-prinzessin-der-verurteilung.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We can iterate over all candidates for the MEX and try them one by one.  Note that the answer will be at most \(3\) characters long since there are more 3 character combinations than we can pack into a string of length \(1000\).  So we can solve this neatly with a short and sweet three loops.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1536&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1536c/&quot;&gt;
    Diluc and Kaeya
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1536/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r724/1536c-diluc-and-kaeya.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;hashing&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;I solved it in a much more convoluted way but a simple solution goes as follows.&lt;/p&gt;

&lt;p&gt;Visualize this on a XY plane where ‘D’ goes up and ‘K’ goes right.  The tangent corresponds to the ration of \(Ds/Ks\) and so we can split at every point which has the same tangent as our current point.  So we can just count the numbers of ‘D’, \(c_D\), and ‘K’, \(c_K\), store them in a multiset of pairs as:&lt;/p&gt;

\[(\frac{c_D}{gcd(c_D, c_K)}, \frac{c_K}{gcd(c_D, c_K)})\]

&lt;p&gt;and the cardinality of the element we’re inserting is the answer at that position.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1536&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1536d/&quot;&gt;
    Omkar and Medians
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1536/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r724/1536d-omkar-and-medians.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We can solve this by keeping track of:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(v_1 \le v_2 \ldots \le v_n\) being the elements that must necessarily belong to the array we’re trying to reconstruct.&lt;/li&gt;
  &lt;li&gt;\(c_\ge\): the number of elements that are greater or equal than \(v_n\) but otherwise unconstrained and&lt;/li&gt;
  &lt;li&gt;\(c_\le\): the number of elements that are smaller or equal than \(v_1\) but otherwise unconstrained.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that when considering a new element:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;if it’s not in \(v_1, \ldots, v_n\) we need to add it there,&lt;/li&gt;
  &lt;li&gt;all the remaining moves can be used to increment \(c_\ge\) or \(c_\le\) in such a way as to try to make our element a new median (note that it might not be possible)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It can be implemented using an Ordered Statistic Tree.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1536&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1536e/&quot;&gt;
    Omkar and Forest
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1536/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r724/1536e-omkar-and-forest.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;shortest paths&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s say we fixed positions of \(0\)s and all the rest must be different than \(0\).  The crucial observation is that everything else is uniquely determined.  One way to see that is to visualize a BFS starting from all the \(0\)s at once and by so doing assigning to every cell its closest distance to some \(0\).  If we do that clearly all values only move by \(1\).  And indeed positive values have something smaller than them, namely, the cell on the path to the closest \(0\).&lt;/p&gt;

&lt;p&gt;So the only choice we have is for every cell with “#” whether to turn it into a \(0\) or not, hence the answer is \(2^\mathcal{Q}\), where \(\mathcal{Q}\) is the number of cells with “#”.  The only edge case is when all the cells have “#”, in which case we need to subtract \(1\) from the answer as there must be at least one cell with \(0\) (to “bootstrap” our BFS).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1536&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1536f/&quot;&gt;
    Omkar and Akmar
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1536/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;games&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-724.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Sun, 06 Jun 2021 00:00:00 +0100</pubDate>
        <link>//R-724</link>
        <link href="/R-724"/>
        <guid isPermaLink="true">/R-724</guid>
      </item>
    
      <item>
        <title>Educational Round 110</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1535&quot;&gt;Educational Codeforces Round 110 (Rated for Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1535&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1535a/&quot;&gt;
    Fair Playoff
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1535/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu110/1535a-fair-playoff.kt&quot;&gt;(Code)&lt;/a&gt;

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We can easily determine winners/losers in both matches let’s denote them as \(w_1/l_1\) for the first match and \(w_2/l_2\) for the second one.&lt;/p&gt;

&lt;p&gt;Then the tournament is fair iff:&lt;/p&gt;

\[w_2 &amp;gt; l_1 \land w_1 &amp;gt; l_2\]

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1535&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1535b/&quot;&gt;
    Array Reodering
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1535/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu110/1535b-array-reordering.kt&quot;&gt;(Code)&lt;/a&gt;

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;The optimal strategy is to put the even numbers at the front of the array, as then they will form a good pair with both even and odd numbers to their right.&lt;/p&gt;

&lt;p&gt;So let’s say we have \(n_{even}\) even elements and \(n_{odd}\) odd ones.  We have the following observations:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;all the even elements form good pairs with all the other even elements, which contributes: \(n_{even}\cdot(n_{even}-1)/2\).&lt;/li&gt;
  &lt;li&gt;all the even elements form good pairs with all the odd elements (since we put them to their right), contributing: \(n_{even} \cdot n_{odd}\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So we’re left with figuring out how many good pairs do we have among odd elements.  Since none of the elements is divisible by \(2\) the elements \(x\) and \(y\) form a good pair only if \(gcd(x, y) &amp;gt; 1\) and we can check that condition directly for all the pairs of odd elements.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1535&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1535c/&quot;&gt;
    Unstable String
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1535/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu110/1535c-unstable-string.kt&quot;&gt;(Code)&lt;/a&gt;

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We’ll iterate through characters and keep track of two variables: \(z\) and \(o\), indicating, the lengths of the longest beautiful string ending at current position with a \(0\), respectively, \(1\).&lt;/p&gt;

&lt;p&gt;Transitions are as follows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;if next character is \(0\): \((z', o') := (o+1, 0)\) because we can extend a beautiful string ending with a \(1\) by one character and get another beautiful string and there is no way for us to end with a \(1\).  This contributes \(z'\) (for all the beautiful strings ending with a \(0\)).&lt;/li&gt;
  &lt;li&gt;if next character is \(1\) it’s symmetrical: \((z', o') := (0, z+1)\) and we add \(o'\) to the answer.&lt;/li&gt;
  &lt;li&gt;if next characters is \(?\) we have: \((z', o') := (o+1, z+1)\) since we can replace \(?\) with either \(0\) or \(1\).  Note however that this contributes \(max(z', o')\) as we can pick whatever we like for \(?\) to make the beautiful string as long as possible (but we cannot score for both \(0\) and \(1\) variants at once).&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1535&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1535d/&quot;&gt;
    Playoff Tournament
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1535/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu110/1535d-playoff-tournament.kt&quot;&gt;(Code)&lt;/a&gt;

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Visualize the tournament bracket as a binary tree.  Leaves are first round games.  Root is the final.  Values in the nodes denote the number of teams that can win a given game.  For simplicity let’s actually add an extra layer of leaves which are all \(1\) and will never change: those are the teams on their own.  Then for the internal nodes we have the following rules depending on the value in the string for that game:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;for \(0\), i.e. lower numbered team wins, then the value of the node equals the value of the left child&lt;/li&gt;
  &lt;li&gt;for \(1\) then, similarly, the value is the values of the right child and&lt;/li&gt;
  &lt;li&gt;for \(?\), i.e. either team can win, it’s the sum of both children.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can easily construct that tree for the initial configuration and we can also easily update, as each update only changes the node in question, plus requires re-computation for all the nodes on the path to the root.  The only difficulty remaining is to translate between game numbers and positions of the nodes in our binary tree (which, of course, we store in an array).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1535&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1535e/&quot;&gt;
    Gold Transfer
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1535/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1535&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1535f/&quot;&gt;
    String Distance
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1535/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;hashing&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/Edu-110.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Fri, 04 Jun 2021 00:00:00 +0100</pubDate>
        <link>//Edu-110</link>
        <link href="/Edu-110"/>
        <guid isPermaLink="true">/Edu-110</guid>
      </item>
    
      <item>
        <title>Round 722 (Div. I+II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1528&quot;&gt;Codeforces Round #722 (Div. 1)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1529&quot;&gt;Codeforces Round #722 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1529&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1529a/&quot;&gt;
    Eshag Loves Big Arrays
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1529/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r722/1529a-Eshag-loves-big-arrays.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, it’s easy to see that we will never be able to remove the minimal element(s).  To do so we would need the average of picked numbers to be strictly less than the minimum, but this is impossible as the minimum is the smallest number we can pick.&lt;/p&gt;

&lt;p&gt;Secondly, we can remove all the other elements: just pick the minimum and the element to be removed.&lt;/p&gt;

&lt;p&gt;So, overall, we just check what’s the minimum, count how many such elements there are and everything else can be removed.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1529&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1529b/&quot;&gt;
    Sifid and Strange Subsequences
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1529/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r722/1529b-Sifid-and-strange-subsequences.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;First, observe that we can always add all non-positive elements.  For them \(\mid x - y \mid \ge 0\) and the maximum is at most \(0\) so we’re good.&lt;/p&gt;

&lt;p&gt;Can we add more?  It’s easy to see that we cannot add more than one positive elements.  Suppose we tried to add \(x, y &amp;gt; 0\), but then we have \(\mid x - y \mid &amp;lt; x\) and so necessarily also less than maximum.&lt;/p&gt;

&lt;p&gt;So now we now we can add at most one positive number.  Clearly the smallest one is the best as it puts least constraints.  So just take it and see if it works by checking all consecutive pairs in sorted order.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1529&lt;/tiny&gt;C / &lt;tiny&gt;1528&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1529c/&quot;&gt;
    Parsa's Humongous Tree
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1529/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r722/1529c-Parsa's-humongous-tree.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Exercise says \(a_i \in [l_i, r_i]\) but the intuition suggests that in the optimal solution we can always pick either \(l_i\) or \(r_i\).  How can we convince ourselves that’s true?  Say we have \(a_i \in (l_i, r_i)\).  Let’s then count how many of the neighbours have values smaller/larger than \(a_i\).  If there are more smaller neighbours then we’ll get a better result by increasing \(a_i\) so we might as well increase it all the way to \(r_i\) (note that by doing so we might increase that imbalance even more).  Similarly for the symmetrical case when there are more larger neighbours, in which case \(l_i\) is better.  What if those two sets are equal?  Moving to \(l_i\) or \(r_i\) will at either not make a difference (if we don’t “cross” any of the other numbers by making this move) or improve the result (if we do cross at least one).&lt;/p&gt;

&lt;p&gt;Now that we know that we only need to consider \(l_i\) and \(r_i\) let’s root the tree at an arbitrary node and for all nodes \(u\) we can calculate \(\mathcal{D}_{u,\leftarrow}\) and \(\mathcal{D}_{u,\rightarrow}\) which are the best results we can get for the subtree at \(u\) picking \(l_i\), respectively, \(r_i\), for its value.  Then we do a DFS and calculate those values from leaves up to the root.  The respective equations are rather straightforward.  Clearly, the final answer is
\(max(\mathcal{D}_{r,\leftarrow}, \mathcal{D}_{r,\rightarrow})\) where \(r\) is the root we picked.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1529&lt;/tiny&gt;D / &lt;tiny&gt;1528&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1529d/&quot;&gt;
    Kavi on Pairing Duty
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1529/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r722/1529d-Kavi-on-pairing-duty.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s denote the number of combinations for \(n\) pairs of points by \(f(n)\).  So let’s say we have \(n\) pairs of points, how can we connect them?&lt;/p&gt;

&lt;p&gt;Firstly, we can connect the first and last points, everything else will be inside that arc so we can put there any solution for \(n-1\) pairs of points.  Similarly we can connect first and last but one and second and last points; the arcs will intersect but will have the same length and we have \(n-2\) points left that we can use arbitrarily as they’ll be inside those two initial arcs.  And so on.&lt;/p&gt;

&lt;p&gt;Secondly, we can make all the arcs have equal lengths, which will trivially satisfy correctness constraints. For instance for 6 points we can connect them as: \((1, 2), (3, 4), (5, 6)\) or \((1, 4), (2, 5), (3, 6)\) with arc lengths of \(1\) and \(3\) respectively.  Notice that the number of points being divisible by the arc lengths is the only requirement here.&lt;/p&gt;

&lt;p&gt;Putting those two together we get the final formula as:&lt;/p&gt;

\[f(n) = \mathcal{D}(n) + \sum_{i \in {1 \ldots n-1}} f(i)\]

&lt;p&gt;where \(\mathcal{D}(n)\) is the number of divisors of \(n\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1529&lt;/tiny&gt;E / &lt;tiny&gt;1528&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1529e/&quot;&gt;
    Trees of Tranquillity
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1529/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1529&lt;/tiny&gt;F / &lt;tiny&gt;1528&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1529f/&quot;&gt;
    It's a bird! No, it's a plane! No, it's AaParsa!
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1529/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;shortest paths&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1528&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1528e/&quot;&gt;
    Mashtali and Hagh Trees
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1528/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1528&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1528f/&quot;&gt;
    AmShZ Farm
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1528/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;fft&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-722.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Mon, 24 May 2021 00:00:00 +0100</pubDate>
        <link>//R-722</link>
        <link href="/R-722"/>
        <guid isPermaLink="true">/R-722</guid>
      </item>
    
      <item>
        <title>Round 721 (Div. I+II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1527&quot;&gt;Codeforces Round #721 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1527&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1527a/&quot;&gt;
    And Then There Were K
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1527/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r721/1527a-and-then-there-were-k.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s take the highest set bit in \(n\), suppose it is \(2^k\).  Now, clearly \((2^k) \&amp;amp; (2^k-1) = 0\) as the former only has the \(k\)-th bit set and the latter has all the lower bits but not the \(k\)-th one.  So \(2^k-1\) is an answer.  It’s easy to see that there is not a better one since all numbers from \(2^k\) up to \(n\) have the \(k\)-th bit set.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1527&lt;/tiny&gt;B1

  
  &lt;a href=&quot;/codeforces-editorials/problems/1527b1/&quot;&gt;
    Palindrome Game (easy version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1527/problem/B1&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/codeforces/r720-739/r721/1527b1-palindrome-game-easy.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;games&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, let’s assume that the palindrome has an even length.  Then Bob wins.  This is because initially string is a palindrome so Alice needs to turn some \(0\) into \(1\) and Bob can:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If there is more than one \(0\) left he mimics this move at the corresponding position in the palindrome.  This again gives a palindrome to Alice in her next move.&lt;/li&gt;
  &lt;li&gt;If there is only one \(0\) he can reverse the palindrome and so Alice will be forced in the next move to remove the remaining \(0\) and lose by at least \(2\$\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What if the initial palindrome has an odd length?  If the character in the middle is \(1\) then it does not change anything.  If it’s a zero then Alice can turn it into \(1\) and win as now Bob is given the starting position equivalent to that for even-length scenario described above.&lt;/p&gt;

&lt;p&gt;Note that those conditions can be simplified as: Bob wins if there is an even number of zeroes whereas Alice wins if there is an odd number.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1527&lt;/tiny&gt;B2

  
  &lt;a href=&quot;/codeforces-editorials/problems/1527b2/&quot;&gt;
    Palindrome Game (hard version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1527/problem/B2&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r721/1527b2-palindrome-game-hard.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;games&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We covered in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B1&lt;/code&gt; the case when the string is a palindrome.  If it is not then Alice almost always wins as she can:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;revert the string, unless&lt;/li&gt;
  &lt;li&gt;the string is one step away from becoming a palindrome with an even number of zeroes.  In that case she makes it so and we’re back to a palindrome case, in which Alice wins by at least \(2\$\) and she paid \(1\$\) in this steps so she still wins.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The only scenario that leads to a draw is if the string has \(2\) zeroes and one of them is in the middle as in this case they will both pay \(1\$\) when played optimally:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If Alice takes the non-middle \(0\), Bob needs to take the middle.&lt;/li&gt;
  &lt;li&gt;If Alice reverts the string then Bob takes the non-middle \(0\) and Alice needs to take the middle one.&lt;/li&gt;
  &lt;li&gt;If Alice take the middle \(0\) then Bob reverts and Alice lost so she will not do that.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1527&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1527c/&quot;&gt;
    Sequence Pair Weight
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1527/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r720-739/r721/1527c-sequence-pair-weight.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;hashing&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s look at all the contributions of all segments ending at character \(i\).  They can be classified as:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;All the contributions ending at character \(i-1\) (we extend those by 1 letter to the right but not yet count the pairs matched with character \(i\)).&lt;/li&gt;
  &lt;li&gt;Suppose we have another occurrence of the same element at index \(j\) (\(j &amp;lt; i\)), how much will this pair contribute?  Well, \(j\), as it will be included in subsegments \([1, i], [2, i], \ldots [j, i]\).  So overall we get \(j_1 + \ldots + j_n\) where \(j_1, \ldots, j_n\) are indices of previous occurrences of the element at position \(i\).  We can easily keep track of that by having a map from element to the prefix sum of its indices seen so far.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1527&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1527d/&quot;&gt;
    MEX Tree
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1527/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1527&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1527e/&quot;&gt;
    Partition Game
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1527/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;divide and conquer&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-721.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Thu, 20 May 2021 00:00:00 +0100</pubDate>
        <link>//R-721</link>
        <link href="/R-721"/>
        <guid isPermaLink="true">/R-721</guid>
      </item>
    
      <item>
        <title>Round 719 (Div III)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1520&quot;&gt;Codeforces Round #719 (Div. 3)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1520&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1520a/&quot;&gt;
    Do Not Be Distracted!
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1520/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r719/1520a-do-not-be-distracted.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We can do it in one pass: consider all blocks of problems (i.e. ignore a problem if it’s the same as the previous one, meaning it belongs to the same block).  Now if any problem has at least \(2\) groups then the teacher can be suspicious.&lt;/p&gt;

&lt;p&gt;Alternatively, for every problem find its first and last occurrence.  All the positions in between must also belong to that problem or else the teacher can be suspicious.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1520&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1520b/&quot;&gt;
    Ordinary Numbers
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1520/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r719/1520b-ordinary-numbers.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Simply iterate through all the digits from \(1\) to \(9\) and for each digit keep constructing ordinary numbers with increasing number of digits (i.e. \(d, dd, ddd, \ldots\)) until they exceed \(n\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1520&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1520c/&quot;&gt;
    Not Adjacent Matrix
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1520/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r719/1520c-not-adjacent-matrix.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;As it turns out \(n = 2\) is the only case where there is no answer.  For all the other numbers we can do a simple construction of dividing the board into black and white cells, like a chessboard.  First fill black cells row by row from \(1\) going up and then continue, similarly, with higher numbers for white cells, so that for instance for \(n = 3\) we get:&lt;/p&gt;

\[\begin{pmatrix}1 &amp;amp; 6 &amp;amp; 2 \\ 7 &amp;amp; 3 &amp;amp; 8 \\ 4 &amp;amp; 9 &amp;amp; 5 \end{pmatrix}\]

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1520&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1520d/&quot;&gt;
    Same Differences
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1520/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r719/1520d-same-differences.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;hashing&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;So \(a_j − a_i = j − i\) can be represented equivalently as:  \(a_j - j = a_i - a_i\).  So we can transform each number \(a_i\) into \(a_i - i\) and now the problem can be reduced to finding the number of equal values in such transformed array.  We do that simply by doing frequency counts and each value occurring \(x\) times gives us \(\frac{x \cdot (x-1)}{2}\) such pairs.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1520&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1520e/&quot;&gt;
    Arranging The Sheep
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1520/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r719/1520e-arranging-the-sheep.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;I solved it by considering all sheeps one by one and assuming that a given sheep is stationary.  Then with a DP it’s possible for every prefix to compute the cost of moving all the sheep up until that position to form a line ending at that position (i.e. going from \(*.*.* \to ..***\)) and similarly for every suffix.&lt;/p&gt;

&lt;p&gt;But actually there’s a much simpler solution hinging on the fact that if there are \(k\) sheeps then in the optimal solution sheep \(\lceil \frac{k}{2} \rceil\) should remain stationary and then it’s just a simple single sweep calculation.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1520&lt;/tiny&gt;F1

  
  &lt;a href=&quot;/codeforces-editorials/problems/1520f1/&quot;&gt;
    Guess the K-th Zero (Easy version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1520/problem/F1&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r719/1520f1-guess-the-kth-zero-easy.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;This is just a simple binary search.  We will maintain a segment in which the \(k\)‘th zero must be, starting with the full \([0, n-1]\) segment.&lt;/p&gt;

&lt;p&gt;Let’s say we are looking for the \(k\)‘th zero and we know it is within \([l, r]\).  Pick \(m = \lfloor \frac{l+r}{2} \rfloor\), ask for segment \([l, m]\).  Let’s say the answer is \(s\).  Than means that there are \(z = m-l+1-s\) zeros in that segment and so:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;if \(z \ge k\) then we continue searching for \(k\) zeros in \([l, m]\)&lt;/li&gt;
  &lt;li&gt;if \(z &amp;lt; k\) then we continue searching for \(k-z\) zeros in \([m+1, r]\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We end up asking at most \(\log n\) queries, which is fine.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1520&lt;/tiny&gt;F2

  
  &lt;a href=&quot;/codeforces-editorials/problems/1520f2/&quot;&gt;
    Guess the K-th Zero (Hard version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1520/problem/F2&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r719/1520f2-guess-the-kth-zero-hard.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;This is similar to the easy problem except we need to be smarter and remember responses and re-use answers rather than asking again.&lt;/p&gt;

&lt;p&gt;When doing so we need to be careful to account for the changes in the array by remembering that the zeroes we guessed so far were changed into ones.  The easiest way to do it is to store answers pertaining to the original array and then when re-using an answer for segment \([l, r]\), add to it the number of guessed zeros we’ve made so far in that range (by using an OST).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1520&lt;/tiny&gt;G

  
  &lt;a href=&quot;/codeforces-editorials/problems/1520g/&quot;&gt;
    To Go Or Not To Go?
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1520/problem/G&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r719/1520g-to-go-or-not-to-go.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;shortest paths&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, observe that there is no point to using portal more than once.  If we have a solution that uses portal multiple times then we can always jump from the first portal immediately to the last, removing the part in the middle and reducing the cost.  So the answer can have one of the two forms:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;go from start to end without any use of portals.&lt;/li&gt;
  &lt;li&gt;go from start to portal \(A\), teleport to \(B\) and go from there to the end.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can compute costs of those options by doing a flood algorithm from start and keeping track of:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;the cheapest direct route to the end (if any) and&lt;/li&gt;
  &lt;li&gt;the cheapest way to some portal + cost of taking that portal.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Then we do flood from the end to compute:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;the cheapest way from end to some portal + cost of taking it.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Combining the two we get the answers for the original two options and we’re done.&lt;/p&gt;

&lt;p&gt;Careful that both start and end can be portals (I failed during the contest because of that).&lt;/p&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-719.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Wed, 05 May 2021 00:00:00 +0100</pubDate>
        <link>//R-719</link>
        <link href="/R-719"/>
        <guid isPermaLink="true">/R-719</guid>
      </item>
    
      <item>
        <title>Educational Round 107</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1511&quot;&gt;Educational Codeforces Round 107 (Rated for Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1511&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1511a/&quot;&gt;
    Review Site
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1511/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu107/1511a-review-site.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;The basic idea is to send all the nay-sayers to the second server and all the positive ones to the first ones, hence ensuring that everyone who’s undecided says yes.  Helpfully draws are in our favour so the answer is simply the total number of reviewers of types \(1\) and \(3\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1511&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1511b/&quot;&gt;
    GCD Length
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1511/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu107/1511b-GCD-length.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Since \(10 = 2 \cdot 5\) we have that \(10^i = 2^i \cdot 5^i\).  So let’s take \(x = 100\ldots 0 \cdot 10^{c-1}\) and \(y = 111\ldots 1 \cdot 10^{c-1}\). We have \(gcd(x, y) = 10^{c-1}\) since \(10^i\) and \(11\ldots1\) are relatively prime.  So we can prepend the prefix of required length to both \(x\) and \(y\) and we’re done.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1511&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1511c/&quot;&gt;
    Yet Another Card Deck
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1511/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu107/1511c-yet-another-card-deck.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, clearly we only need to keep track of the top card of each color.  Secondly, when we move card from position \(p\) to the top then the index of all the cards which previously had an index less than \(p\) increases by \(1\).  So this easily leads to a simulation of the process with \(O(nk)\) complexity.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1511&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1511d/&quot;&gt;
    Min Cost String
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1511/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu107/1511d-min-cost-string.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;It was fairly easy to solve it (greedily) but much harder to prove that that (greedy) solution works.  The main observation is that we have \(k^2\) pairs of letters and we want to use them “uniformly”, i.e. if the generated string is short enough then just use as many of those pairs as we can, as that will give us a \(0\) cost.  Otherwise, try to repeat each pair as few times as possible.  We essentially do it by keeping track of unused pairs and being careful not to get into a letter from which we cannot move forward (i.e. do not follow \(x\) with \(y\) if there are no moves from \(y\)).  Once we use all the pairs recreate them again and start from scratch.&lt;/p&gt;

&lt;p&gt;There’s a nice interpretation of this problem where we are basically looking for an Eulerian cycle in a graph (a clique actually) of letters.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1511&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1511e/&quot;&gt;
    Colorings and Dominoes
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1511/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1511&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1511f/&quot;&gt;
    Chainword
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1511/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;matrices&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1511&lt;/tiny&gt;G

  
  &lt;a href=&quot;/codeforces-editorials/problems/1511g/&quot;&gt;
    Chips on a Board
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1511/problem/G&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;games&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/Edu-107.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Mon, 12 Apr 2021 00:00:00 +0100</pubDate>
        <link>//Edu-107</link>
        <link href="/Edu-107"/>
        <guid isPermaLink="true">/Edu-107</guid>
      </item>
    
      <item>
        <title>Round 712 (Div I+II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1503&quot;&gt;Codeforces Round #712 (Div. 1)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1504&quot;&gt;Codeforces Round #712 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1504&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1504a/&quot;&gt;
     Déjà Vu
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1504/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r712/1504a-deja-vu.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We cannot just try inserting “a” at every position and checking if we get a palindrome as that will TLE.  However, note that we can just try inserting at the beginning and at the end.  If neither works then there’s no solution.  Why?   Since \(a\vec{x}\) is a palindrome and \(\vec{x}a\) is a palindrome then clearly \(\vec{v}\) starts and ends with an \(a\) and in fact is just a sequence of \(a\) so clearly inserting \(a\) anything into it will not give us a palindrome.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1504&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1504b/&quot;&gt;
    Flip the Bits
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1504/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r712/1504b-flip-the-bits.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We should start fixing from the end, as if some suffix is good we don’t need to touch it ever again.  So we go from the end of the string and keep track of:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;a flag indicating whether we flipped the prefix and&lt;/li&gt;
  &lt;li&gt;number of \(0\)s and \(1\)s in the prefix.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If at current position we get something else than what we need (after taking into account that prefix might have been flipped) then we need to flip that prefix.  So if number of \(0\)s and \(1\)s is different then there’s no solution.  Otherwise we flip the “prefix-flipped” flag and continue.  Regardless of whether the current position matches or not we also update number of \(0/1\) in the prefix.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1504&lt;/tiny&gt;C / &lt;tiny&gt;1503&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1504c/&quot;&gt;
    Balance the Bits
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1504/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r712/1504c-balance-the-bits.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Think of the usual way to check for correctness of such an expression where we count \(+1/-1\) for “(“ / “)” and need to never go below zero and end up with zero.  Note that for both \(a\) and \(b\) we will have some values contributed by the common substring, say \(x\), and some contributed by the parts where they must differ, call it \(y_a\) and \(y_b\).  Then we have that:&lt;/p&gt;

&lt;p&gt;\(x + y_a = 0\) and \(x + y_b = 0\)&lt;/p&gt;

&lt;p&gt;Hence \(y_a = y_b\) but we also know that \(y_a = -y_b\) as those two parts are complementary (i.e. if one has an opening bracket the other one has a closing one and vice versa).  Hence we conclude that \(x = y_a = y_b = 0\).  That means that:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;number of positions on which \(a\) and \(b\) agree must be even and will be split evenly between opening and closing brackets.&lt;/li&gt;
  &lt;li&gt;number of positions on which they differ must be even and we will alternate between opening and closing bracket for it.&lt;/li&gt;
  &lt;li&gt;to minimize the chance that we go below zero at some point (i.e. produce unmatched closing bracket) let’s start with the half of opening brackets and finish with all closing brackets for the common part.&lt;/li&gt;
  &lt;li&gt;all that’s left at this point is to construct \(a\) and \(b\) in the unique way prescribed above and check whether they both are valid expressions.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1504&lt;/tiny&gt;D / &lt;tiny&gt;1503&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1504d/&quot;&gt;
    3-Coloring
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1504/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r712/1504d-3-coloring.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;games&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s think of the grid as a chessboard with alternating black and white squares.  Firstly let’s fill one black and one white square with any, but different, numbers.  We can always do that as:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;in the first move, for the black square, we have two numbers to choose from and either works; say we end up with \(x\)&lt;/li&gt;
  &lt;li&gt;in the second move, for the white square, one number is forbidden, one we potentially cannot use because we used it on black but one number remains; say it’s \(y\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;From there on we just continue filling black with \(x\) and white squares with \(y\).  At some point we will have filled all black (or white) squares but at this point we can put any number on white (black) other than \(x\) (\(y\)).  Again we can always do that as we cannot use \(x\) and we cannot use whatever Alice forbids us to, but one option always remains.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1504&lt;/tiny&gt;E / &lt;tiny&gt;1503&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1504e/&quot;&gt;
    Travelling Salesman Problem
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1504/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;shortest paths&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1504&lt;/tiny&gt;F / &lt;tiny&gt;1503&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1504f/&quot;&gt;
    Flip the Cards
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1504/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;2-sat&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1503&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1503e/&quot;&gt;
    2-Coloring
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1503/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1503&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1503f/&quot;&gt;
    Balance the Cards
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1503/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;divide and conquer&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;geometry&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-712.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Sat, 03 Apr 2021 00:00:00 +0100</pubDate>
        <link>//R-712</link>
        <link href="/R-712"/>
        <guid isPermaLink="true">/R-712</guid>
      </item>
    
      <item>
        <title>Round 711 (Div II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1498&quot;&gt;CodeCraft-21 and Codeforces Round #711 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1498&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1498a/&quot;&gt;
    GCD Sum
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1498/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r711/1498a-gcd-sum.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Simply try consecutive numbers until hitting one that fulfils the requirements.  We won’t have to try for long as numbers divisible by \(3\) have sum of their digits divisible by \(3\) and so at least every third number works.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1498&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1498b/&quot;&gt;
    Box Fitting
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1498/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r711/1498b-box-fitting.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Simple greedy strategy works:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;continue packing largest box that still fits,&lt;/li&gt;
  &lt;li&gt;when nothing fits any more take a new box of size \(w\).&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1498&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1498c/&quot;&gt;
    Planar Reflections
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1498/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r711/1498c-planar-reflections.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;This screams DP.  Let’s call by \(\mathcal{D}_{i, j}\) the number of particles we finally get after a single one hits a plane so that it will \(i\) planes to go through going right and it has power \(j\).&lt;/p&gt;

&lt;p&gt;For boundary conditions clearly if power is \(1\) then answer is \(1\) as it won’t get cloned.&lt;/p&gt;

&lt;p&gt;Otherwise we will get:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(\mathcal{D}_{i-1, j}\) particles after moving right, i.e. we have one fewer planes to go through and our power does not change and&lt;/li&gt;
  &lt;li&gt;\(\mathcal{D}_{n-i, j-1}\) particles after moving left, i.e. our power goes down by one and going to the left is the same as going through the right in the mirror image, so we appropriately adjust the number of planes on our way.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Another option was to have another dimension of the DP indicating direction of travel and it’s quite possible that this was easier to code quickly and correctly.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1498&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1498d/&quot;&gt;
    Bananas in a Microwave
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1498/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1498&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1498e/&quot;&gt;
    Two Houses
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1498/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;probabilities&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1498&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1498f/&quot;&gt;
    Christmas Game
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1498/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;games&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-711.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Mon, 29 Mar 2021 00:00:00 +0100</pubDate>
        <link>//R-711</link>
        <link href="/R-711"/>
        <guid isPermaLink="true">/R-711</guid>
      </item>
    
      <item>
        <title>Round 710 (Div III)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1506&quot;&gt;Codeforces Round #710 (Div. 3)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1506&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1506a/&quot;&gt;
    Strange Table
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1506/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r710/1506a-strange-table.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly we need to find the row and column numbers as: \(r = (x-1) \mod n\) and \(c = \lceil \frac{x-1}{n} \rceil\), respectively (both \(0\)-based).  Then the answer is simply: \(r \cdot m + c + 1\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1506&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1506b/&quot;&gt;
    Partial Replacement
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1506/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r710/1506b-partial-replacement.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Greedy.  Start at the position of the first start and until reaching the last star, in each move go as far right as the constraints allow (i.e. to another star not more than \(k\) characters away).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1506&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1506c/&quot;&gt;
    Double-ended Strings
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1506/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r710/1506c-double-ended-strings.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;hashing&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Given how small the constraints are we can go with a simple solution of just iterating through all the substrings of \(a\) and checking if any of them is a substring of \(b\); if so then we can keep that substring in both and only delete all the remaining characters.  Pick best among all substrings.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1506&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1506d/&quot;&gt;
    Epic Transformation
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1506/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r710/1506d-epic-transformation.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s compute frequency for all the numbers.  Clearly, in every step we can decrement two of those numbers and so we will only be left with one being non-zero and we want to minimize its value.  The optimal strategy is to greedily pair two most frequent numbers.  In fact, let’s say the most frequent element occurs \(m\) times.  Then we can match it \(n - m\) times and so in the end we will be left with \(max(0, m - (n - m))\) of its copies.  Except for when the number of elements is odd, in which case we will only be left with at least \(1\) element unmatched.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1506&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1506e/&quot;&gt;
    Restoring the Permutation
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1506/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r710/1506e-restoring-the-permutation.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s build the permutation from left to right.  Every time we see a new element \(a\) all the elements from the maximal seen so far, all the up to \(a\) become “available”.&lt;/p&gt;

&lt;p&gt;Now we get the answers following a greedy strategy, by choosing smallest/largest available for smallest/largest lexicographically.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1506&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1506f/&quot;&gt;
    Triangular Paths
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1506/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r710/1506f-triangular-paths.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;shortest paths&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Since all arrows point downwards the only possible path is by visiting them in the increasing order of layers.  So what’s left is to know how to compute the cost of moving between two given coordinates.&lt;/p&gt;

&lt;p&gt;My thinking was to introduce a notion of a “line” where the first one contains \((1, 1), (2, 2), (3, 3), \ldots\), the second one \((2, 1), (3, 2), (4, 3), \ldots\) etc. (see notes for clarification).  So coordinate \((x, y)\) is in line \(x-y\).&lt;/p&gt;

&lt;p&gt;Now suppose we want to go from \((x_1, y_1)\) to \((x_2, y_2)\).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If they are in the same line, then we can move for free if it’s an odd line (as all arrows go the way we want them) or for \(x_2 - x_1\) otherwise (as we need to flip all the arrows between them).&lt;/li&gt;
  &lt;li&gt;If they are on different lines then the answer is the number of times we need to go from odd to even line, as we can do all the necessary travelling “down-right” on some odd line on the way.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1506&lt;/tiny&gt;G

  
  &lt;a href=&quot;/codeforces-editorials/problems/1506g/&quot;&gt;
    Maximize the Remaining String
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1506/problem/G&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r710/1506g-maximize-the-remaining-string.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;For each letter we need to leave just one (any) copy of it.  Firstly let’s build for each letter a lists of positions at which it occurs.  Now we will build \(t\) by looking at all the indices of last occurrences for all the letters and taking minimum over them, let’s call that \(p\).  As it’s the last occurrence of some letter, we eventually need to use it, unless we use one of it earlier occurrences.  The candidates for the next letter in \(t\) are all the letters that are not yet in \(t\) and occur in the first \(p\) characters of \(s\).  We want lexicographically largest solution so let’s pick the largest candidate.  Once we pick it we cannot use that letter any more and from all the list of indices for all the letters we can remove the ones that are smaller or equal to \(p\), then continue until we distributed all the letters.&lt;/p&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-710.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
        <link>//R-710</link>
        <link href="/R-710"/>
        <guid isPermaLink="true">/R-710</guid>
      </item>
    
      <item>
        <title>Round 709 (Div I+II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1483&quot;&gt;Codeforces Round #709 (Div. 1, based on Technocup 2021 Final Round)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1484&quot;&gt;Codeforces Round #709 (Div. 2, based on Technocup 2021 Final Round)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1484&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1484a/&quot;&gt;
    Prison Break
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1484/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r709/1484a-prison-break.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;It’s fairly easy to find a solution with \(n \cdot m\), for instance doing a snake like pattern from top-left to bottom, going row by row.  An argument why that’s optimal is: if we think about it as a graph we start with \(n \cdot m\) components and with one move we connect at most two into ones, so we need \(n \cdot m - 1\) move to make the graph connected, plus one to connect with the outside world.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1484&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1484b/&quot;&gt;
    Restore Modulo
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1484/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r709/1484b-restore-modulo.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s look at all the differences of consecutive elements.  We have few cases:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;if there’s just one distinct value we can choose infinitely many large \(m\)s.&lt;/li&gt;
  &lt;li&gt;if there are more than two distinct values then there is no answer.&lt;/li&gt;
  &lt;li&gt;why can we have two values?  Because one (positive) might be a “regular” one bumping up by \(c\) and the other one (negative) might be once we “wrap up” modulo \(m\).  In this case the positive one is \(c\) and \(m\) is the difference between the two.  What remains to be done is to check whether this is indeed a valid solution.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1484&lt;/tiny&gt;C / &lt;tiny&gt;1483&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1484c/&quot;&gt;
    Basic Diplomacy
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1484/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r709/1484c-basic-diplomacy.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;flows&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Greedy.  If there are days with \(0\) candidates there is no answer.  For days with \(1\) candidate let’s choose him.  From then one we have a choice and let’s greedily choose a friend that was used least times so far.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1484&lt;/tiny&gt;D / &lt;tiny&gt;1483&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1484d/&quot;&gt;
    Playlist
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1484/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r709/1484d-playlist.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dsu&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;It helps to first think how we would naively simulate it.  We need to remove entries so let’s keep everything on a doubly linked circular list.&lt;/p&gt;

&lt;p&gt;Why simple simulation is not good enough?  Because we can have an input like lots of \(2\)s followed by lots of \(3\) and we only do one deletion per “round” so this is going to be too slow.&lt;/p&gt;

&lt;p&gt;One way to speed it up is to in addition to regular pointers in the list add “shortcut” links.  If we go through a block \(a_1, \ldots a_n\) without doing any deletions and then finally do a deletion from \(a_n\) to \(b\) then we add shortcuts from \(a_1, \ldots a_{n-1}\) to \(a_n\) as those numbers (on their own) will never be reduced.&lt;/p&gt;

&lt;p&gt;From here on it’s just a matter of careful implementation; when done properly this is actually short and sweet.  What helps a lot is that we have a fixed initial size of the input so instead of doing any pointers we just store appropriate indices in static arrays.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1484&lt;/tiny&gt;E / &lt;tiny&gt;1483&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1484e/&quot;&gt;
    Skyline Photo
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1484/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1484&lt;/tiny&gt;F / &lt;tiny&gt;1483&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1484f/&quot;&gt;
    Useful Edges
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1484/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;shortest paths&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1483&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1483e/&quot;&gt;
    Vabank
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1483/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1483&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1483f/&quot;&gt;
    Exam
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1483/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dsu&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;string suffix structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-709.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Sun, 21 Mar 2021 00:00:00 +0000</pubDate>
        <link>//R-709</link>
        <link href="/R-709"/>
        <guid isPermaLink="true">/R-709</guid>
      </item>
    
  </channel>
</rss>
