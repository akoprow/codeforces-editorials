<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Codeforces editorials</title>
    <description>Codeforces editorials</description>
    <link></link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <author>
      <name>Adam Koprowski</name>
      <email>Adam.Koprowski@gmail.com</email>
      <uri></uri>
    </author>
    
      <item>
        <title>Educational Round 105</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1494&quot;&gt;Educational Codeforces Round 105 (Rated for Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1494&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1494a/&quot;&gt;
    
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1494/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  

  &lt;labels&gt;
  
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Probably the easiest solution is just to brute force it and try all combinations of parenthesis for all of \(A, B, C\), since there are only \(2^3 = 8\) combinations.  Alternatively, we can observe that the sequence must start with opening and must end with a closing parenthesis.&lt;/p&gt;

&lt;p&gt;Once we have a fixed meaning for every letter it’s just a matter of applying the classical algorithm of counting \(+1\) for opening and \(-1\) for closing parenthesis and the sequence is valid if:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;we never go below \(0\) (closing parenthesis that is unmatched) and&lt;/li&gt;
  &lt;li&gt;at the end we reach \(0\) (everything balanced out in the end)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1494&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1494b/&quot;&gt;
    
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1494/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  

  &lt;labels&gt;
  
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Note that the tricky bit is the corners.  Imagine we knew what’s in every corner.  Then the problem is easy as for every border we have \(n-2\) slots excluding corners and so the number of blocks we need to place there \(v\), which is the original constrain from the problem minus \(0\), \(1\), or \(2\) depending how many blocks are already in the two relevant corners, must be \(0 \le v \le n-2\).&lt;/p&gt;

&lt;p&gt;So now we can just try all the combinations for corners (filled/unfilled) since there are only \(2^4 = 16\) and apply the reasoning from above and clearly we have an answer overall if we have an answer for any of the configurations.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1494&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1494c/&quot;&gt;
    
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1494/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  

  &lt;labels&gt;
  
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, note that our position relative to the blocks cannot change.  Which means that the final solution can always be expressed as:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;going \(x\) steps to the right,&lt;/li&gt;
  &lt;li&gt;coming back to the origin.&lt;/li&gt;
  &lt;li&gt;going \(y\) steps to the left.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since the first step is only concerned with blocks/targets on the positive part of the axis and last step only with those on the negative part we can split this problem into two.&lt;/p&gt;

&lt;p&gt;So now we only have blocks/targets to the right of us and the question is: how many steps to the right should we make?&lt;/p&gt;

&lt;p&gt;Next observation is that the only configurations that we should consider are:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;don’t do anything and&lt;/li&gt;
  &lt;li&gt;stop just before &lt;em&gt;some&lt;/em&gt; target, i.e. at positions \(b_i-1\) for some \(i\).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Why is it enough to only consider configurations where we stop right before some target?  Imagine instead we stopped at position \(p\) such that position \(p+1\) is not special.  By moving there we will be pushing a number of boxes, let’s say \(t\) of them.  In this scenario the boxes are covering the segment \([p+1, p+t]\).  Let’s say that the closest special position is at \(p+q\) (\(q &amp;gt; 1\)).  If instead we moved to \(p+q-1\) (right before that special position) the boxes would cover \([p+q, p+q+v-1]\).  Comparing that with the original segment we lost some positions on the left, but none of them was special and we added some positions on the right, some of which might, so we end up with a not worse (and possibly better) outcome.&lt;/p&gt;

&lt;p&gt;Ok, so let’s start by computing how many boxes initially are at special positions.  That’s our initial score and it covers the first option above (don’t do anything).&lt;/p&gt;

&lt;p&gt;Now, let’s iterate over special positions.  We will be keeping track of how many boxes we’re pushing, \(t\), initially \(t=0\). Let’s call it our “train”.  Once we move to position \(b_i\) all the boxes to the left, i.e. all \(a_j &amp;lt; b_i\) will join our train.  But our train sits on \([b_i, b_i+t]\) so all the boxes in &lt;em&gt;that&lt;/em&gt; segment also join the train, so we need to be careful there when updating \(t\).&lt;/p&gt;

&lt;p&gt;Moreover, for every box that joins the train and was initially on a special position we must make sure to decrease our score by \(1\) (we removed a box from a special position).  However, we can add to the score the number of special positions in the segment \([b_i, b_it+t]\), which is where our train sits.  To efficiently compute that we can either use an appropriate data structure or do two binary searches to find left-most and right-most special position that falls in the range.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1494&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1494d/&quot;&gt;
    
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1494/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  

  &lt;labels&gt;
  
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1494&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1494e/&quot;&gt;
    
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1494/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  

  &lt;labels&gt;
  
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1494&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1494f/&quot;&gt;
    
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1494/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  

  &lt;labels&gt;
  
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/Edu-105.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Tue, 02 Mar 2021 00:00:00 +0000</pubDate>
        <link>//Edu-105</link>
        <link href="/Edu-105"/>
        <guid isPermaLink="true">/Edu-105</guid>
      </item>
    
      <item>
        <title>Global Round 13</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1491&quot;&gt;Codeforces Global Round 13&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1491&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1491a/&quot;&gt;
    K-th Largest Value
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1491/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/gr/gr13/1491a-kth-largest-value.kt&quot;&gt;(Code)&lt;/a&gt;

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Since we have \(n\) elements that are only \(0\) or \(1\) knowing how many \(1\)s (or \(0\)s) there are is enough to know what the \(k\)-th largest element will be (i.e. it will be \(1\) if we have at least \(k\) ones).  So it’s enough to keep track of the number of ones and update it appropriately when flipping some element.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1491&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1491b/&quot;&gt;
    Minimal Cost
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1491/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/gr/gr13/1491b-minimal-cost.kt&quot;&gt;(Code)&lt;/a&gt;

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s think about it geometrically , i.e. as if the obstacles where drawing a line (a pixelated one :).  To block us that line will need to:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;be uninterrupted (i.e. continuous) and&lt;/li&gt;
  &lt;li&gt;it can either go to the left border of the board (cutting us off) or to the bottom border (splitting the board into two).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What does it mean for the line to be uninterrupted?  It means that for consecutive rows the difference in columns is at most \(1\); otherwise we can “slip through”.&lt;/p&gt;

&lt;p&gt;When does it reach the left border?  When (uninterrupted) it reaches column \(0\).&lt;/p&gt;

&lt;p&gt;When does it reach the bottom border?  When (uninterrupted) it extends to the last row.&lt;/p&gt;

&lt;p&gt;Now, if neither condition is true, we can pass without any changes.&lt;/p&gt;

&lt;p&gt;If the line is a straight vertical line.  In this case we have two make two moves to move one obstacle out of the way: the first one to left/right and the second one either left/right or top/down, whichever is cheaper.&lt;/p&gt;

&lt;p&gt;In the remaining cases it’s always enough to move only one obstacle either up/down or left/right.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1491&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1491c/&quot;&gt;
    Pekora and Trampoline
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1491/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/gr/gr13/1491c-pekora-and-trampoline.kt&quot;&gt;(Code)&lt;/a&gt;

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, if we start jumping at trampoline \(i\), this will not affect any trampolines to the left of it.  Imagine there is an “unfinished” (value other than \(1\)) trampoline to the left.  We will have to jump starting from it, so we might as well start there, as jumping from \(i\) and then from \(j\) is at least as good, and potentially better!,  as jumping from \(j\) and then from \(i\) (\(j &amp;gt; i\)).&lt;/p&gt;

&lt;p&gt;So a greedy approach works: always start from the leftmost “unfinished” trampoline.&lt;/p&gt;

&lt;p&gt;How do we simulate it?  For each trampoline keep track of how many times it was reached previously (starting with all \(0\)); let’s call it \(d_i\).  When we consider position \(i\):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;we need to start afresh on it \(max(0, a_i - 1 - d_i)\) times and we need to add that value to the final result.&lt;/li&gt;
  &lt;li&gt;we will jump on it when it has values: \(a_i, a_i-1, \ldots, 2\) which means we need to increment \(d_{i+2}, \ldots d_{i + a_i}\) (as long as they are within bounds)&lt;/li&gt;
  &lt;li&gt;we will jump on it \(min(0, d_i - (a_i -1))\) with it having value \(1\), which is by how much we should increment \(d_{i+1}\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Amazingly, the source code to this problem is at most half the size of this text…&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1491&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1491d/&quot;&gt;
    Zookeeper and The Infinite Zoo
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1491/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/gr/gr13/1491d-zookeeper-and-the-infinite-zoo.kt&quot;&gt;(Code)&lt;/a&gt;

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Ok, firstly let’s try to understand what kind of moves can we do, exactly.  We can transition \(u \to u + v\) iff \(u \&amp;amp; v = u\).  In other words, we’re in \(u\) we can pick a sub-mask of \(u\) and add it to \(u\).&lt;/p&gt;

&lt;p&gt;Can we simplify this?  Note that if the sub-mask we pick has only one bit set then we have a transition \(u \to u + 2^i\) which will &lt;em&gt;not&lt;/em&gt; affect bits \(j &amp;lt; i\).  That in turns mean we can decompose a move \(u \to u + (2^{i_1} + 2^{i_2} + \ldots 2^{i_n})\) into \(n\) moves with single bit masks: \(u \to u + 2^{i_1} \to \ldots \to u + (2^{i_1} + 2^{i_2} + \ldots 2^{i_n})\) (\(i_1 &amp;gt; i_2 &amp;gt; \ldots i_n\)).&lt;/p&gt;

&lt;p&gt;So we can restrict our thinking to moves of the shape \(u \to u + 2^i\) and we know that bit \(i\) is set in \(u\).  How do such moves look like?&lt;/p&gt;

&lt;p&gt;If bit \(i+1\) in \(u\) is not set then what happens on those two bits is: \(01 + 01 = 10\), i.e. we shifted the bit to the left.  Let’s call this move &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If a number of higher bits in \(u\) is set then instead it looks like this: \(11\ldots11 + 01 = 100\ldots00\), i.e. we also shifted the highest bit to the left but also zeroed in a number of following \(1\)s.  Let’s call this type of move &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Those are the only two types of moves we can make so in particular:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;we can never move a bit to the right and&lt;/li&gt;
  &lt;li&gt;we can decrease but never increase the number of bits.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This starts looking like a skeleton of an algorithm.  Look at \(u\) and \(v\), if \(v &amp;gt; u\) the answer is clearly “NO”.  Same if \(v\) has more bits than \(u\).  Otherwise we will try to match bits in \(u\) to bits in \(v\), from least significant positions and for every match of bit \(i\) in \(u\) with bit \(j\) in \(v\) we want \(i \le j\) (remember, we can only shift to the left).&lt;/p&gt;

&lt;p&gt;Now the claim is that if such matching exists then the answer is “YES”.  This is not completely obvious as remember that \(u\) might have more bits than \(v\)!  However, we can always get rid of those bits with moves &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt;.  Formal argument follows (implicitly by induction on number of bits).&lt;/p&gt;

&lt;p&gt;We’re matching \(u\) with \(v\) and \(u \le v\).  First let’s assume that they both have the same highest bit set, so we have a match at that position and we can move to lower bits.&lt;/p&gt;

&lt;p&gt;If instead \(u = 0\ldots1_1\) and \(v = 1\ldots\) and \(u\) has \(p\) bits more set than \(u\) then we get rid of spurious \(1\)s with move &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; as follows (we index \(1\)s):&lt;/p&gt;

&lt;p&gt;\(u = 0 \ldots 1_1 \ldots 1_2 \ldots 1_3 \ldots 1_p \to 0 1_1 1_2 \ldots 1_p \to 10\ldots0\) so \(u\) and \(v\) now agree on the highest bits &lt;em&gt;and&lt;/em&gt; have the same number of \(1\)s so from now on we can finish the problem with moves &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; only.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1491&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1491e/&quot;&gt;
    Fib-tree
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1491/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;divide and conquer&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1491&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1491f/&quot;&gt;
    Magnets
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1491/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1491&lt;/tiny&gt;G

  
  &lt;a href=&quot;/codeforces-editorials/problems/1491g/&quot;&gt;
    Switch and Flip
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1491/problem/G&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1491&lt;/tiny&gt;H

  
  &lt;a href=&quot;/codeforces-editorials/problems/1491h/&quot;&gt;
    Yuezheng Ling and Dynamic Tree
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1491/problem/H&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1491&lt;/tiny&gt;I

  
  &lt;a href=&quot;/codeforces-editorials/problems/1491i/&quot;&gt;
    Ruler Of The Zoo
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1491/problem/I&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/GR-13.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Sun, 28 Feb 2021 00:00:00 +0000</pubDate>
        <link>//GR-13</link>
        <link href="/GR-13"/>
        <guid isPermaLink="true">/GR-13</guid>
      </item>
    
      <item>
        <title>Round 704 (Div II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1492&quot;&gt;Codeforces Round #704 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1492&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1492a/&quot;&gt;
    Three swimmers
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1492/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r704/1492a-three-swimmers.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Clearly the answer is the minimum over answers per lane.  For swimmer who does laps in \(a\) how long will we have to wait for him after arriving at time \(p\)?  Let’s look at \(a \mod p\).  If \(a \mod p = 0\) then he arrives just at the point when we do so the answer is \(0\); otherwise it’s \(a - a \mod p\) as we’ll need to wait for him to complete his lap.  Now take a minimum over answers for \(a, b, c\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1492&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1492b/&quot;&gt;
    Card Deck
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1492/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r704/1492b-card-deck.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Clearly at each point we want to split the deck so that we get the largest card first.  So at each point we need to find the index of the remaining max.  One way to do it is to have a sorted map from values to their indices.  We always operate on a segment of the deck of the form \([1, r]\) (\(1\)-based indexing for indices) with initially \(r = n\).  After finding that maximum is at index \(p\) we go from \(p\) to \(r\), add those cards to the answer and remove from our map with indices.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1492&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1492c/&quot;&gt;
    Maximum width
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1492/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r704/1492c-maximum-width.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;The problem can be seen as having to map all letters in \(t\) to equal letters in \(s\) (in the same order), in such a way that the gap between some two letters in \(s\) is as large as possible.  Firstly, for every \(i\) let’s compute \(mx_i\) and \(mn_i\) which are maximal and minimal, respectively, indices in \(s\) that we can match it with.  Once we have that then clearly the answer is just \(max_{i \in 1..m-1} mn_{i+1}-mn_i\).&lt;/p&gt;

&lt;p&gt;How do we compute them?  For \(mn_i\) a simple greedy approach works where we iterate over \(t\) and move a pointer over \(s\), matching it as soon as we can.  \(mx_i\) can be done in the same way, except matching greedily from the back.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1492&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1492d/&quot;&gt;
    Genius's Gambit
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1492/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1492&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1492e/&quot;&gt;
    Almost Fault-Tolerant Database
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1492/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-704.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate>
        <link>//R-704</link>
        <link href="/R-704"/>
        <guid isPermaLink="true">/R-704</guid>
      </item>
    
      <item>
        <title>Round 703 (Div II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1486&quot;&gt;Codeforces Round #703 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486a/&quot;&gt;
    Shifting Stacks
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r703/1486a-shifting-stacks.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s think what’s the minimal happy configuration.  Clearly it’s stacks with \(1, 2, 3, \ldots\), so if we don’t have that many blocks in total we won’t be able to make a right sequence.  Also, blocks can only move to the right and so the aforementioned condition needs to hold for every index.  If it does then we win as we can clearly send all the surplus above what’s required to the right.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486b/&quot;&gt;
    Eastern Exhibition
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r703/1486b-eastern-exhibition.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;geometry&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Clearly we can decompose this 2D problem into two 1D problems and then just multiply the results.  How do we solve a 1D problem?  Well, the optimal location is always at the median and if there there is an even number of elements than any position between two medians will do.  The intuition for that is clear: there are as many houses to the left as there are to the right so moving left increases the distance by \(1\) and at the same time, for the equal number of houses, decreases by \(1\), not changing it overall.  So if two median houses are at locations \(x_1\) and \(x_2\) (\(x_2 \ge x_1\))we just return the number of points between them, their locations included, that is \(x_2-x_1+1\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;C1

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486c1/&quot;&gt;
    Guessing the Greatest (easy version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/C1&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r703/1486c1-guessing-the-greatest-easy.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;It’s fairly easy to see that binary search is the way to go.  \(log_2 10^5 &amp;lt; 17\), so we can do \(2\) queries at every step.  How do we decide if the max is in the left or the right part?  Well, firstly let’s ask for the whole interval, i.e. \([l, r]\).  Assume that the answer, \(x\), is in the left part (other case is symmetrical), i.e. \(x \in [l, m]\) (\(m = \frac{l+r}{2}\)).  In that case let’s ask for that interval \([l, m]\).  If the answer is \(x\) again then that means that globally second element is there and it’s also a second element in the left part so max must be there as well; otherwise we go to the right part.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;C2

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486c2/&quot;&gt;
    Guessing the Greatest (hard version)
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/C2&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r703/1486c2-guessing-the-greatest-hard.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Now we need to be more efficient as \(2\) queries per move will not do anymore.&lt;/p&gt;

&lt;p&gt;Note how we were wasting some queries in our strategy?  I.e. if both answers were the same, so we asked for \([l, r]\) and \([l, m]\) (or \([m, r]\)) and got the same answer then we continue with the \([l, m]\) range (\([m, r]\)) and &lt;em&gt;don’t have to ask for it again&lt;/em&gt;.  The same is not true for the other case, but I thought that we can take advantage of this asymmetry: rather than making both intervals the same, let’s make them unequal so that the case where we have to ask twice gains us more.  Unfortunately a) the math does not work out (we still need more than \(20\) queries) and b) this reasoning is flawed as we &lt;em&gt;cannot&lt;/em&gt; pick which part the answer will be in and so don’t know which segment to make smaller/larger.&lt;/p&gt;

&lt;p&gt;Instead the solution is quite simple really.  Let’s get the global answer for \([1, n]\), say it’s \(x\).  Now let’s figure out whether our answer is to the left or to the right of \(x\), just as we did in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C1&lt;/code&gt;.  Let’s say that it’s to the right of \(x\) (the other case being symmetrical).  Note that our answer is simply the &lt;em&gt;smallest&lt;/em&gt; \(p \in [x+1, n]\) such that the answer for \([x, p]\) is \(x\).  That’s simply because if the global max is not in our range then the globally second element will &lt;em&gt;not&lt;/em&gt; be the second largest element in the range.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486d/&quot;&gt;
    Max Median
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486e/&quot;&gt;
    Paired Payment
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;shortest paths&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1486&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1486f/&quot;&gt;
    Pairs of Paths
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1486/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-703.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Thu, 18 Feb 2021 00:00:00 +0000</pubDate>
        <link>//R-703</link>
        <link href="/R-703"/>
        <guid isPermaLink="true">/R-703</guid>
      </item>
    
      <item>
        <title>Round 702 (Div III)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1490&quot;&gt;Codeforces Round #702 (Div. 3)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1490&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1490a/&quot;&gt;
    Dense Array
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1490/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r702/1490a-dense-array.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Clearly, whatever we insert between any two elements will not affect any other pair so we can solve each pair independently.  For a given pair \(a_i, a_{i+1}\) let’s take \(x = min(a_i, a_{i+1})\) and \(y = max(a_i, a_{i+1})\).  If \(2*x \ge y\) then we’re good.  Otherwise, we want to insert \(2x, 4x, 8x, \ldots\) and we can figure out how many of those elements we need with a simple loop.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1490&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1490b/&quot;&gt;
    Balanced Remainders
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1490/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r702/1490b-balanced-remainders.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Numbers don’t matter, only their remainder modulo \(3\).  Let’s count \(c_0, c_1, c_2\) being the number of elements with respective remainders.  In a single move we can decrement \(c_i\) and increment \(c_{(i+1) \mod 3}\).  One greedy approach that we can take is:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;as long as there’s \(c_i\) that is too large, take it and move it to “the next slot” (\(\mod 3\)).&lt;/li&gt;
  &lt;li&gt;it can be shown that at most two rounds through all \(c_i\) will do.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1490&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1490c/&quot;&gt;
    Sum of Cubes
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1490/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r702/1490c-sum-of-cubes.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Note that \(\sqrt[3]{10^{12}} = 10^4\), so in other words the largest number that is useful to use is \(10000\), so for all numbers up to that limit we can precompute their cubes and store in a set.  Then if we want to see if \(x\) can be represented as sum of cubes, iterate over stored cubes smaller than \(x\) and for each \(v^3\), check if \(x - v^3\) is in our precomputed set (i.e. is a cube of some number).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1490&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1490d/&quot;&gt;
    Permutation Transformation
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1490/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r702/1490d-permutation-transformation.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;divide and conquer&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We pretty much just do what the problem describes, via a recursion with three arguments: \((l, r, d)\) being the segment we still operate on \([l, r]\) and current depth \(d\).  We start with \((1, n, 0)\).  At a recursion step we find maximum in \(a_l, \ldots, a_r\) at position \(p\).  We denote \(d\) as the answer for \(a_p\) and we recursively descend into \((l, p-1, d+1)\) and \((p+1, r, d+1)\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1490&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1490e/&quot;&gt;
    Accidental Victory
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1490/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r702/1490e-accidental-victory.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s sort players by the number of tokens they have.  Note that problem speaks about possibility of winning so if we just find one scenario where we win that’s good enough for there to be a non-zero probability that this will actually happen, so that’s good enough.&lt;/p&gt;

&lt;p&gt;Firstly note that we can win with all the players that have not more tokens than we do and by doing so collect their tokens.  So we want to find the number of tokens that we need to have to win.  One option is by doing binary search.  Another is a more direct approach, which is linear after sorting and that’s what I did; see code for details.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1490&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1490f/&quot;&gt;
    Equalize the Array
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1490/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r702/1490f-equalize-the-array.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;The crucial observation is that the winning \(C\) must be a frequency of some element in the array.  And we can have at most \(\sqrt{n}\) different candidates for \(C\) (elements with counts \(1, 2, 3, \ldots\) has a quadratic growth).  So let’s just compute frequencies of all elements to get our candidates.&lt;/p&gt;

&lt;p&gt;Now for a given \(C\) computing the cost to make array \(C\)-beautiful is easy, as for a given element with \(x\) occurrences we have to pay:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(x\) if \(x &amp;lt; C\) as we need to remove all \(x\) copies.&lt;/li&gt;
  &lt;li&gt;\(0\) if \(x = C\),&lt;/li&gt;
  &lt;li&gt;\(x-C\) if \(x &amp;gt; C\) as we need to remove extra copies.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Then we simply pick the best option over all candidate \(C\)s.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1490&lt;/tiny&gt;G

  
  &lt;a href=&quot;/codeforces-editorials/problems/1490g/&quot;&gt;
    Old Floppy Drive 
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1490/problem/G&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r702/1490g-old-floppy-drive.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s start by computing all the points where the disk might stop in a single round, i.e. pairs \((p_i, v_i)\) point on disk \(1 \le p \le n\) and \(v_i = \sum_{i \le p} a_i\).  Note that those points will form an increasing sequence as if we had \(x\) followed by \(y\) and \(y &amp;lt; x\) then it we were to stop at \(y\) we’d have stopped instead at \(x\) before.  Once we have that for a single query we have few cases&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(x \le v_t\) assuming we have \(t\) pairs of possible stopping points.  In this case the disk will stop within the first spin and we can find the point where it stops with binary search.&lt;/li&gt;
  &lt;li&gt;\(x &amp;gt; v_t\) and \(\sum_{i \in 1..n} a_i \le 0\), which means we won’t reach the right point within the first spin and with every spin \(x\) is not increasing so it will never stop.&lt;/li&gt;
  &lt;li&gt;Otherwise, we compute how many full spins we need to get to \(x \le v_t\) (i.e. first case above).  So we know by how much we need to decrease \(x\) and hence how many full spins are required.  After that we’re back in the first case above.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-702.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Tue, 16 Feb 2021 00:00:00 +0000</pubDate>
        <link>//R-702</link>
        <link href="/R-702"/>
        <guid isPermaLink="true">/R-702</guid>
      </item>
    
      <item>
        <title>Educational Round 104</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1487&quot;&gt;Educational Codeforces Round 104 (Rated for Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1487&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1487a/&quot;&gt;
    Arena
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1487/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu104/1487a-arena.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Notice that if we have two heroes with levels \(a_i\) and \(a_j\) such that \(a_i &amp;gt; a_j\) then \(a_i\) can easily reach arbitrarily high level by continuing to fight with \(a_j\) over and over again.  So any hero that initially has at least one other hero who’s weaker than him can do that.  Also notice that if for any hero there is no one weaker than him initially then this will continue to be this case as the levels are only ever increasing and so such hero will forever remain at his level and won’t be able to reach \(100^{500}\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1487&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1487b/&quot;&gt;
    Cat Cycle
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1487/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu104/1487b-cat-cycle.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;The case when \(n\) is even is each as the cats never “collide”.&lt;/p&gt;

&lt;p&gt;Otherwise, we can see that they’ll collide every \(\lfloor \frac{n}{2} \rfloor\) moves, so in total they’ll collide \(C = \frac{k}{n/2}\) times.  Each collision means that cat \(A\) moves by \(2\) spots rather than \(1\) (since the next one is occupied) and so he’ll eventually reach position \(((k+C) % n\) (0-based).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1487&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1487c/&quot;&gt;
    Minimum Ties
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1487/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu104/1487c-minimum-ties.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;matrices&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We have a total of \(G = \frac{n \cdot (n-1)}{2}\) games and the number of wins for each team must be equal and so each team should win \(\lfloor \frac{G}{n} \rfloor\) times and also lose that many times.  How do we construct such schedule of games?  The easiest way is for team \(i\) to win against the following teams, i.e. \(i+1, i+2, \ldots\) (everything modulo \(n\)).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1487&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1487d/&quot;&gt;
    Pythagorean Triples
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1487/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu104/1487d-pythagorean-triples.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We need to have \(a^2 + b^2 = c^2\) and \(a^2 - c = b\).  If we subtract the second equation from the first we get:&lt;/p&gt;

\[b^2 + c = c^2 - b \iff b(b+1) = (c-1)c \iff b = c-1\]

&lt;p&gt;Now solving for \(a\):&lt;/p&gt;

\[a^2 - c = b \iff a^2 - (b+1)  = b \iff a^2 = 2b + 1\]

&lt;p&gt;For this to have a solution:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(a^2\) must be odd and so \(a\) must be odd and&lt;/li&gt;
  &lt;li&gt;\(a \neq 1\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Any \(a\) with those two constraints gives a unique solution for \(b\) and \(c\) and such that \(b &amp;lt; c &amp;lt; a \le n\) and so is valid.&lt;/p&gt;

&lt;p&gt;So we simply must compute the number of odd numbers \(a &amp;gt; 1\) such that \(a^2 \le n\).  Naive solution should be \(O(\sqrt(n))\) which should be good enough but I did that and got TLE so instead I used binary search to find the answer.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1487&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1487e/&quot;&gt;
    Cheap Dinner
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1487/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu104/1487e-cheap-dinner.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;For two courses we want to precompute cheapest valid combo of those courses for any choice of the first course.&lt;/p&gt;

&lt;p&gt;How do we combine it for 4 dishes?  Well, let’s start with drinks + desserts, for every drink computing the cheapest combo with a dessert. Now that we move to second courses note that we do not care any more which dessert went into the combo.  So let’s do second courses + drink/dessert combo, having best option for all three for every second course.  Finally we combine that with first courses and we’re done (the code to do it is shorter than this description…).&lt;/p&gt;

&lt;p&gt;So we just reduced this problem to two dishes only.  How do we solve that?  Well, let’s sort the second dish by increasing price and for every first dish let’s go though those options in order stopping at first for which the combo is not forbidden (or concluding there’s no option for the given first dish).  Note that the key here is that there are not too many forbidden combos so we know that the total work we’ll do is bounded by that, more precisely for \(n\) options for first dish, \(m\) for the second and \(f\) forbidden pairs, one pass costs us \(O(m \log{m} + max(n, f))\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1487&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1487f/&quot;&gt;
    Ones
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1487/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1487&lt;/tiny&gt;G

  
  &lt;a href=&quot;/codeforces-editorials/problems/1487g/&quot;&gt;
    String Counting
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1487/problem/G&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/Edu-104.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
        <link>//Edu-104</link>
        <link href="/Edu-104"/>
        <guid isPermaLink="true">/Edu-104</guid>
      </item>
    
      <item>
        <title>Round 701 (Div II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1485&quot;&gt;Codeforces Round #701 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1485&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1485a/&quot;&gt;
    Add and Divide
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1485/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r701/1485a-add-and-divide.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;ternary search&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;It’s fairly easy to realize that we want to increase \(b\) as much as possible before starting to divide by it (by looking at those two operations next to each other it’s obvious).  So just make sure that \(b\) isn’t \(1\) (if it is increase it once) and then keep on increasing \(b\) and for each one check what the score is by doing repeated division.  What’s the stop condition?  Once a given \(b\) gives us score worse than what we’ve got as a best one so far.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1485&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1485b/&quot;&gt;
    Replace and Keep Sorted
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1485/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r701/1485b-replace-and-keep-sorted.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Note that to make array \(k\)-similar we pick a position, say \(i\), and replace the value at that position to \(a_{i-1} &amp;lt; v &amp;lt; a_{i+1}\) and \(v \neq a_i\).&lt;/p&gt;

&lt;p&gt;It’s possible to compute things directly but the simplest solution (I think) is to use prefix sums.  Compute on each position how many \(k\)-similar arrays we can make by changing value at this position, which is trivial given the observation above.  Now for each query just take the sum over the segment, only be careful with segment boundaries as for them we now get more solutions as we loose part of the constraints.  So for a segment \([l, r]\) at position \(l\) we can put anything smaller than \(a_{l+1}\) and different than \(a_l\) so we have \(a_{l+1}-2\) options.  Similarly at position \(r\) we can put anything greater than \(a_{r-1}\) and different than \(a_r\) so we have \(k - a_{r-1} - 1\) options.  For the rest of the segment just take the sum using precomputed prefix sums.  Be careful for the case where \(l = r\) in which case any single number other than \(a_l\) is a solution.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1485&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1485c/&quot;&gt;
    Floor and Mod
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1485/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r701/1485c-floor-and-mod.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Let’s say that \(\lfloor \frac{a}{b} \rfloor = a \mod b = k\).  How do those pairs look like for \(k=1\)?  We must have \((v+1, v)\) as then \(\lfloor \frac{v+1}{v} \rfloor = 1 = (v+1) \mod v\).  Then for \(2\) we get: \((2v+2, v)\) with \(\lfloor \frac{2v+2}{v} \rfloor = 2 = 2v+2 \mod v\) etc.&lt;/p&gt;

&lt;p&gt;So let’s iterate over \(k\).  For a given \(k\) we have:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(a = kb + k\),&lt;/li&gt;
  &lt;li&gt;\(b &amp;gt; k\),&lt;/li&gt;
  &lt;li&gt;\(1 \le b \le y\),&lt;/li&gt;
  &lt;li&gt;\(a \le x\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Substituting \(a\) in the last equation we get: \(kb + k \le x\) so we end up with the following constraints on \(b\):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(b \le \frac{x}{k}-1\) and&lt;/li&gt;
  &lt;li&gt;\(k &amp;lt; b \le y\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So the number of solutions for a given \(k\) is: \(max(0, min(y, \frac{x}{k}-1) - k)\).  And from the fact that smallest \(a\) is \(k(k+1) + k\) and \(a \le x\), we easily get an upper bound of the number of iterations to be \(\sqrt{x}\).&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: I used a somewhat different reasoning in the live contest and never validated the above via a submission.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1485&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1485d/&quot;&gt;
    Multiples and Power Differences
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1485/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r701/1485d-multiples-and-power-differences.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2200 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2200&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;The trick is to realize that there are relatively few solutions and rather than looking for them we must find a trick that “always works”.  The idea is to divide the board into 2-colors so that we always have adjacent cells of different colors and then write into them \(p+q\) and \(p\).  From the problem we have the following constraints:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(p, q \ge 1\),&lt;/li&gt;
  &lt;li&gt;\(p\) is a multiple of the value in one of the cells,&lt;/li&gt;
  &lt;li&gt;\(p+q\) is a multiple of the value in the other cell,&lt;/li&gt;
  &lt;li&gt;\(q\) is equal to \(k^4\) for some \(k\),&lt;/li&gt;
  &lt;li&gt;\(p + q \le 10^6\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Can we find a \((p, q)\) pair that satisfies those constraints?  Turns out we can.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(p\) must be a multiple of a number in given cell (any cell) so our best bet is \(lcm(1, 2, \ldots 16) = 720720\).&lt;/li&gt;
  &lt;li&gt;\(q\) must be a multiple of a number in a given cell &lt;em&gt;and&lt;/em&gt; a \(4\)‘th power of some number so we can just take \(v^4\) where \(v\) is the value in the cell.&lt;/li&gt;
  &lt;li&gt;\(p + q = 720720 + v^4 \le 720720 + 16^4 = 786256 \le 10^6\).&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1485&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1485e/&quot;&gt;
    Move and Swap
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1485/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1485&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1485f/&quot;&gt;
    Copy or Prefix Sum
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1485/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2400 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2400&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;combinatorics&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;sortings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-701.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Fri, 12 Feb 2021 00:00:00 +0000</pubDate>
        <link>//R-701</link>
        <link href="/R-701"/>
        <guid isPermaLink="true">/R-701</guid>
      </item>
    
      <item>
        <title>Round 700 (Div I+II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1479&quot;&gt;Codeforces Round #700 (Div. 1)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1480&quot;&gt;Codeforces Round #700 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1480&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1480a/&quot;&gt;
    Yet Another String Game
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1480/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r700/1480a-yet-another-string-game.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;games&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Since we’re looking at lexicographic ordering, it’s pretty clear everyone in their move should always change the most significant available letter.  Note that even if it’s Alice’s turn and the first character is “a”, so she cannot improve it from her point of view, she should still change it to “b” (next best), because if she did not Bob would next change it to “z”!&lt;/p&gt;

&lt;p&gt;So Alice changes all letters at odd positions and Bob at even positions.  Alice changes to “a” if possible, or “b” otherwise and Bob changes to “z” if possible and “y” otherwise.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1480&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1480b/&quot;&gt;
    The Great Hero
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1480/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r700/1480b-the-great-hero.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Clearly we need \(\lceil \frac{b_i}{A} \rceil\) rounds to kill monster \(i\) and in the process we will sustain \(a_i \cdot \lceil \frac{b_i}{A} \rceil\) damage.  Our health needs to remain above zero for all, except perhaps the last round.  So let’s pick the largest \(a_i\), i.e. we will leave monster \(i\) as the last to fight, and check if:&lt;/p&gt;

\[B &amp;gt; \sum_i {a_i \cdot \lceil \frac{b_i}{A} \rceil} - \max_i {a_i}\]

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1480&lt;/tiny&gt;C / &lt;tiny&gt;1479&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1480c/&quot;&gt;
    Searching Local Minimum
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1480/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r700/1480c-searching-local-minimum.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;interactive&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Binary search is the answer.  Our goal is to maintain a segment \([l, r]\) such that \(a_{l-1} &amp;gt; a_l\) and \(a_{r+1} &amp;gt; a_r\).  Those two boundary conditions ensure that there must be a local minimum within the segment.  We start with \([1, n]\), where those inequalities hold “in absentia” (also note that there must be a minimum in \([1, n]\) as it contains \(1\) which is a minimum).&lt;/p&gt;

&lt;p&gt;Now how do we perform the step in binary search?  Let’s pick \(m\) in the middle of \([l, r]\) as usual.  However, just asking for \(a_m\) is not enough, we must also ask for \(a_{m+1}\).  Now we have the following options:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(a_{m+1} &amp;lt; a_m\) in which case we continue with \([m+1, r]\), as it clearly fulfils our conditions,&lt;/li&gt;
  &lt;li&gt;\(a_m &amp;gt; a_{m+1}\) and then we continue with \([l, m]\).&lt;/li&gt;
  &lt;li&gt;we cannot have \(a_m = a_{m+1}\) as all numbers are distinct in a permutation.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1480&lt;/tiny&gt;D1 / &lt;tiny&gt;1479&lt;/tiny&gt;B1

  
  &lt;a href=&quot;/codeforces-editorials/problems/1480d1/&quot;&gt;
    Painting the Array I
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1480/problem/D1&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r700/1480d1-painting-the-array-i.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;The following greedy strategy works, let’s construct two optimal subsequences and their last elements (as only those matter) be \(a_l\) and \(a_r\) and we’re now looking at element \(b\).  Then:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;if \(a_l = b\) and \(a_r \neq b\) then assign \(b\) to the right subsequence and we increase the score by \(1\).&lt;/li&gt;
  &lt;li&gt;similarly, if \(a_r = b\) and \(a_l \neq b\) then assign \(b\) to the left subsequence and we increase the score by \(1\).&lt;/li&gt;
  &lt;li&gt;if \(a_l = a_r = b\) then clearly it does not matter to which sequence we assign it.&lt;/li&gt;
  &lt;li&gt;finally if \(a_l \neq b\) and \(a_r \neq b\) then assign \(b\) then check whether in the remaining subsequence we will first get another \(a_l\) or another \(a_r\).  In the former case assign \(b\) to \(a_l\), in the latter to \(a_r\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Formally proving that this works is not trivial.&lt;/p&gt;

&lt;p&gt;I had a completely different reasoning to this which goes something likes this (and unfortunately does not generalize to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;D2&lt;/code&gt;):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;let’s count the longest blocks of equal numbers&lt;/li&gt;
  &lt;li&gt;if the block has one element we can always score \(1\) for it.&lt;/li&gt;
  &lt;li&gt;no matter how long the block we can never score more than \(2\) for it, as at best we can start two new segments in \(a_l\) and \(a_r\).&lt;/li&gt;
  &lt;li&gt;but clearly we cannot always score \(2\) as in the sequence: \(2, 2, 1, 2, 2\).&lt;/li&gt;
  &lt;li&gt;let’s keep count of: last seen double and number of “neutral” elements, starting with no doubles and 0 neutral elements.&lt;/li&gt;
  &lt;li&gt;if we see a single number then if it’s equal to last seen double then we decrement the number of “neutral” elements, otherwise we increment it and regardless we increase score by one.&lt;/li&gt;
  &lt;li&gt;if we get two neutral elements then we can forget about the last double, it’s been neutralized by them (i.e. we know that in both \(a_l\) and \(a_r\) last element is different to it).&lt;/li&gt;
  &lt;li&gt;if we see a second number that is different than the last double then we increment the score by one, reset neutral elements and remember that this element is the new double.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1480&lt;/tiny&gt;D2 / &lt;tiny&gt;1479&lt;/tiny&gt;B2

  
  &lt;a href=&quot;/codeforces-editorials/problems/1480d2/&quot;&gt;
    Painting the Array II
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1480/problem/D2&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r700-719/r700/1480d2-painting-the-array-ii.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;The generic greedy solution from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;D1&lt;/code&gt; generalizes, only if we see an element that is different than both \(a_l\) and \(a_r\) then we assign it to the sequence whose front element comes &lt;em&gt;sooner&lt;/em&gt; rather than &lt;em&gt;later&lt;/em&gt;.  Showing that it works is not easy.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1480&lt;/tiny&gt;E / &lt;tiny&gt;1479&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1480e/&quot;&gt;
    Continuous City
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1480/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1479&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1479d/&quot;&gt;
    Odd Mineral Resource
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1479/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2900 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2900&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;probabilities&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1479&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1479e/&quot;&gt;
    School Clubs
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1479/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;fft&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;number theory&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;probabilities&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-700.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate>
        <link>//R-700</link>
        <link href="/R-700"/>
        <guid isPermaLink="true">/R-700</guid>
      </item>
    
      <item>
        <title>Round 699 (Div II)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1481&quot;&gt;Codeforces Round #699 (Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1481&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1481a/&quot;&gt;
    Space Navigation
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1481/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r699/1481a-space-navigation.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:800 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;800&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Firstly, all the talk about reordering is a distraction as the order of instructions has no impact on the final coordinate.  Further, observe that we can easily decompose this 2D problem into two 1D problems along both axis.  Let’s denote by \(\mathcal{T}_U, \mathcal{T}_D, \mathcal{T}_L, \mathcal{T}_R\) the total number of steps that we can make in the respective direction (i.e. \(U, D, L, R\)).  The minimal coordinate we can reach along \(X\) axis is \(-\mathcal{T}_L\) and that’s by keeping all \(L\) moves and deleting all \(R\) instructions.  Similarly the maximal is \(R\).  And we can reach anything in between by deleting some more instructions from those extreme configurations.  So we can reach \([-\mathcal{T}_L, \mathcal{T}_R]\) along the \(X\)-axis and \([-\mathcal{T}_U, \mathcal{T}_D]\) along the \(Y\)-axis and we just need to check if our target lies within that rectangle.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1481&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1481b/&quot;&gt;
    New Colony
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1481/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r699/1481b-new-colony.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We just need to make a simple observation that if we reach a configuration where a boulder falls into the collection system then clearly all the subsequent ones will too.  And moreover since all heights are at most \(100\), this game will have at most \(100\cdot n\) steps before it’s over.  So we can just do the simulation of the boulder falling and even with the naive approach we end up with a \(O(100\cdot n^2)\) solution which is plenty good.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1481&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1481c/&quot;&gt;
    Fence Painting
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1481/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r699/1481c-fence-painting.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Crucial observation here is that the last painter is the key, as whatever he paints will have to remain of color \(c_m\).  Let’s find \(i\) such that \(b_i = c_m\).  We have three options:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(a_i \neq b_i\), we prefer this option over the next one, as in this way the work of the last painter is useful and we might have to make use of that in order to get to the solution,&lt;/li&gt;
  &lt;li&gt;\(a_i = b_i\), in which case his work wasn’t necessarily required but we end up with the right color and clearly we did not have the need for painting anything in this color (if we did, we’d have fallen into the previous case),&lt;/li&gt;
  &lt;li&gt;there is no \(i\) such that \(b_i = c_m\), in which case clearly there is no solution as the painter has to paint and some plank will end up with that color.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If we fell into one of the first two cases then all that remains is for the remaining painters to greedily one by one:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;if the painter paints in a color that we need for some plank then let’s use him there,&lt;/li&gt;
  &lt;li&gt;otherwise let’s make him paint plank \(i\), as the last painter will repaint in anyway.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now we only need to check if we repainted all the planks that needed repainting and we’re done.&lt;/p&gt;

&lt;p&gt;My solution during the live round was somewhat more complicated than that.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1481&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1481d/&quot;&gt;
    AB Graph
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1481/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r699/1481d-ab-graph.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:2000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;Nice one!  Firstly, let’s get rid of a trivial case: if we have two nodes, say \(u\) and \(v\), connected with the same letter in both directions, i.e. \(u \stackrel{a}{\leftrightarrow} v\) or \(u \stackrel{b}{\leftrightarrow} v\), then we can just follow this cycle for \(m\) steps and get a single repeated letter, which is trivially a palindrome.&lt;/p&gt;

&lt;p&gt;Another easy case is when \(m\) is odd.  Then we can just pick any two nodes and go in the loop between for the required number of steps and no matter what letters on them, we’ll get a palindrome.&lt;/p&gt;

&lt;p&gt;So what remains is an even \(m\) with a graph with no trivial same-letter loop.  Note that in this case we can have at most one node that is connected to everything else by \(a\) (if there were two we’d have an \(a\)-cycle between them) and at most one node that is connected to everything else by \(b\); all the other nodes must have at least one \(a\) and at least one \(b\) connection.  Let’s pick such a node.  Node that it’s impossible only if our graph has only 2 nodes  \(u \leftrightarrow v\) with two different letters, in which case clearly we cannot construct an even length palindrome.  Otherwise, we have a situation like this:&lt;/p&gt;

\[x \underset{a}{\overset{b}{\leftrightarrows}} y \underset{a}{\overset{b}{\leftrightarrows}} z\]

&lt;p&gt;The crucial observation is that we can always make an even length palindrome in this configuration.  The winning combo is: \(y \to^a z \to^b y \to^b x \to^a y \to \ldots\), only depending on whether \(\frac{m}{2}\) is even or odd, we need to start at second or first element, respectively.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1481&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1481e/&quot;&gt;
    Sorting Books
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1481/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2500 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2500&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1481&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1481f/&quot;&gt;
    AB Tree
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1481/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;trees&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/R-699.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Fri, 05 Feb 2021 00:00:00 +0000</pubDate>
        <link>//R-699</link>
        <link href="/R-699"/>
        <guid isPermaLink="true">/R-699</guid>
      </item>
    
      <item>
        <title>Educational Round 103</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1476&quot;&gt;Educational Codeforces Round 103 (Rated for Div. 2)&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;A

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476a/&quot;&gt;
    K-divisible Sum
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/A&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu103/1476a-k-divisible-sum.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;constructive algorithms&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We essentially have three cases:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(n \ge k\) and \(n\) is divisible by \(k\) then the answer is \(1\) as all elements equal to \(1\) are a correct solution&lt;/li&gt;
  &lt;li&gt;\(n \ge k\) but \(n\) not divisible by \(k\) then the answer is \(2\) as all \(1\) is not divisible by \(k\) and we need to bump up some elements to \(2\).&lt;/li&gt;
  &lt;li&gt;\(k &amp;lt; n\) the answer is \(\lceil \frac{k}{n} \rceil\) as we are aiming for the total sum to be \(k\) in this case and that’s the maximum we will need to put in a single element.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;B

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476b/&quot;&gt;
    Inflation
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/B&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu103/1476b-inflation.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;binary search&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;brute force&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;math&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;We want:&lt;/p&gt;

\[\frac{p_i}{p_0 + \ldots + p_{i-1}} \le \frac{k}{100}\]

&lt;p&gt;or, equivalently:&lt;/p&gt;

\[100 \cdot p_i \le k \cdot (p_0 + \ldots + p_{i-1})\]

&lt;p&gt;We compute that by keeping track of the running sum.  If at any point the equation does not hold we compute the delta by which we need to increase the running sum, i.e.:&lt;/p&gt;

\[\lceil \frac{100 \cdot p_i - k \cdot (p_0 + \ldots + p_{i-1}}{k} \rceil\]

&lt;p&gt;we update the running sum and continue further.  The sum of all the deltas is our answer.&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;C

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476c/&quot;&gt;
    Longest Simple Cycle
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/C&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu103/1476c-longest-simple-cycle.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1600 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1600&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;greedy&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;It’s clear that the cycle’s right side will be one of the chains.  So we’ll iterate over that chain, \(i\), and will keep track of the current longest cycle that we can built to the left of \(i\), let’s call that \(q_i\).  To simplify things, notice that we can swap \(a_i\) and \(b_i\) without influencing the result, so let’s normalize it so that always \(a_i &amp;lt; b_i\).&lt;/p&gt;

&lt;p&gt;We have two cases.  If \(a_i = b_i\) then the current chain is connected to the same vertex so \(q_i = 2\) as we can only use the two links to that vertex.&lt;/p&gt;

&lt;p&gt;Otherwise we have two options (a picture is worth a thousand words so see notes for a diagram)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;either we follow the links to the previous chain and then follow that chain, that gives us \(2 + b_i - a_i\) or&lt;/li&gt;
  &lt;li&gt;we follow the links and then combine it with the longest cycle so far for \(2 + q_{i-1} + (a_i - 1) + (c_{i-1} - b_i)\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We combine those two options for the final formula:&lt;/p&gt;

\[q_i = 2 + max(b_i - a_i, q_{i-1} + (a_i - 1) + (c_{i-1} - b_i))\]

&lt;p&gt;Now at each position we close the cycle so need to add the path traversed along the last chain so the final answer is \(max_i (q_i + c_i - 1)\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;D

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476d/&quot;&gt;
    Journey
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/D&quot;&gt;
  [CF]
  &lt;/a&gt;

  &lt;a href=&quot;https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/edu/edu103/1476d-journey.kt&quot;&gt;(Code)&lt;/a&gt;

  &lt;rating&gt;R:1700 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;1700&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dsu&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;p&gt;The crucial observation is that if we start at city \(i\) and move to other city \(j\), we can always come back to \(i\).  We can easily see that that’s possible after one step and we can prove it for arbitrary number of steps by induction (or just convince ourselves that it works by observing \(2\) or \(3\) steps).&lt;/p&gt;

&lt;p&gt;So now for each city we compute \(L(i)\) and \(L_{rev}(i)\) denoting how many steps to the left can we move from city \(i\) in initial/reversed setup (all arrows reversed), respectively.  We have \(L(i) = L_{rev}(i-1)+1\) if \(s_{i-1} = &quot;L&quot;\) and \(0\) otherwise.  Similarly \(L_{rev}(i) = L(i-1) + 1\) if \(s_{i-1} = &quot;R&quot;\) and \(0\) otherwise.&lt;/p&gt;

&lt;p&gt;Now, we do the same for \(R(i)\) and \(R_rev(i)\) to compute our moves to the right.  And we combine it for each city by seeing how far we can go to the left and right, plus the city itself, giving us the final answer for city \(i\) of: \(L_i + R_i + 1\).&lt;/p&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;E

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476e/&quot;&gt;
    Pattern Matching
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/E&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:2300 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;2300&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;bitmasks&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dfs and similar&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;graphs&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;implementation&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;strings&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;F

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476f/&quot;&gt;
    Lanterns
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/F&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3000 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3000&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;dp&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
  
  &lt;tiny&gt;1476&lt;/tiny&gt;G

  
  &lt;a href=&quot;/codeforces-editorials/problems/1476g/&quot;&gt;
    Minimum Difference
  &lt;/a&gt;
  &lt;a href=&quot;https://codeforces.com/contest/1476/problem/G&quot;&gt;
  [CF]
  &lt;/a&gt;

  

  &lt;rating&gt;R:3100 &lt;meter min=&quot;800&quot; max=&quot;3600&quot; value=&quot;3100&quot; /&gt;&lt;/rating&gt;

  &lt;labels&gt;
  
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;data structures&lt;/span&gt;
  
    &lt;span class=&quot;badge rounded-pill bg-warning text-dark&quot;&gt;two pointers&lt;/span&gt;
  
  &lt;/labels&gt;
&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;object data=&quot;notes/Edu-103.pdf&quot; width=&quot;1000&quot; height=&quot;1000&quot; type=&quot;application/pdf&quot; /&gt;

</description>
        <pubDate>Fri, 29 Jan 2021 00:00:00 +0000</pubDate>
        <link>//Edu-103</link>
        <link href="/Edu-103"/>
        <guid isPermaLink="true">/Edu-103</guid>
      </item>
    
  </channel>
</rss>
