<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no"">
  <meta name="generator" content="Jekyll">

  <title>Round 690 (Div III)</title>

  <!-- Bootstrap -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/js/bootstrap.bundle.min.js" integrity="sha384-ygbV9kiqUc6oa4msXn9868pTtWMgiQaeYH7/t7LECLbyPA2x65Kgf80OJFdroafW" crossorigin="anonymous"></script>

  <link rel="stylesheet" href="/codeforces-editorials/css/main.css">

  <link href="/codeforces-editorials/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Round 690 (Div III) | Codeforces editorials</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Round 690 (Div III)" />
<meta name="author" content="Adam Koprowski" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Codeforces Round #690 (Div. 3)" />
<meta property="og:description" content="Codeforces Round #690 (Div. 3)" />
<meta property="og:site_name" content="Codeforces editorials" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-12-15T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Round 690 (Div III)" />
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"Round 690 (Div III)","dateModified":"2020-12-15T00:00:00+00:00","url":"/codeforces-editorials/R-690","datePublished":"2020-12-15T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"/codeforces-editorials/R-690"},"author":{"@type":"Person","name":"Adam Koprowski"},"description":"Codeforces Round #690 (Div. 3)","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
    extensions: [
      "MathMenu.js",
      "MathZoom.js",
      "AssistiveMML.js",
      "a11y/accessibility-menu.js"
    ],
    jax: ["input/TeX", "output/CommonHTML"],
    TeX: {
      extensions: [
        "AMSmath.js",
        "AMSsymbols.js",
        "noErrors.js",
        "noUndefined.js",
      ]
    }
  });
  </script>
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-SHM3SPE7F9"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-SHM3SPE7F9');
  </script>
</head>


<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/codeforces-editorials/">
    
    <h1>adam@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/codeforces-editorials/"><h2 class="header-link">Contests</h2></a>
<a href="/codeforces-editorials/problems"><h2 class="header-link">Problems</h2></a>
<a href="/codeforces-editorials/todo"><h2 class="header-link">TODO</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>Round 690 (Div III)</h2>
  <time datetime="2020-12-15T00:00:00+00:00" class="by-line">15 Dec 2020</time>
  <p><a href="https://codeforces.com/contest/1462">Codeforces Round #690 (Div. 3)</a></p>

<div class="alert alert-primary" role="alert">
  
  <tiny>1462</tiny>A

  
  <a href="/codeforces-editorials/problems/1462a/">
    Favorite Sequence
  </a>
  <a href="https://codeforces.com/contest/1462/problem/A">
  [CF]
  </a>

  <a href="https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r690/1462a-favorite-sequence.kt">(Code)</a>

  <rating>R:800 <meter min="800" max="3600" value="800" /></rating>

  <labels>
  
  
    <span class="badge rounded-pill bg-warning text-dark">implementation</span>
  
    <span class="badge rounded-pill bg-warning text-dark">two pointers</span>
  
  </labels>
</div>

<p>We simply need to reverse the process.  We can do that by either maintaining two pointers or by deriving the formula for the element to take based on the parity of the result index.</p>

<div class="alert alert-primary" role="alert">
  
  <tiny>1462</tiny>B

  
  <a href="/codeforces-editorials/problems/1462b/">
    Last Year's Substring
  </a>
  <a href="https://codeforces.com/contest/1462/problem/B">
  [CF]
  </a>

  <a href="https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r690/1462b-last-years-substring.kt">(Code)</a>

  <rating>R:800 <meter min="800" max="3600" value="800" /></rating>

  <labels>
  
  
    <span class="badge rounded-pill bg-warning text-dark">dp</span>
  
    <span class="badge rounded-pill bg-warning text-dark">implementation</span>
  
    <span class="badge rounded-pill bg-warning text-dark">strings</span>
  
  </labels>
</div>

<p>One option is to match the prefix with “2020” and similarly the suffix (in reverse).  If the sum of those matched substrings is at least \(4\) then it means that the answer is positive.</p>

<p>Alternatively we can observe that we need to end up with a \(4\) characters string, which means that we need to delete \(n-4\) contiguous characters.  There are at most 5 ways to pick them and we can try them all and check whether what’s left matches “2020”.  In other words for \((x, y)\) we take \(x\) character prefix and \(y\) character suffix and we do that for: \((0, 4), (1, 3), (2, 2), (3, 1), (4, 0)\).</p>

<div class="alert alert-primary" role="alert">
  
  <tiny>1462</tiny>C

  
  <a href="/codeforces-editorials/problems/1462c/">
    Unique Number
  </a>
  <a href="https://codeforces.com/contest/1462/problem/C">
  [CF]
  </a>

  <a href="https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r690/1462c-unique-number.kt">(Code)</a>

  <rating>R:900 <meter min="800" max="3600" value="900" /></rating>

  <labels>
  
  
    <span class="badge rounded-pill bg-warning text-dark">brute force</span>
  
    <span class="badge rounded-pill bg-warning text-dark">greedy</span>
  
    <span class="badge rounded-pill bg-warning text-dark">math</span>
  
  </labels>
</div>

<p>Given the ridiculously low limit on \(x\) it was possible to just precompute all solutions by a naive brute-force.</p>

<p>If we want to solve it “properly” then a number of observations:</p>

<ul>
  <li>Zeroes are useless (they increase the number but do not increase the sum)</li>
  <li>Numbers should go in increasing order (order does not matter for the sum but smaller digits on more significant positions will lead to a smaller number)</li>
  <li>We can check what’s the minimal number of digits by considering a prefix of \(987654321\) until reaching (or exceeding) the required sum.</li>
  <li>If we found some answer in the following step then we optionally need to decrease it by the difference between its sum and the required sum.  That difference will always be at most \(8\) and it’s always optimal to decrease the initial \(9\).</li>
</ul>

<div class="alert alert-primary" role="alert">
  
  <tiny>1462</tiny>D

  
  <a href="/codeforces-editorials/problems/1462d/">
    Add to Neighbour and Remove
  </a>
  <a href="https://codeforces.com/contest/1462/problem/D">
  [CF]
  </a>

  <a href="https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r690/1462d-add-to-neighbour-and-remove.kt">(Code)</a>

  <rating>R:1400 <meter min="800" max="3600" value="1400" /></rating>

  <labels>
  
  
    <span class="badge rounded-pill bg-warning text-dark">greedy</span>
  
    <span class="badge rounded-pill bg-warning text-dark">math</span>
  
    <span class="badge rounded-pill bg-warning text-dark">number theory</span>
  
  </labels>
</div>

<p>Note that our operations essentially mean that we can collapse a block of contiguous elements into one equal to the sum of elements we collapsed.  And after doing that all elements must be equal.  Which means we must find blocks that can be collapsed to the required sum.</p>

<p>We know what’s the required sum.  Let’s say we know the solution ends up with \(k\) blocks.  Then each block must have a sum of: \(\frac{\sum_i a_i}{k}\) since all operations preserve the total sum.  If that number is not an integer then clearly such \(k\) cannot work.  If it is then it remains to be checked greedily whether we can find blocks summing up to that value.</p>

<p>All that remains to be done is to check all \(k\) in decreasing order from \(n\) (no operations at all) to \(1\) (everything collapsed to a single element, which is always a valid answer).</p>

<div class="alert alert-primary" role="alert">
  
  <tiny>1462</tiny>E1

  
  <a href="/codeforces-editorials/problems/1462e1/">
    Close Tuples (easy version)
  </a>
  <a href="https://codeforces.com/contest/1462/problem/E1">
  [CF]
  </a>

  <a href="https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r690/1462e1-close-tuples-easy.kt">(Code)</a>

  <rating>R:1500 <meter min="800" max="3600" value="1500" /></rating>

  <labels>
  
  
    <span class="badge rounded-pill bg-warning text-dark">binary search</span>
  
    <span class="badge rounded-pill bg-warning text-dark">combinatorics</span>
  
    <span class="badge rounded-pill bg-warning text-dark">math</span>
  
    <span class="badge rounded-pill bg-warning text-dark">sortings</span>
  
    <span class="badge rounded-pill bg-warning text-dark">two pointers</span>
  
  </labels>
</div>

<p>Let’s say the minimum number in a triple we consider is \(k\).  Let’s denote by \(n_{eq}\) the number of elements \(a_i = k\) and by \(n_{gt}\) the number of elements in \(a_i \in \{k+1, k+2\}\).</p>

<p>We have the following options for the formation of the triple:</p>

<ul>
  <li>all elements equal to \(k\); there are \({n_{eq}}\choose{3}\) such configurations.</li>
  <li>two elements equal to \(k\), one greater; there are \({n_{eq}\choose{2}} \cdot n_{gt}\) such configurations.</li>
  <li>one element equal to \(k\), two greater; there are \(n_{eq} \cdot {n_{gt}\choose{2}}\) such configurations.</li>
</ul>

<p>We now need to sum those values over all possible \(k\)s and we’re done.</p>

<div class="alert alert-primary" role="alert">
  
  <tiny>1462</tiny>E2

  
  <a href="/codeforces-editorials/problems/1462e2/">
    Close Tuples (hard version)
  </a>
  <a href="https://codeforces.com/contest/1462/problem/E2">
  [CF]
  </a>

  <a href="https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r690/1462e2-close-tuples-hard.kt">(Code)</a>

  <rating>R:1700 <meter min="800" max="3600" value="1700" /></rating>

  <labels>
  
  
    <span class="badge rounded-pill bg-warning text-dark">binary search</span>
  
    <span class="badge rounded-pill bg-warning text-dark">combinatorics</span>
  
    <span class="badge rounded-pill bg-warning text-dark">implementation</span>
  
    <span class="badge rounded-pill bg-warning text-dark">math</span>
  
    <span class="badge rounded-pill bg-warning text-dark">sortings</span>
  
    <span class="badge rounded-pill bg-warning text-dark">two pointers</span>
  
  </labels>
</div>

<p>Note that the order does not matter so let’s assume that the array is sorted in an ascending order for ease of reasoning (and let’s actually sort it so).  Now we’ll consider numbers from left to right as the potential minimal elements in a triple, so that all the remaining elements of the triple must be to their right.  Once we consider a number \(v\) at a given position we use binary search to find index of the element \(v+k\) to the right of it.  So now  know how many elements, other than \(v\) itself, fall into the \([v, v+k]\) segment which can be used to form a triple “rooted” at \(v\), if there are \(n\) such elements then they add \(n\choose{m-1}\) to the answer (\(v\) is the \(m\)‘th element).  What remains to be done is to be sure to precompute factorials so that we can compute those binomial coefficients efficiently.</p>

<div class="alert alert-primary" role="alert">
  
  <tiny>1462</tiny>F

  
  <a href="/codeforces-editorials/problems/1462f/">
    The Treasure of The Segments
  </a>
  <a href="https://codeforces.com/contest/1462/problem/F">
  [CF]
  </a>

  <a href="https://github.com/akoprow/competetive-programming/blob/master/src/codeforces/r680-699/r690/1462f-the-treasure-of-the-segments.kt">(Code)</a>

  <rating>R:1800 <meter min="800" max="3600" value="1800" /></rating>

  <labels>
  
  
    <span class="badge rounded-pill bg-warning text-dark">binary search</span>
  
    <span class="badge rounded-pill bg-warning text-dark">data structures</span>
  
    <span class="badge rounded-pill bg-warning text-dark">greedy</span>
  
  </labels>
</div>

<p>This basically comes down to a single observation.  Let’s say we consider a segment \([l, r]\).  What can we say about a segment \([p, q]\) that does <strong>not</strong> intersect it?  Well, it’s either:</p>

<ul>
  <li>\(p &gt; r\) or</li>
  <li>\(q &lt; l\) and</li>
  <li>crucially, it cannot be both.</li>
</ul>

<p>So we can just form an array of all beginnings of segments (sorted) and all endings (sorted) and use them with a binary search to quickly compute for a given \([l, r]\) segment how many segments it does not intersect (we will need to remove that many to form an answer).  Now we just pick the best answer over all initial segments and we’re done.</p>

<hr />

<object data="notes/R-690.pdf" width="1000" height="1000" type="application/pdf" />


</article>
      </section>
    </div>
  </div>

   <footer>
  <a href="https://creativecommons.org/licenses/by-nc/3.0/deed.en_US">
    <span>
        <b>Adam Koprowski</b>
    </span>
    
    <span>© 2021</span>
  </a>
</footer>

  
</body>

</html>
